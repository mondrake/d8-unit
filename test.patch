diff --git a/core/lib/Drupal/Core/Database/Connection.php b/core/lib/Drupal/Core/Database/Connection.php
index 142e452ceb..73733197a2 100644
--- a/core/lib/Drupal/Core/Database/Connection.php
+++ b/core/lib/Drupal/Core/Database/Connection.php
@@ -3,6 +3,7 @@
 namespace Drupal\Core\Database;
 
 use Drupal\Component\Assertion\Inspector;
+use Drupal\Component\EventDispatcher\Event;
 use Drupal\Core\Database\Query\Condition;
 use Drupal\Core\Database\Query\Delete;
 use Drupal\Core\Database\Query\Insert;
@@ -1865,4 +1866,98 @@ public function hasJson(): bool {
     }
   }
 
+  /**
+   * @todo
+   */
+  public function areStatementEventsEnabled(): bool {
+    return TRUE;
+  }
+
+  /**
+   * @todo
+   */
+  public function dispatchEvent(Event $event, ?string $eventName = NULL): Event {
+    return $event;
+  }
+
+  /**
+   * Determine the last non-database method that called the database API.
+   *
+   * Traversing the call stack from the very first call made during the
+   * request, we define "the routine that called this query" as the last entry
+   * in the call stack that is not any method called from the namespace of the
+   * database driver, is not inside the Drupal\Core\Database namespace and does
+   * have a file (which excludes call_user_func_array(), anonymous functions
+   * and similar). That makes the climbing logic very simple, and handles the
+   * variable stack depth caused by the query builders.
+   *
+   * See the @link http://php.net/debug_backtrace debug_backtrace() @endlink
+   * function.
+   *
+   * @return array
+   *   This method returns a stack trace entry similar to that generated by
+   *   debug_backtrace(). However, it flattens the trace entry and the trace
+   *   entry before it so that we get the function and args of the function that
+   *   called into the database system, not the function and args of the
+   *   database call itself.
+   */
+  public function findCaller(): array {
+    $stack = $this->removeDatabaseEntries($this->getDebugBacktrace());
+
+    // Return the first function call whose stack entry has a 'file' key, that
+    // is, it is not a callback or a closure.
+    for ($i = 0; $i < count($stack); $i++) {
+      if (!empty($stack[$i]['file'])) {
+        return [
+          'file' => $stack[$i]['file'],
+          'line' => $stack[$i]['line'],
+          'function' => $stack[$i + 1]['function'],
+          'class' => $stack[$i + 1]['class'] ?? NULL,
+          'type' => $stack[$i + 1]['type'] ?? NULL,
+          'args' => $stack[$i + 1]['args'] ?? [],
+        ];
+      }
+    }
+
+    return [];
+  }
+
+  /**
+   * Removes database related calls from a backtrace array.
+   *
+   * @param array $backtrace
+   *   A standard PHP backtrace. Passed by reference.
+   *
+   * @return array
+   *   The cleaned backtrace array.
+   */
+  protected function removeDatabaseEntries(array $backtrace): array {
+    // Starting from the very first entry processed during the request, find
+    // the first function call that can be identified as a call to a
+    // method/function in the database layer.
+    for ($n = count($backtrace) - 1; $n >= 0; $n--) {
+      // If the call was made from a function, 'class' will be empty. We give
+      // it a default empty string value in that case.
+      $class = $backtrace[$n]['class'] ?? '';
+      if (strpos($class, __NAMESPACE__, 0) === 0 || strpos($class, $this->getConnectionOptions()['namespace'], 0) === 0) {
+        break;
+      }
+    }
+
+    return array_values(array_slice($backtrace, $n));
+  }
+
+  /**
+   * Gets the debug backtrace.
+   *
+   * Wraps the debug_backtrace function to allow mocking results in PHPUnit
+   * tests.
+   *
+   * @return array[]
+   *   The debug backtrace.
+   */
+  protected function getDebugBacktrace(): array {
+    return debug_backtrace();
+  }
+
 }
diff --git a/core/lib/Drupal/Core/Database/DatabaseEvents.php b/core/lib/Drupal/Core/Database/DatabaseEvents.php
new file mode 100644
index 0000000000..95fdf6893f
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/DatabaseEvents.php
@@ -0,0 +1,28 @@
+<?php
+
+namespace Drupal\Core\Database;
+
+/**
+ * Defines events for the database system.
+ */
+final class DatabaseEvents {
+
+  /**
+   * Name of the event fired when starting a statement execution.
+   *
+   * @Event
+   *
+   * @var string
+   */
+  const STATEMENT_EXECUTION_START = 'database.statement.execution.start';
+
+  /**
+   * Name of the event fired when a statement execution is finished.
+   *
+   * @Event
+   *
+   * @var string
+   */
+  const STATEMENT_EXECUTION_END = 'database.statement.execution.end';
+
+}
diff --git a/core/lib/Drupal/Core/Database/Event/StatementExecutionEvent.php b/core/lib/Drupal/Core/Database/Event/StatementExecutionEvent.php
new file mode 100644
index 0000000000..33175df3ee
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/Event/StatementExecutionEvent.php
@@ -0,0 +1,36 @@
+<?php
+
+namespace Drupal\Core\Database\Event;
+
+use Drupal\Component\EventDispatcher\Event;
+use Drupal\Core\Database\StatementInterface;
+
+/**
+ * Represents a statement execution as an event.
+ */
+class StatementExecutionEvent extends Event {
+
+  /**
+   * Constructs a StatementExecutionEvent object.
+   */
+  public function __construct(
+    public readonly StatementInterface $statement,
+    public readonly array $args,
+    public readonly array $caller,
+  ) {}
+
+  /**
+   * Sets the query start time.
+   */
+  public function setStartTime(float $time): void {
+    $this->startTime = $time;
+  }
+
+  /**
+   * Sets the query end time.
+   */
+  public function setEndTime(float $time): void {
+    $this->endTime = $time;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Database/StatementPrefetch.php b/core/lib/Drupal/Core/Database/StatementPrefetch.php
index 0702bd1de4..41dee2e713 100644
--- a/core/lib/Drupal/Core/Database/StatementPrefetch.php
+++ b/core/lib/Drupal/Core/Database/StatementPrefetch.php
@@ -2,6 +2,8 @@
 
 namespace Drupal\Core\Database;
 
+use Drupal\Core\Database\Event\StatementExecutionEvent;
+
 /**
  * An implementation of StatementInterface that prefetches all data.
  *
@@ -172,9 +174,10 @@ public function execute($args = [], $options = []) {
       }
     }
 
-    $logger = $this->connection->getLogger();
-    if (!empty($logger)) {
-      $query_start = microtime(TRUE);
+    if ($this->connection->areStatementEventsEnabled()) {
+      $event = new StatementExecutionEvent($this, $args ?? [], $this->connection->findCaller());
+      $event->setStartTime(microtime(TRUE));
+      $this->connection->dispatchEvent($event, DatabaseEvents::STATEMENT_EXECUTION_START);
     }
 
     // Prepare the query.
@@ -207,9 +210,9 @@ public function execute($args = [], $options = []) {
       $this->columnNames = [];
     }
 
-    if (!empty($logger)) {
-      $query_end = microtime(TRUE);
-      $logger->log($this, $args, $query_end - $query_start, $query_start);
+    if (isset($event)) {
+      $event->setEndTime(microtime(TRUE));
+      $this->connection->dispatchEvent($event, DatabaseEvents::STATEMENT_EXECUTION_END);
     }
 
     // Initialize the first row in $this->currentRow.
diff --git a/core/lib/Drupal/Core/Database/StatementWrapper.php b/core/lib/Drupal/Core/Database/StatementWrapper.php
index 8a3bc208c5..5ecdd7990f 100644
--- a/core/lib/Drupal/Core/Database/StatementWrapper.php
+++ b/core/lib/Drupal/Core/Database/StatementWrapper.php
@@ -2,6 +2,8 @@
 
 namespace Drupal\Core\Database;
 
+use Drupal\Core\Database\Event\StatementExecutionEvent;
+
 // cSpell:ignore maxlen driverdata INOUT
 
 /**
@@ -87,16 +89,17 @@ public function execute($args = [], $options = []) {
       }
     }
 
-    $logger = $this->connection->getLogger();
-    if (!empty($logger)) {
-      $query_start = microtime(TRUE);
+    if ($this->connection->areStatementEventsEnabled()) {
+      $event = new StatementExecutionEvent($this, $args ?? [], $this->connection->findCaller());
+      $event->setStartTime(microtime(TRUE));
+      $this->connection->dispatchEvent($event, DatabaseEvents::STATEMENT_EXECUTION_START);
     }
 
     $return = $this->clientStatement->execute($args);
 
-    if (!empty($logger)) {
-      $query_end = microtime(TRUE);
-      $logger->log($this, $args, $query_end - $query_start, $query_start);
+    if (isset($event)) {
+      $event->setEndTime(microtime(TRUE));
+      $this->connection->dispatchEvent($event, DatabaseEvents::STATEMENT_EXECUTION_END);
     }
 
     return $return;
