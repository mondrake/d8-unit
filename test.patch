diff --git a/core/lib/Drupal/Core/Database/Connection.php b/core/lib/Drupal/Core/Database/Connection.php
index 7a9de46a7d4..12dad114a13 100644
--- a/core/lib/Drupal/Core/Database/Connection.php
+++ b/core/lib/Drupal/Core/Database/Connection.php
@@ -664,6 +664,31 @@ public function query($query, array $args = [], $options = []) {
     return $result ? $statement : NULL;
   }
 
+  /**
+   * Executes a data definition language (DDL) statement.
+   *
+   * This method allows to void an active transaction when the driver does
+   * not support transactional DDL.
+   *
+   * @param string $sql
+   *   The DDL statement to execute. This is a SQL string that may contain
+   *   placeholders.
+   * @param array $arguments
+   *   (Optional) The associative array of arguments for the prepared
+   *   statement.
+   * @param array $options
+   *   (Optional) An associative array of options to control how the query is
+   *   run. The given options will be merged with self::defaultOptions().
+   */
+  public function executeDdlStatement(string $sql, array $arguments = [], array $options = []): void {
+    $this->query($sql, $arguments, $options);
+    // DDL statements when in a transaction force a commit in some databases.
+    // Void the transaction in that case.
+    if (!$this->transactionalDDLSupport && $this->transactionManager()->inTransaction()) {
+      $this->transactionManager()->voidClientTransaction();
+    }
+  }
+
   /**
    * Expands out shorthand placeholders.
    *
diff --git a/core/lib/Drupal/Core/Database/Query/Truncate.php b/core/lib/Drupal/Core/Database/Query/Truncate.php
index 45f1c8447ac..607839664d1 100644
--- a/core/lib/Drupal/Core/Database/Query/Truncate.php
+++ b/core/lib/Drupal/Core/Database/Query/Truncate.php
@@ -34,6 +34,12 @@ public function __construct(Connection $connection, $table, array $options = [])
   /**
    * Executes the TRUNCATE query.
    *
+   * In most cases, TRUNCATE is not a transaction safe statement as it is a DDL
+   * statement which results in an implicit COMMIT. When we are in a
+   * transaction, fallback to the slower, but transactional, DELETE.
+   * PostgreSQL also locks the entire table for a TRUNCATE strongly reducing
+   * the concurrency with other transactions.
+   *
    * @return int|null
    *   Return value is dependent on whether the executed SQL statement is a
    *   TRUNCATE or a DELETE. TRUNCATE is DDL and no information on affected
@@ -44,13 +50,18 @@ public function __construct(Connection $connection, $table, array $options = [])
    * @see https://learnsql.com/blog/difference-between-truncate-delete-and-drop-table-in-sql
    */
   public function execute() {
-    $stmt = $this->connection->prepareStatement((string) $this, $this->queryOptions, TRUE);
-    try {
-      $stmt->execute([], $this->queryOptions);
-      return $stmt->rowCount();
+    if ($this->connection->inTransaction()) {
+      $stmt = $this->connection->prepareStatement((string) $this, $this->queryOptions, TRUE);
+      try {
+        $stmt->execute([], $this->queryOptions);
+        return $stmt->rowCount();
+      }
+      catch (\Exception $e) {
+        $this->connection->exceptionHandler()->handleExecutionException($e, $stmt, [], $this->queryOptions);
+      }
     }
-    catch (\Exception $e) {
-      $this->connection->exceptionHandler()->handleExecutionException($e, $stmt, [], $this->queryOptions);
+    else {
+      $this->connection->executeDdlStatement((string) $this, [], $this->queryOptions);
     }
 
     return NULL;
@@ -66,11 +77,8 @@ public function __toString() {
     // Create a sanitized comment string to prepend to the query.
     $comments = $this->connection->makeComment($this->comments);
 
-    // In most cases, TRUNCATE is not a transaction safe statement as it is a
-    // DDL statement which results in an implicit COMMIT. When we are in a
-    // transaction, fallback to the slower, but transactional, DELETE.
-    // PostgreSQL also locks the entire table for a TRUNCATE strongly reducing
-    // the concurrency with other transactions.
+    // The statement actually built depends on whether a transaction is active.
+    // @see ::execute()
     if ($this->connection->inTransaction()) {
       return $comments . 'DELETE FROM {' . $this->connection->escapeTable($this->table) . '}';
     }
diff --git a/core/lib/Drupal/Core/Database/Schema.php b/core/lib/Drupal/Core/Database/Schema.php
index ee8d1469eba..6037e1a5632 100644
--- a/core/lib/Drupal/Core/Database/Schema.php
+++ b/core/lib/Drupal/Core/Database/Schema.php
@@ -616,7 +616,7 @@ public function createTable($name, $table) {
     }
     $statements = $this->createTableSql($name, $table);
     foreach ($statements as $statement) {
-      $this->connection->query($statement);
+      $this->connection->executeDdlStatement($statement);
     }
   }
 
diff --git a/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php b/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php
index 4e1fc8352fa..e3ca10e76cc 100644
--- a/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php
+++ b/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php
@@ -333,6 +333,7 @@ public function unpile(string $name, string $id): void {
       }
       else {
         // The stack got corrupted.
+        $this->postTransactionCallbacks = [];
         throw new TransactionOutOfOrderException("Transaction {$id}/{$name} is out of order. Active stack: " . $this->dumpStackItemsAsString());
       }
 
@@ -342,6 +343,7 @@ public function unpile(string $name, string $id): void {
     }
 
     // The stack got corrupted.
+    $this->postTransactionCallbacks = [];
     throw new TransactionOutOfOrderException("Transaction {$id}/{$name} is out of order. Active stack: " . $this->dumpStackItemsAsString());
   }
 
@@ -349,8 +351,19 @@ public function unpile(string $name, string $id): void {
    * {@inheritdoc}
    */
   public function rollback(string $name, string $id): void {
+    // If the transaction was voided, we cannot rollback. Fail silently in
+    // Drupal 11.
+    // @todo In drupal:12.0.0, throw a TransactionOutOfOrderException, just
+    //   removing this check.
+    if ($this->getConnectionTransactionState() === ClientConnectionTransactionState::Voided) {
+      @trigger_error('Calling Transaction::rollBack() after a DDL statement is deprecated in drupal:11.1.0 and will throw a TransactionOutOfOrderException in drupal:12.0.0. See https://www.drupal.org/node/3402926', E_USER_DEPRECATED);
+      $this->postTransactionCallbacks = [];
+      return;
+    }
+
     // Rolled back item should match the last one in stack.
     if ($id != array_key_last($this->stack()) || $name !== $this->stack()[$id]->name) {
+      $this->postTransactionCallbacks = [];
       throw new TransactionOutOfOrderException("Error attempting rollback of {$id}\\{$name}. Active stack: " . $this->dumpStackItemsAsString());
     }
 
@@ -377,12 +390,14 @@ public function rollback(string $name, string $id): void {
       }
       else {
         // The stack got corrupted.
+        $this->postTransactionCallbacks = [];
         throw new TransactionOutOfOrderException("Error attempting rollback of {$id}\\{$name}. Active stack: " . $this->dumpStackItemsAsString());
       }
       return;
     }
 
     // The stack got corrupted.
+    $this->postTransactionCallbacks = [];
     throw new TransactionOutOfOrderException("Error attempting rollback of {$id}\\{$name}. Active stack: " . $this->dumpStackItemsAsString());
   }
 
diff --git a/core/modules/mysql/src/Driver/Database/mysql/Schema.php b/core/modules/mysql/src/Driver/Database/mysql/Schema.php
index 6fdcad7047b..8f9b3980bf6 100644
--- a/core/modules/mysql/src/Driver/Database/mysql/Schema.php
+++ b/core/modules/mysql/src/Driver/Database/mysql/Schema.php
@@ -380,7 +380,7 @@ public function renameTable($table, $new_name) {
     }
 
     $info = $this->getPrefixInfo($new_name);
-    $this->connection->query('ALTER TABLE {' . $table . '} RENAME TO [' . $info['table'] . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} RENAME TO [' . $info['table'] . ']');
   }
 
   /**
@@ -391,7 +391,7 @@ public function dropTable($table) {
       return FALSE;
     }
 
-    $this->connection->query('DROP TABLE {' . $table . '}');
+    $this->connection->executeDdlStatement('DROP TABLE {' . $table . '}');
     return TRUE;
   }
 
@@ -430,14 +430,14 @@ public function addField($table, $field, $spec, $keys_new = []) {
       $query .= ', ADD ' . implode(', ADD ', $keys_sql);
     }
     try {
-      $this->connection->query($query);
+      $this->connection->executeDdlStatement($query);
     }
     catch (DatabaseExceptionWrapper $e) {
       // MySQL error number 4111 (ER_DROP_PK_COLUMN_TO_DROP_GIPK) indicates that
       // when dropping and adding a primary key, the generated invisible primary
       // key (GIPK) column must also be dropped.
       if (isset($e->getPrevious()->errorInfo[1]) && $e->getPrevious()->errorInfo[1] === 4111 && isset($keys_new['primary key']) && $this->indexExists($table, 'PRIMARY') && $this->findPrimaryKeyColumns($table) === ['my_row_id']) {
-        $this->connection->query($query . ', DROP COLUMN [my_row_id]');
+        $this->connection->executeDdlStatement($query . ', DROP COLUMN [my_row_id]');
       }
       else {
         throw $e;
@@ -488,7 +488,7 @@ public function dropField($table, $field) {
       $this->dropPrimaryKey($table);
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP [' . $field . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP [' . $field . ']');
     return TRUE;
   }
 
@@ -513,7 +513,7 @@ public function addPrimaryKey($table, $fields) {
       throw new SchemaObjectExistsException("Cannot add primary key to table '$table': primary key already exists.");
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD PRIMARY KEY (' . $this->createKeySql($fields) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD PRIMARY KEY (' . $this->createKeySql($fields) . ')');
   }
 
   /**
@@ -524,7 +524,7 @@ public function dropPrimaryKey($table) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP PRIMARY KEY');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP PRIMARY KEY');
     return TRUE;
   }
 
@@ -550,7 +550,7 @@ public function addUniqueKey($table, $name, $fields) {
       throw new SchemaObjectExistsException("Cannot add unique key '$name' to table '$table': unique key already exists.");
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD UNIQUE KEY [' . $name . '] (' . $this->createKeySql($fields) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD UNIQUE KEY [' . $name . '] (' . $this->createKeySql($fields) . ')');
   }
 
   /**
@@ -561,7 +561,7 @@ public function dropUniqueKey($table, $name) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP KEY [' . $name . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP KEY [' . $name . ']');
     return TRUE;
   }
 
@@ -579,7 +579,7 @@ public function addIndex($table, $name, $fields, array $spec) {
     $spec['indexes'][$name] = $fields;
     $indexes = $this->getNormalizedIndexes($spec);
 
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD INDEX [' . $name . '] (' . $this->createKeySql($indexes[$name]) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD INDEX [' . $name . '] (' . $this->createKeySql($indexes[$name]) . ')');
   }
 
   /**
@@ -590,7 +590,7 @@ public function dropIndex($table, $name) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP INDEX [' . $name . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP INDEX [' . $name . ']');
     return TRUE;
   }
 
@@ -642,11 +642,11 @@ public function changeField($table, $field, $field_new, $spec, $keys_new = []) {
     if ($keys_sql = $this->createKeysSql($keys_new)) {
       $sql .= ', ADD ' . implode(', ADD ', $keys_sql);
     }
-    $this->connection->query($sql);
+    $this->connection->executeDdlStatement($sql);
 
     if ($spec['type'] === 'serial') {
       $max = $this->connection->query('SELECT MAX(`' . $field_new . '`) FROM {' . $table . '}')->fetchField();
-      $this->connection->query("ALTER TABLE {" . $table . "} AUTO_INCREMENT = " . ($max + 1));
+      $this->connection->executeDdlStatement("ALTER TABLE {" . $table . "} AUTO_INCREMENT = " . ($max + 1));
     }
   }
 
diff --git a/core/modules/pgsql/src/Driver/Database/pgsql/Schema.php b/core/modules/pgsql/src/Driver/Database/pgsql/Schema.php
index 32a12b44ec1..7433caa23b0 100644
--- a/core/modules/pgsql/src/Driver/Database/pgsql/Schema.php
+++ b/core/modules/pgsql/src/Driver/Database/pgsql/Schema.php
@@ -590,7 +590,7 @@ public function renameTable($table, $new_name) {
       // The renaming of an index will fail when the there exists an table with
       // the same name as the renamed index.
       if (!$this->tableExists($this->ensureIdentifiersLength($new_name, $index_name, $index_type), FALSE)) {
-        $this->connection->query('ALTER INDEX "' . $this->defaultSchema . '"."' . $index->indexname . '" RENAME TO ' . $this->ensureIdentifiersLength($new_name, $index_name, $index_type));
+        $this->connection->executeDdlStatement('ALTER INDEX "' . $this->defaultSchema . '"."' . $index->indexname . '" RENAME TO ' . $this->ensureIdentifiersLength($new_name, $index_name, $index_type));
       }
     }
 
@@ -613,11 +613,11 @@ public function renameTable($table, $new_name) {
         // subsequent table renames.
         $new_sequence = $this->ensureIdentifiersLength($new_name, $field, 'seq', '_');
 
-        $this->connection->query('ALTER SEQUENCE ' . $old_sequence . ' RENAME TO ' . $new_sequence);
+        $this->connection->executeDdlStatement('ALTER SEQUENCE ' . $old_sequence . ' RENAME TO ' . $new_sequence);
       }
     }
     // Now rename the table.
-    $this->connection->query('ALTER TABLE {' . $table . '} RENAME TO ' . $prefixInfo['table']);
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} RENAME TO ' . $prefixInfo['table']);
     $this->resetTableInformation($table);
   }
 
@@ -629,7 +629,7 @@ public function dropTable($table) {
       return FALSE;
     }
 
-    $this->connection->query('DROP TABLE {' . $table . '}');
+    $this->connection->executeDdlStatement('DROP TABLE {' . $table . '}');
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -658,7 +658,7 @@ public function addField($table, $field, $spec, $new_keys = []) {
     }
     $query = 'ALTER TABLE {' . $table . '} ADD COLUMN ';
     $query .= $this->createFieldSql($field, $this->processField($spec));
-    $this->connection->query($query);
+    $this->connection->executeDdlStatement($query);
     if (isset($spec['initial_from_field'])) {
       if (isset($spec['initial'])) {
         $expression = 'COALESCE(' . $spec['initial_from_field'] . ', :default_initial_value)';
@@ -678,7 +678,7 @@ public function addField($table, $field, $spec, $new_keys = []) {
         ->execute();
     }
     if ($fix_null) {
-      $this->connection->query("ALTER TABLE {" . $table . "} ALTER $field SET NOT NULL");
+      $this->connection->executeDdlStatement("ALTER TABLE {" . $table . "} ALTER $field SET NOT NULL");
     }
     if (isset($new_keys)) {
       // Make sure to drop the existing primary key before adding a new one.
@@ -691,7 +691,7 @@ public function addField($table, $field, $spec, $new_keys = []) {
     }
     // Add column comment.
     if (!empty($spec['description'])) {
-      $this->connection->query('COMMENT ON COLUMN {' . $table . '}.' . $field . ' IS ' . $this->prepareComment($spec['description']));
+      $this->connection->executeDdlStatement('COMMENT ON COLUMN {' . $table . '}.' . $field . ' IS ' . $this->prepareComment($spec['description']));
     }
     $this->resetTableInformation($table);
   }
@@ -704,7 +704,7 @@ public function dropField($table, $field) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP COLUMN "' . $field . '"');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP COLUMN "' . $field . '"');
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -778,7 +778,7 @@ public function addPrimaryKey($table, $fields) {
       throw new SchemaObjectExistsException("Cannot add primary key to table '$table': primary key already exists.");
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD CONSTRAINT ' . $this->ensureIdentifiersLength($table, '', 'pkey') . ' PRIMARY KEY (' . $this->createPrimaryKeySql($fields) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD CONSTRAINT ' . $this->ensureIdentifiersLength($table, '', 'pkey') . ' PRIMARY KEY (' . $this->createPrimaryKeySql($fields) . ')');
     $this->resetTableInformation($table);
   }
 
@@ -790,7 +790,7 @@ public function dropPrimaryKey($table) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP CONSTRAINT ' . $this->ensureIdentifiersLength($table, '', 'pkey'));
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP CONSTRAINT ' . $this->ensureIdentifiersLength($table, '', 'pkey'));
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -819,7 +819,7 @@ public function addUniqueKey($table, $name, $fields) {
     // Use the createPrimaryKeySql(), which already discards any prefix lengths
     // passed as part of the key column specifiers. (Postgres doesn't support
     // setting a prefix length for PRIMARY or UNIQUE indices.)
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD CONSTRAINT ' . $this->ensureIdentifiersLength($table, $name, 'key') . ' UNIQUE (' . $this->createPrimaryKeySql($fields) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD CONSTRAINT ' . $this->ensureIdentifiersLength($table, $name, 'key') . ' UNIQUE (' . $this->createPrimaryKeySql($fields) . ')');
     $this->resetTableInformation($table);
   }
 
@@ -831,7 +831,7 @@ public function dropUniqueKey($table, $name) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP CONSTRAINT ' . $this->ensureIdentifiersLength($table, $name, 'key'));
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP CONSTRAINT ' . $this->ensureIdentifiersLength($table, $name, 'key'));
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -847,7 +847,7 @@ public function addIndex($table, $name, $fields, array $spec) {
       throw new SchemaObjectExistsException("Cannot add index '$name' to table '$table': index already exists.");
     }
 
-    $this->connection->query($this->_createIndexSql($table, $name, $fields));
+    $this->connection->executeDdlStatement($this->_createIndexSql($table, $name, $fields));
     $this->resetTableInformation($table);
   }
 
@@ -859,7 +859,7 @@ public function dropIndex($table, $name) {
       return FALSE;
     }
 
-    $this->connection->query('DROP INDEX ' . $this->defaultSchema . '.' . $this->ensureIdentifiersLength($table, $name, 'idx'));
+    $this->connection->executeDdlStatement('DROP INDEX ' . $this->defaultSchema . '.' . $this->ensureIdentifiersLength($table, $name, 'idx'));
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -938,15 +938,15 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
     if (!empty($seq_name)) {
       // We need to add CASCADE otherwise we cannot alter the sequence because
       // the table depends on it.
-      $this->connection->query('DROP SEQUENCE IF EXISTS ' . $seq_name . ' CASCADE');
+      $this->connection->executeDdlStatement('DROP SEQUENCE IF EXISTS ' . $seq_name . ' CASCADE');
     }
 
     foreach ($field_info as $check) {
-      $this->connection->query('ALTER TABLE {' . $table . '} DROP CONSTRAINT [' . $check . ']');
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP CONSTRAINT [' . $check . ']');
     }
 
     // Remove old default.
-    $this->connection->query('ALTER TABLE {' . $table . '} ALTER COLUMN [' . $field . '] DROP DEFAULT');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER COLUMN [' . $field . '] DROP DEFAULT');
 
     // Convert field type.
     // Usually, we do this via a simple typecast 'USING fieldname::type'. But
@@ -956,10 +956,10 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
     $is_bytea = !empty($table_information->blob_fields[$field]);
     if ($spec['pgsql_type'] != 'bytea') {
       if ($is_bytea) {
-        $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING convert_from([' . $field . ']' . ", 'UTF8')");
+        $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING convert_from([' . $field . ']' . ", 'UTF8')");
       }
       else {
-        $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING [' . $field . ']::' . $field_def);
+        $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING [' . $field . ']::' . $field_def);
       }
     }
     else {
@@ -968,7 +968,7 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
         // Convert to a bytea type by using the SQL replace() function to
         // convert any single backslashes in the field content to double
         // backslashes ('\' to '\\').
-        $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING decode(replace("' . $field . '"' . ", E'\\\\', E'\\\\\\\\'), 'escape');");
+        $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING decode(replace("' . $field . '"' . ", E'\\\\', E'\\\\\\\\'), 'escape');");
       }
     }
 
@@ -979,7 +979,7 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
       else {
         $null_action = 'DROP NOT NULL';
       }
-      $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] ' . $null_action);
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] ' . $null_action);
     }
 
     if (in_array($spec['pgsql_type'], ['serial', 'bigserial'])) {
@@ -987,31 +987,31 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
       // not when altering. Because of that, the sequence needs to be created
       // and initialized by hand.
       $seq = $this->connection->makeSequenceName($table, $field_new);
-      $this->connection->query("CREATE SEQUENCE " . $seq . " OWNED BY {" . $table . "}.[" . $field_new . ']');
+      $this->connection->executeDdlStatement("CREATE SEQUENCE " . $seq . " OWNED BY {" . $table . "}.[" . $field_new . ']');
       // Set sequence to maximal field value to not conflict with existing
       // entries.
       $this->connection->query("SELECT setval('" . $seq . "', MAX([" . $field . "])) FROM {" . $table . "}");
-      $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] SET DEFAULT nextval(' . $this->connection->quote($seq) . ')');
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] SET DEFAULT nextval(' . $this->connection->quote($seq) . ')');
     }
 
     // Rename the column if necessary.
     if ($field != $field_new) {
-      $this->connection->query('ALTER TABLE {' . $table . '} RENAME [' . $field . '] TO [' . $field_new . ']');
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} RENAME [' . $field . '] TO [' . $field_new . ']');
     }
 
     // Add unsigned check if necessary.
     if (!empty($spec['unsigned'])) {
-      $this->connection->query('ALTER TABLE {' . $table . '} ADD CHECK ([' . $field_new . '] >= 0)');
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD CHECK ([' . $field_new . '] >= 0)');
     }
 
     // Add default if necessary.
     if (isset($spec['default'])) {
-      $this->connection->query('ALTER TABLE {' . $table . '} ALTER COLUMN [' . $field_new . '] SET DEFAULT ' . $this->escapeDefaultValue($spec['default']));
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER COLUMN [' . $field_new . '] SET DEFAULT ' . $this->escapeDefaultValue($spec['default']));
     }
 
     // Change description if necessary.
     if (!empty($spec['description'])) {
-      $this->connection->query('COMMENT ON COLUMN {' . $table . '}.[' . $field_new . '] IS ' . $this->prepareComment($spec['description']));
+      $this->connection->executeDdlStatement('COMMENT ON COLUMN {' . $table . '}.[' . $field_new . '] IS ' . $this->prepareComment($spec['description']));
     }
 
     if (isset($new_keys)) {
diff --git a/core/modules/sqlite/src/Driver/Database/sqlite/Schema.php b/core/modules/sqlite/src/Driver/Database/sqlite/Schema.php
index 64bdffa8c80..4531e34cc73 100644
--- a/core/modules/sqlite/src/Driver/Database/sqlite/Schema.php
+++ b/core/modules/sqlite/src/Driver/Database/sqlite/Schema.php
@@ -272,7 +272,7 @@ public function renameTable($table, $new_name) {
     // the table with curly braces in case the db_prefix contains a reference
     // to a database outside of our existing database.
     $info = $this->getPrefixInfo($new_name);
-    $this->connection->query('ALTER TABLE {' . $table . '} RENAME TO [' . $info['table'] . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} RENAME TO [' . $info['table'] . ']');
 
     // Drop the indexes, there is no RENAME INDEX command in SQLite.
     if (!empty($schema['unique keys'])) {
@@ -289,7 +289,7 @@ public function renameTable($table, $new_name) {
     // Recreate the indexes.
     $statements = $this->createIndexSql($new_name, $schema);
     foreach ($statements as $statement) {
-      $this->connection->query($statement);
+      $this->connection->executeDdlStatement($statement);
     }
   }
 
@@ -301,7 +301,7 @@ public function dropTable($table) {
       return FALSE;
     }
     $this->connection->tableDropped = TRUE;
-    $this->connection->query('DROP TABLE {' . $table . '}');
+    $this->connection->executeDdlStatement('DROP TABLE {' . $table . '}');
     return TRUE;
   }
 
@@ -326,7 +326,7 @@ public function addField($table, $field, $specification, $keys_new = []) {
       // When we don't have to create new keys and we are not creating a
       // NOT NULL column without a default value, we can use the quicker version.
       $query = 'ALTER TABLE {' . $table . '} ADD ' . $this->createFieldSql($field, $this->processField($specification));
-      $this->connection->query($query);
+      $this->connection->executeDdlStatement($query);
 
       // Apply the initial value if set.
       if (isset($specification['initial_from_field'])) {
@@ -683,7 +683,7 @@ public function addIndex($table, $name, $fields, array $spec) {
     $schema['indexes'][$name] = $fields;
     $statements = $this->createIndexSql($table, $schema);
     foreach ($statements as $statement) {
-      $this->connection->query($statement);
+      $this->connection->executeDdlStatement($statement);
     }
   }
 
@@ -706,7 +706,7 @@ public function dropIndex($table, $name) {
 
     $info = $this->getPrefixInfo($table);
 
-    $this->connection->query('DROP INDEX [' . $info['schema'] . '].[' . $info['table'] . '_' . $name . ']');
+    $this->connection->executeDdlStatement('DROP INDEX [' . $info['schema'] . '].[' . $info['table'] . '_' . $name . ']');
     return TRUE;
   }
 
@@ -724,7 +724,7 @@ public function addUniqueKey($table, $name, $fields) {
     $schema['unique keys'][$name] = $fields;
     $statements = $this->createIndexSql($table, $schema);
     foreach ($statements as $statement) {
-      $this->connection->query($statement);
+      $this->connection->executeDdlStatement($statement);
     }
   }
 
@@ -738,7 +738,7 @@ public function dropUniqueKey($table, $name) {
 
     $info = $this->getPrefixInfo($table);
 
-    $this->connection->query('DROP INDEX [' . $info['schema'] . '].[' . $info['table'] . '_' . $name . ']');
+    $this->connection->executeDdlStatement('DROP INDEX [' . $info['schema'] . '].[' . $info['table'] . '_' . $name . ']');
     return TRUE;
   }
 
diff --git a/core/tests/Drupal/KernelTests/Core/Cache/EndOfTransactionQueriesTest.php b/core/tests/Drupal/KernelTests/Core/Cache/EndOfTransactionQueriesTest.php
index 0414b6e6fd1..b564fa58725 100644
--- a/core/tests/Drupal/KernelTests/Core/Cache/EndOfTransactionQueriesTest.php
+++ b/core/tests/Drupal/KernelTests/Core/Cache/EndOfTransactionQueriesTest.php
@@ -75,6 +75,13 @@ public function testEntitySave(): void {
     Database::startLog('testEntitySave');
     $entity->save();
 
+    // Entity save should have deferred cache invalidation to after transaction
+    // completion for the "entity_test_list", "entity_test_list:entity_test"
+    // and "4xx-response" tags. Since cache invalidation is a MERGE database
+    // operation, and in core drivers each MERGE is split in two SELECT and
+    // INSERT|UPDATE operations, we expect the last 6 logged database queries
+    // to be related to the {cachetags} table.
+    $expected_tail_length = 6;
     $executed_statements = [];
     foreach (Database::getLog('testEntitySave') as $log) {
       // Exclude transaction related statements from the log.
@@ -87,9 +94,10 @@ public function testEntitySave(): void {
       }
       $executed_statements[] = $log['query'];
     }
-    $last_statement_index = max(array_keys($executed_statements));
-    $cachetag_statements = array_keys($this->getStatementsForTable($executed_statements, 'cachetags'));
-    $this->assertSame($last_statement_index - count($cachetag_statements) + 1, min($cachetag_statements), 'All of the last queries in the transaction are for the "cachetags" table.');
+    $expected_post_transaction_statements = array_keys(array_fill(array_key_last($executed_statements) - $expected_tail_length + 1, $expected_tail_length, TRUE));
+    $cachetag_statements = $this->getStatementsForTable($executed_statements, 'cachetags');
+    $tail_cachetag_statements = array_keys(array_slice($cachetag_statements, count($cachetag_statements) - $expected_tail_length, $expected_tail_length, TRUE));
+    $this->assertSame($expected_post_transaction_statements, $tail_cachetag_statements);
 
     // Verify that a nested entity save occurred.
     $this->assertSame('john doe', User::load(1)->getAccountName());
diff --git a/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php b/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
index 3911419ca77..c260fb9fa00 100644
--- a/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
+++ b/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
@@ -12,6 +12,7 @@
 use Drupal\Core\Database\Transaction\TransactionManagerBase;
 use Drupal\Core\Database\TransactionNameNonUniqueException;
 use Drupal\Core\Database\TransactionOutOfOrderException;
+use PHPUnit\Framework\Attributes\IgnoreDeprecations;
 
 /**
  * Tests the transaction abstraction system.
@@ -424,24 +425,40 @@ public function testTransactionWithDdlStatement(): void {
       unset($transaction);
       $this->assertRowAbsent('row');
     }
-    else {
-      // For database servers that do not support transactional DDL,
-      // the DDL statement should commit the transaction stack.
-      $this->cleanUp();
-      $transaction = $this->createRootTransaction('', FALSE);
-      $this->insertRow('row');
-      $this->executeDDLStatement();
-
-      // Try to rollback the outer transaction. It should fail and void
-      // the transaction stack.
-      $transaction->rollBack();
-      $manager = $this->connection->transactionManager();
-      $reflectedTransactionState = new \ReflectionMethod($manager, 'getConnectionTransactionState');
-      $this->assertSame(ClientConnectionTransactionState::Voided, $reflectedTransactionState->invoke($manager));
+  }
 
-      unset($transaction);
-      $this->assertRowPresent('row');
+  /**
+   * Tests rollback after a DDL statement when no transactional DDL supported.
+   *
+   * @todo In drupal:12.0.0, rollBack will throw a
+   *   TransactionOutOfOrderException. Adjust the test accordingly.
+   */
+  #[IgnoreDeprecations]
+  public function testRollbackAfterDdlStatementForNonTransactionalDdlDatabase(): void {
+    if ($this->connection->supportsTransactionalDDL()) {
+      $this->markTestSkipped('This test only works for database that do not support transactional DDL.');
     }
+    $this->expectDeprecation('Calling Transaction::rollBack() after a DDL statement is deprecated in drupal:11.1.0 and will throw a TransactionOutOfOrderException in drupal:12.0.0. See https://www.drupal.org/node/3402926');
+
+    // For database servers that do not support transactional DDL,
+    // the DDL statement should commit the transaction stack.
+    $this->cleanUp();
+    $transaction = $this->createRootTransaction('', FALSE);
+    $reflectionMethod = new \ReflectionMethod(get_class($this->connection->transactionManager()), 'getConnectionTransactionState');
+    $this->assertSame(1, $this->connection->transactionManager()->stackDepth());
+    $this->assertEquals(ClientConnectionTransactionState::Active, $reflectionMethod->invoke($this->connection->transactionManager()));
+    $this->insertRow('row');
+    $this->executeDDLStatement();
+
+    // Try to rollback the root transaction. Since the DDL already committed
+    // it, it should fail.
+    $transaction->rollBack();
+    unset($transaction);
+    $manager = $this->connection->transactionManager();
+    $this->assertSame(0, $manager->stackDepth());
+    $reflectedTransactionState = new \ReflectionMethod($manager, 'getConnectionTransactionState');
+    $this->assertSame(ClientConnectionTransactionState::Voided, $reflectedTransactionState->invoke($manager));
+    $this->assertRowPresent('row');
   }
 
   /**
@@ -767,6 +784,7 @@ public function testRootTransactionEndCallbackCalledOnCommit(): void {
     $this->connection->transactionManager()->addPostTransactionCallback([$this, 'rootTransactionCallback']);
     $this->insertRow('row');
     $this->assertNull($this->postTransactionCallbackAction);
+    $this->assertRowAbsent('rtcCommit');
     unset($transaction);
     $this->assertSame('rtcCommit', $this->postTransactionCallbackAction);
     $this->assertRowPresent('row');
@@ -832,6 +850,98 @@ public function testRootTransactionEndCallbackCalledAfterDdlAndDestruction(): vo
     $this->assertRowPresent('row');
   }
 
+  /**
+   * Tests post-transaction rollback executes after a DDL statement.
+   *
+   * For database servers that support transactional DDL, a rollback of a
+   * transaction including DDL statements is possible.
+   */
+  public function testRootTransactionEndCallbackCalledAfterDdlAndRollbackForTransactionalDdlDatabase(): void {
+    if (!$this->connection->supportsTransactionalDDL()) {
+      $this->markTestSkipped('This test only works for database supporting transactional DDL.');
+    }
+
+    $transaction = $this->createRootTransaction('', FALSE);
+    $this->connection->transactionManager()->addPostTransactionCallback([$this, 'rootTransactionCallback']);
+    $this->insertRow('row');
+    $this->assertNull($this->postTransactionCallbackAction);
+
+    // Callbacks are processed only when destructing the transaction.
+    // Executing a DDL statement is not sufficient itself.
+    // We cannot use truncate here, since it has protective code to fall back
+    // to a transactional delete when in transaction. We drop an unrelated
+    // table instead.
+    $this->connection->schema()->dropTable('test_people');
+    $this->assertNull($this->postTransactionCallbackAction);
+    $this->assertRowAbsent('rtcCommit');
+    $this->assertRowAbsent('rtcRollback');
+    $this->assertRowPresent('row');
+
+    // Callbacks are processed only when destructing the transaction.
+    // Executing the rollback is not sufficient by itself.
+    $transaction->rollBack();
+    $this->assertNull($this->postTransactionCallbackAction);
+    $this->assertRowAbsent('rtcCommit');
+    $this->assertRowAbsent('rtcRollback');
+    $this->assertRowAbsent('row');
+
+    // Destruct the transaction.
+    unset($transaction);
+
+    // The post-transaction callback should now have inserted a 'rtcRollback'
+    // row.
+    $this->assertSame('rtcRollback', $this->postTransactionCallbackAction);
+    $this->assertRowAbsent('rtcCommit');
+    $this->assertRowPresent('rtcRollback');
+    $this->assertRowAbsent('row');
+  }
+
+  /**
+   * Tests post-transaction rollback failure after a DDL statement.
+   *
+   * For database servers that support transactional DDL, a rollback of a
+   * transaction including DDL statements is not possible, since a commit
+   * happened already. We cannot decide what should be the status of the
+   * callback, an exception is thrown.
+   *
+   * @todo In drupal:12.0.0, rollBack will throw a
+   *   TransactionOutOfOrderException. Adjust the test accordingly.
+   */
+  #[IgnoreDeprecations]
+  public function testRootTransactionEndCallbackFailureUponDdlAndRollbackForNonTransactionalDdlDatabase(): void {
+    if ($this->connection->supportsTransactionalDDL()) {
+      $this->markTestSkipped('This test only works for database that do not support transactional DDL.');
+    }
+    $this->expectDeprecation('Calling Transaction::rollBack() after a DDL statement is deprecated in drupal:11.1.0 and will throw a TransactionOutOfOrderException in drupal:12.0.0. See https://www.drupal.org/node/3402926');
+
+    $transaction = $this->createRootTransaction('', FALSE);
+    $this->connection->transactionManager()->addPostTransactionCallback([$this, 'rootTransactionCallback']);
+    $this->insertRow('row');
+    $this->assertNull($this->postTransactionCallbackAction);
+
+    // Callbacks are processed only when destructing the transaction.
+    // Executing a DDL statement is not sufficient itself.
+    // We cannot use truncate here, since it has protective code to fall back
+    // to a transactional delete when in transaction. We drop an unrelated
+    // table instead.
+    $this->connection->schema()->dropTable('test_people');
+    $this->assertNull($this->postTransactionCallbackAction);
+    $this->assertRowAbsent('rtcCommit');
+    $this->assertRowAbsent('rtcRollback');
+    $this->assertRowPresent('row');
+
+    $transaction->rollBack();
+    unset($transaction);
+    $this->assertNull($this->postTransactionCallbackAction);
+    $this->assertRowAbsent('rtcCommit');
+    $this->assertRowAbsent('rtcRollback');
+    $manager = $this->connection->transactionManager();
+    $this->assertSame(0, $manager->stackDepth());
+    $reflectedTransactionState = new \ReflectionMethod($manager, 'getConnectionTransactionState');
+    $this->assertSame(ClientConnectionTransactionState::Voided, $reflectedTransactionState->invoke($manager));
+    $this->assertRowPresent('row');
+  }
+
   /**
    * A post-transaction callback for testing purposes.
    */
