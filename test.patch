diff --git a/core/lib/Drupal/Core/Database/Connection.php b/core/lib/Drupal/Core/Database/Connection.php
index c6ce48e5..0acfd2fd 100644
--- a/core/lib/Drupal/Core/Database/Connection.php
+++ b/core/lib/Drupal/Core/Database/Connection.php
@@ -315,6 +315,11 @@ public function destroy() {
    *   database type. In rare cases, such as creating an SQL function, []
    *   characters might be needed and can be allowed by changing this option to
    *   TRUE.
+   * - pdo: By default, queries will execute with the PDO options set on the
+   *   connection. In particular cases, it could be necessary to override the
+   *   PDO driver options on the statement level. In such case, pass the
+   *   required setting as an array here, and they will be passed to the
+   *   prepared statement. See https://www.php.net/manual/en/pdo.prepare.php.
    *
    * @return array
    *   An array of default query options.
@@ -326,6 +331,7 @@ protected function defaultOptions() {
       'throw_exception' => TRUE,
       'allow_delimiter_in_query' => FALSE,
       'allow_square_brackets' => FALSE,
+      'pdo' => [],
     ];
   }
 
@@ -476,6 +482,38 @@ public function getFullQualifiedTableName($table) {
     return $options['database'] . '.' . $prefix . $table;
   }
 
+  /**
+   * Returns a prepared statement given a SQL string.
+   *
+   * This method caches prepared statements, reusing them when possible. It also
+   * prefixes tables names enclosed in curly braces and, optionally, quotes
+   * identifiers enclosed in square brackets.
+   *
+   * @param string $query
+   *   The query string as SQL, with curly braces surrounding the table names.
+   * @param array $args
+   *   The array of arguments for the prepared statement. By default Drupal
+   *   uses named placeholders; drivers may need to pre-process the arguments
+   *   or the placeholders before preparing the statement (for instance, to
+   *   convert the named placeholders to positional placeholders represented
+   *   by ? in the SQL query string if a driver is unable to manage named
+   *   placeholders).
+   * @param array $options
+   *   An associative array of options to control how the query is run. See
+   *   the documentation for self::defaultOptions() for details. The content of
+   *   the 'pdo' key will be passed to the prepared statement.
+   *
+   * @return \Drupal\Core\Database\StatementInterface
+   *   A PDO prepared statement ready for its execute() method.
+   */
+  public function prepareStatement(string $query, array $args, array $options): StatementInterface {
+    $query = $this->prefixTables($query);
+    if (!($options['allow_square_brackets'] ?? FALSE)) {
+      $query = $this->quoteIdentifiers($query);
+    }
+    return $this->connection->prepare($query, $options['pdo'] ?? []);
+  }
+
   /**
    * Prepares a query string and returns the prepared statement.
    *
@@ -494,6 +532,7 @@ public function getFullQualifiedTableName($table) {
    *   A PDO prepared statement ready for its execute() method.
    */
   public function prepareQuery($query, $quote_identifiers = TRUE) {
+    @trigger_error('Connection::prepareQuery() is deprecated in drupal:9.1.0 and is removed in drupal:10.0.0. Use ::prepareStatement() instead. See https://www.drupal.org/node/TODO', E_USER_DEPRECATED);
     $query = $this->prefixTables($query);
     if ($quote_identifiers) {
       $query = $this->quoteIdentifiers($query);
@@ -675,9 +714,7 @@ protected function filterComment($comment = '') {
    *   object to this method. It is used primarily for database drivers for
    *   databases that require special LOB field handling.
    * @param array $args
-   *   An array of arguments for the prepared statement. If the prepared
-   *   statement uses ? placeholders, this array must be an indexed array.
-   *   If it contains named placeholders, it must be an associative array.
+   *   The associative array of arguments for the prepared statement.
    * @param array $options
    *   An associative array of options to control how the query is run. The
    *   given options will be merged with self::defaultOptions(). See the
@@ -730,7 +767,7 @@ public function query($query, array $args = [], $options = []) {
         if (strpos($query, ';') !== FALSE && empty($options['allow_delimiter_in_query'])) {
           throw new \InvalidArgumentException('; is not supported in SQL strings. Use only one statement at a time.');
         }
-        $stmt = $this->prepareQuery($query, !$options['allow_square_brackets']);
+        $stmt = $this->prepareStatement($query, $args, $options);
         $stmt->execute($args, $options);
       }
 
@@ -1652,6 +1689,7 @@ public function commit() {
    * @see \PDO::prepare()
    */
   public function prepare($statement, array $driver_options = []) {
+    @trigger_error('Connection::prepare() is deprecated in drupal:9.1.0 and is removed in drupal:10.0.0. See https://www.drupal.org/node/TODO', E_USER_DEPRECATED);
     return $this->connection->prepare($statement, $driver_options);
   }
 
diff --git a/core/lib/Drupal/Core/Database/Driver/pgsql/Connection.php b/core/lib/Drupal/Core/Database/Driver/pgsql/Connection.php
index c2aef48a..4e19f00e 100644
--- a/core/lib/Drupal/Core/Database/Driver/pgsql/Connection.php
+++ b/core/lib/Drupal/Core/Database/Driver/pgsql/Connection.php
@@ -6,6 +6,7 @@
 use Drupal\Core\Database\Connection as DatabaseConnection;
 use Drupal\Core\Database\DatabaseAccessDeniedException;
 use Drupal\Core\Database\DatabaseNotFoundException;
+use Drupal\Core\Database\StatementInterface;
 
 /**
  * @addtogroup database
@@ -184,7 +185,23 @@ public function query($query, array $args = [], $options = []) {
     return $return;
   }
 
+  /**
+   * {@inheritdoc}
+   */
+  public function prepareStatement(string $query, array $args, array $options): StatementInterface {
+    // mapConditionOperator converts some operations (LIKE, REGEXP, etc.) to
+    // PostgreSQL equivalents (ILIKE, ~*, etc.). However PostgreSQL doesn't
+    // automatically cast the fields to the right type for these operators,
+    // so we need to alter the query and add the type-cast.
+    $query = preg_replace('/ ([^ ]+) +(I*LIKE|NOT +I*LIKE|~\*|!~\*) /i', ' ${1}::text ${2} ', $query);
+    return parent::prepareStatement($query, $args, $options);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
   public function prepareQuery($query, $quote_identifiers = TRUE) {
+    @trigger_error('Connection::prepareQuery() is deprecated in drupal:9.1.0 and is removed in drupal:10.0.0. Use ::prepareStatement() instead. See https://www.drupal.org/node/TODO', E_USER_DEPRECATED);
     // mapConditionOperator converts some operations (LIKE, REGEXP, etc.) to
     // PostgreSQL equivalents (ILIKE, ~*, etc.). However PostgreSQL doesn't
     // automatically cast the fields to the right type for these operators,
diff --git a/core/lib/Drupal/Core/Database/Driver/pgsql/Insert.php b/core/lib/Drupal/Core/Database/Driver/pgsql/Insert.php
index ce25e647..422a2770 100644
--- a/core/lib/Drupal/Core/Database/Driver/pgsql/Insert.php
+++ b/core/lib/Drupal/Core/Database/Driver/pgsql/Insert.php
@@ -20,7 +20,9 @@ public function execute() {
       return NULL;
     }
 
-    $stmt = $this->connection->prepareQuery((string) $this);
+    // For this driver we do not need to pass arguments to the
+    // prepareStatement method.
+    $stmt = $this->connection->prepareStatement((string) $this, [], $this->queryOptions);
 
     // Fetch the list of blobs and sequences used on that table.
     $table_information = $this->connection->schema()->queryTableInformation($this->table);
diff --git a/core/lib/Drupal/Core/Database/Driver/pgsql/NativeUpsert.php b/core/lib/Drupal/Core/Database/Driver/pgsql/NativeUpsert.php
index 03f9db0d..db08319d 100644
--- a/core/lib/Drupal/Core/Database/Driver/pgsql/NativeUpsert.php
+++ b/core/lib/Drupal/Core/Database/Driver/pgsql/NativeUpsert.php
@@ -19,7 +19,9 @@ public function execute() {
       return NULL;
     }
 
-    $stmt = $this->connection->prepareQuery((string) $this);
+    // For this driver we do not need to pass arguments to the
+    // prepareStatement method.
+    $stmt = $this->connection->prepareStatement((string) $this, [], $this->queryOptions);
 
     // Fetch the list of blobs and sequences used on that table.
     $table_information = $this->connection->schema()->queryTableInformation($this->table);
diff --git a/core/lib/Drupal/Core/Database/Driver/pgsql/Update.php b/core/lib/Drupal/Core/Database/Driver/pgsql/Update.php
index e937f6c8..4aeff0cc 100644
--- a/core/lib/Drupal/Core/Database/Driver/pgsql/Update.php
+++ b/core/lib/Drupal/Core/Database/Driver/pgsql/Update.php
@@ -17,8 +17,9 @@ public function execute() {
     $blob_count = 0;
 
     // Because we filter $fields the same way here and in __toString(), the
-    // placeholders will all match up properly.
-    $stmt = $this->connection->prepareQuery((string) $this);
+    // placeholders will all match up properly. For this driver we do not need
+    // to pass arguments to the prepareStatement method.
+    $stmt = $this->connection->prepareStatement((string) $this, [], $this->queryOptions);
 
     // Fetch the list of blobs and sequences used on that table.
     $table_information = $this->connection->schema()->queryTableInformation($this->table);
diff --git a/core/lib/Drupal/Core/Database/Driver/sqlite/Connection.php b/core/lib/Drupal/Core/Database/Driver/sqlite/Connection.php
index f00ffb75..b80ebc4a 100644
--- a/core/lib/Drupal/Core/Database/Driver/sqlite/Connection.php
+++ b/core/lib/Drupal/Core/Database/Driver/sqlite/Connection.php
@@ -5,6 +5,7 @@
 use Drupal\Core\Database\Database;
 use Drupal\Core\Database\DatabaseNotFoundException;
 use Drupal\Core\Database\Connection as DatabaseConnection;
+use Drupal\Core\Database\StatementInterface;
 
 /**
  * SQLite implementation of \Drupal\Core\Database\Connection.
@@ -336,6 +337,7 @@ public static function sqlFunctionLikeBinary($pattern, $subject) {
    * {@inheritdoc}
    */
   public function prepare($statement, array $driver_options = []) {
+    @trigger_error('Connection::prepare() is deprecated in drupal:9.1.0 and is removed in drupal:10.0.0. See https://www.drupal.org/node/TODO', E_USER_DEPRECATED);
     return new Statement($this->connection, $this, $statement, $driver_options);
   }
 
@@ -400,10 +402,22 @@ public function mapConditionOperator($operator) {
     return isset(static::$sqliteConditionOperatorMap[$operator]) ? static::$sqliteConditionOperatorMap[$operator] : NULL;
   }
 
+  /**
+   * {@inheritdoc}
+   */
+  public function prepareStatement(string $query, array $args, array $options): StatementInterface {
+    $query = $this->prefixTables($query);
+    if (!($options['allow_square_brackets'] ?? FALSE)) {
+      $query = $this->quoteIdentifiers($query);
+    }
+    return new Statement($this->connection, $this, $query, $options['pdo'] ?? []);
+  }
+
   /**
    * {@inheritdoc}
    */
   public function prepareQuery($query, $quote_identifiers = TRUE) {
+    @trigger_error('Connection::prepareQuery() is deprecated in drupal:9.1.0 and is removed in drupal:10.0.0. Use ::prepareStatement() instead. See https://www.drupal.org/node/TODO', E_USER_DEPRECATED);
     $query = $this->prefixTables($query);
     if ($quote_identifiers) {
       $query = $this->quoteIdentifiers($query);
diff --git a/core/lib/Drupal/Core/Database/StatementPrefetch.php b/core/lib/Drupal/Core/Database/StatementPrefetch.php
index 4294b72d..c7f06823 100644
--- a/core/lib/Drupal/Core/Database/StatementPrefetch.php
+++ b/core/lib/Drupal/Core/Database/StatementPrefetch.php
@@ -220,7 +220,7 @@ protected function throwPDOException() {
    *   A PDOStatement object.
    */
   protected function getStatement($query, &$args = []) {
-    return $this->dbh->prepare($query);
+    return $this->dbh->prepare($query, $this->driverOptions);
   }
 
   /**
diff --git a/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Connection.php b/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Connection.php
new file mode 100644
index 00000000..0289fa86
--- /dev/null
+++ b/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Connection.php
@@ -0,0 +1,40 @@
+<?php
+
+namespace Drupal\driver_test\Driver\Database\DrivertestMysqlPrefetch;
+
+use Drupal\Core\Database\Driver\mysql\Connection as CoreConnection;
+
+/**
+ * MySQL test implementation of \Drupal\Core\Database\Connection.
+ */
+class Connection extends CoreConnection {
+
+  /**
+   * Constructs Connection object.
+   */
+  public function __construct(\PDO $connection, array $connection_options) {
+    // We do not pass a PDOStatement class here, we will simulate it in
+    // static::prepareStatement().
+    $this->statementClass = NULL;
+    parent::__construct($connection, $connection_options);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function prepareStatement(string $query, array $args, array $options): StatementInterface {
+    $query = $this->prefixTables($query);
+    if (!($options['allow_square_brackets'] ?? FALSE)) {
+      $query = $this->quoteIdentifiers($query);
+    }
+    return new Statement($this->connection, $this, $query, $args, $options);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function driver() {
+    return 'DrivertestMysqlPrefetch';
+  }
+
+}
diff --git a/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Insert.php b/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Insert.php
new file mode 100644
index 00000000..a9545d77
--- /dev/null
+++ b/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Insert.php
@@ -0,0 +1,10 @@
+<?php
+
+namespace Drupal\driver_test\Driver\Database\DrivertestMysql;
+
+use Drupal\Core\Database\Driver\mysql\Insert as CoreInsert;
+
+/**
+ * MySQL test implementation of \Drupal\Core\Database\Query\Insert.
+ */
+class Insert extends CoreInsert {}
diff --git a/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Install/Tasks.php b/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Install/Tasks.php
new file mode 100644
index 00000000..14065118
--- /dev/null
+++ b/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Install/Tasks.php
@@ -0,0 +1,19 @@
+<?php
+
+namespace Drupal\driver_test\Driver\Database\DrivertestMysqlPrefetch\Install;
+
+use Drupal\Core\Database\Driver\mysql\Install\Tasks as CoreTasks;
+
+/**
+ * Specifies installation tasks for MySQL test databases.
+ */
+class Tasks extends CoreTasks {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function name() {
+    return t('MySQL by the driver_test module, using StatementPrefetch');
+  }
+
+}
diff --git a/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Schema.php b/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Schema.php
new file mode 100644
index 00000000..6833fc0e
--- /dev/null
+++ b/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Schema.php
@@ -0,0 +1,10 @@
+<?php
+
+namespace Drupal\driver_test\Driver\Database\DrivertestMysqlPrefetch;
+
+use Drupal\Core\Database\Driver\mysql\Schema as CoreSchema;
+
+/**
+ * MySQL test implementation of \Drupal\Core\Database\Schema.
+ */
+class Schema extends CoreSchema {}
diff --git a/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Statement.php b/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Statement.php
new file mode 100644
index 00000000..8dab34b0
--- /dev/null
+++ b/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Statement.php
@@ -0,0 +1,324 @@
+<?php
+
+namespace Drupal\driver_test\Driver\Database\DrivertestMysqlPrefetch;
+
+use Drupal\Core\Database\Connection;
+use Drupal\Core\Database\DatabaseExceptionWrapper;
+use Drupal\Core\Database\StatementInterface;
+use Drupal\Core\Database\RowCountException;
+
+/**
+ * Test implementation of Statement.
+ */
+class Statement implements \IteratorAggregate, StatementInterface {
+
+  /**
+   * Reference to the PDO database connection object for this statement.
+   *
+   * The name $dbh is inherited from \PDOStatement.
+   *
+   * @var \PDO
+   */
+  public $dbh;
+
+  /**
+   * Reference to the connection object for this statement.
+   *
+   * @var \Drupal\Core\Database\Connection
+   */
+  protected $connection;
+
+  /**
+   * Is rowCount() execution allowed.
+   *
+   * @var bool
+   */
+  public $allowRowCount = FALSE;
+
+  /**
+   * The PDO statement.
+   *
+   * @var \PDOStatement
+   */
+  protected $PDOStatement;
+
+  /**
+   * The default fetch mode.
+   *
+   * See http://php.net/manual/pdo.constants.php for the definition of the
+   * constants used.
+   *
+   * @var int
+   */
+  protected $defaultFetchMode;
+
+  /**
+   * The query string, in its form with placeholders.
+   *
+   * @var string
+   */
+  protected $queryString;
+
+  /**
+   * The class to be used for returning row results.
+   *
+   * Used when fetch mode is \PDO::FETCH_CLASS.
+   *
+   * @var string
+   */
+  protected $fetchClass;
+
+  public function __construct(\PDO $pdo_connection, Connection $connection, $query, array $args = [], array $options = []) {
+    $this->queryString = $query;
+    $this->dbh = $pdo_connection;
+    $this->connection = $connection;
+    $this->setFetchMode(\PDO::FETCH_OBJ);
+
+    try {
+      $this->PDOStatement = $this->dbh->prepare($this->queryString);
+    }
+    catch (\Exception $e) {
+      throw new DatabaseExceptionWrapper($e->getMessage(), $e->getCode(), $e);
+    }
+  }
+
+  /**
+   * Constructs a Statement object.
+   *
+   * @param \Drupal\drudbal\Driver\Database\dbal\Connection $dbh
+   *   The database connection object for this statement.
+   * @param string $statement
+   *   A string containing an SQL query. Passed by reference.
+   * @param array $params
+   *   (optional) An array of values to substitute into the query at placeholder
+   *   markers. Passed by reference.
+   * @param array $driver_options
+   *   (optional) An array of driver options for this query.
+   */
+/*  public function __construct(DruDbalConnection $dbh, &$statement, array &$params, array $driver_options = []) {
+    $this->queryString = $statement;
+    $this->dbh = $dbh;
+    $this->setFetchMode(\PDO::FETCH_OBJ);
+
+    // Replace named placeholders with positional ones if needed.
+    if (!$this->dbh->getDbalExtension()->delegateNamedPlaceholdersSupport()) {
+      list($statement, $params) = SQLParserUtils::expandListParameters($statement, $params, []);
+    }
+
+    try {
+      $this->dbh->getDbalExtension()->alterStatement($statement, $params);
+      $this->PDOStatement = $dbh->getDbalConnection()->prepare($statement);
+    }
+    catch (DBALException $e) {
+      throw new DatabaseExceptionWrapper($e->getMessage(), $e->getCode(), $e);
+    }
+  }*/
+
+  /**
+   * {@inheritdoc}
+   */
+  public function execute($args = [], $options = []) {
+    if (isset($options['fetch'])) {
+      if (is_string($options['fetch'])) {
+        $this->setFetchMode(\PDO::FETCH_CLASS, $options['fetch']);
+      }
+      else {
+        $this->setFetchMode($options['fetch']);
+      }
+    }
+
+    $logger = $this->connection->getLogger();
+    if (!empty($logger)) {
+      $query_start = microtime(TRUE);
+    }
+
+    $this->PDOStatement->execute($args);
+
+    if (!empty($logger)) {
+      $query_end = microtime(TRUE);
+      $logger->log($this, $args, $query_end - $query_start);
+    }
+
+    return TRUE;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetch($mode = NULL, $cursor_orientation = NULL, $cursor_offset = NULL) {
+    if (is_string($mode)) {
+      $this->setFetchMode(\PDO::FETCH_CLASS, $mode);
+      $mode = \PDO::FETCH_CLASS;
+    }
+    else {
+      $mode = $mode ?: $this->defaultFetchMode;
+    }
+
+    $row = $this->PDOStatement->fetch(FetchMode::ASSOCIATIVE);
+    if (!$row) {
+      return FALSE;
+    }
+    switch ($mode) {
+      case \PDO::FETCH_ASSOC:
+        return $row;
+
+      case \PDO::FETCH_NUM:
+        return array_values($row);
+
+      case \PDO::FETCH_BOTH:
+        return $row + array_values($row);
+
+      case \PDO::FETCH_OBJ:
+        return (object) $row;
+
+      case \PDO::FETCH_CLASS:
+        $class_obj = new $this->fetchClass();
+        foreach ($row as $column => $value) {
+          $class_obj->$column = $value;
+        }
+        return $class_obj;
+
+      case \PDO::FETCH_CLASS | \PDO::FETCH_CLASSTYPE:
+        $class = array_shift($row);
+        $class_obj = new $class();
+        foreach ($row as $column => $value) {
+          $class_obj->$column = $value;
+        }
+        return $class_obj;
+
+      default:
+        throw new DatabaseExceptionWrapper("Unknown fetch type '{$mode}'");
+
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchAll($mode = NULL, $column_index = NULL, $constructor_arguments = NULL) {
+    if (is_string($mode)) {
+      $this->setFetchMode(\PDO::FETCH_CLASS, $mode);
+      $mode = \PDO::FETCH_CLASS;
+    }
+    else {
+      $mode = $mode ?: $this->defaultFetchMode;
+    }
+
+    $rows = [];
+    if (\PDO::FETCH_COLUMN == $mode) {
+      if ($column_index === NULL) {
+        $column_index = 0;
+      }
+      while (($record = $this->fetch(\PDO::FETCH_ASSOC)) !== FALSE) {
+        $cols = array_keys($record);
+        $rows[] = $record[$cols[$column_index]];
+      }
+    }
+    else {
+      while (($row = $this->fetch($mode)) !== FALSE) {
+        $rows[] = $row;
+      }
+    }
+
+    return $rows;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getIterator() {
+    return new \ArrayIterator($this->fetchAll());
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getQueryString() {
+    return $this->queryString;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchCol($index = 0) {
+    return $this->fetchAll(\PDO::FETCH_COLUMN, $index);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchAllAssoc($key, $fetch = NULL) {
+    $return = [];
+    if (isset($fetch)) {
+      if (is_string($fetch)) {
+        $this->setFetchMode(\PDO::FETCH_CLASS, $fetch);
+      }
+      else {
+        $this->setFetchMode($fetch ?: $this->defaultFetchMode);
+      }
+    }
+
+    while ($record = $this->fetch()) {
+      $record_key = is_object($record) ? $record->$key : $record[$key];
+      $return[$record_key] = $record;
+    }
+
+    return $return;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchAllKeyed($key_index = 0, $value_index = 1) {
+    $return = [];
+    $this->setFetchMode(\PDO::FETCH_ASSOC);
+    while ($record = $this->fetch(\PDO::FETCH_ASSOC)) {
+      $cols = array_keys($record);
+      $return[$record[$cols[$key_index]]] = $record[$cols[$value_index]];
+    }
+    return $return;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchField($index = 0) {
+    if (($ret = $this->fetch(\PDO::FETCH_NUM)) === FALSE) {
+      return FALSE;
+    }
+    return $ret[$index] === NULL ? NULL : (string) $ret[$index];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchAssoc() {
+    return $this->fetch(\PDO::FETCH_ASSOC);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchObject($class_name = NULL, $constructor_args = []) {
+    return $this->fetch($class_name ?? \PDO::FETCH_OBJ);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function rowCount() {
+    return $this->PDOStatement->rowCount();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setFetchMode($mode, $a1 = NULL, $a2 = []) {
+    $this->defaultFetchMode = $mode;
+    if ($mode === \PDO::FETCH_CLASS) {
+      $this->fetchClass = $a1;
+    }
+    return TRUE;
+  }
+
+}
diff --git a/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Upsert.php b/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Upsert.php
new file mode 100644
index 00000000..08ca628a
--- /dev/null
+++ b/core/modules/system/tests/modules/driver_test/src/Driver/Database/DrivertestMysqlPrefetch/Upsert.php
@@ -0,0 +1,10 @@
+<?php
+
+namespace Drupal\driver_test\Driver\Database\DrivertestMysqlPrefetch;
+
+use Drupal\Core\Database\Driver\mysql\Upsert as CoreUpsert;
+
+/**
+ * MySQL test implementation of \Drupal\Core\Database\Query\Upsert.
+ */
+class Upsert extends CoreUpsert {}
diff --git a/core/tests/Drupal/FunctionalTests/Database/NonDefaultStatementTest.php b/core/tests/Drupal/FunctionalTests/Database/NonDefaultStatementTest.php
new file mode 100644
index 00000000..2e1f3ce7
--- /dev/null
+++ b/core/tests/Drupal/FunctionalTests/Database/NonDefaultStatementTest.php
@@ -0,0 +1,85 @@
+<?php
+
+namespace Drupal\FunctionalTests\Database;
+
+use Drupal\Core\Database\Database;
+use Drupal\Core\Database\StatementInterface;
+use Drupal\FunctionalTests\Installer\InstallerTestBase;
+
+/**
+ * Tests a non-default database Statement object.
+ *
+ * @group Database
+ */
+class NonDefaultStatementTest extends InstallerTestBase {
+
+  /**
+   * {@inheritdoc}
+   */
+  protected $defaultTheme = 'stark';
+
+  /**
+   * The name of the test database driver in use.
+   * @var string
+   */
+  protected $testDriverName;
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function setUpSettings() {
+    $driver = Database::getConnection()->driver();
+    if ($driver !== 'mysql') {
+      $this->markTestSkipped("This test does not support the {$driver} database driver.");
+    }
+    $this->testDriverName = 'Drivertest' . ucfirst($driver) . 'Prefetch';
+
+    $settings = $this->parameters['forms']['install_settings_form'];
+    $settings['driver'] = $this->testDriverName;
+    $settings[$this->testDriverName] = $settings[$driver];
+    unset($settings[$driver]);
+    $edit = $this->translatePostValues($settings);
+    $this->drupalPostForm(NULL, $edit, $this->translations['Save and continue']);
+  }
+
+  /**
+   * Tests a Statement that replaces named placeholders with positional ones.
+   */
+  public function testPositionalPlaceholdersStatement() {
+    $this->assertTrue(\Drupal::service('module_installer')->install(['database_test']));
+    $connection = Database::getConnection();
+    // $this->fail(var_export($connection->schema()->findTables('%'), TRUE));
+    // $this->fail(var_export($connection->query('SELECT * FROM {users}')->fetchAll(), TRUE));
+    $num_records_before = $connection->select('test')->countQuery()->execute()->fetchField();
+
+    $sql = "INSERT INTO {test} ([name], [age]) VALUES (:name, :age)";
+    $args = [
+      ':name' => 'Larry',
+      ':age' => '30',
+    ];
+    $options = [
+      'return' => Database::RETURN_STATEMENT,
+      'allow_square_brackets' => FALSE,
+      'positional_placeholders' => TRUE,
+    ];
+
+    $stmt = $connection->prepareStatement($sql, $args, $options);
+    $this->assertInstanceOf(StatementInterface::class, $stmt);
+    $this->assertTrue($stmt->execute($args, $options));
+    $this->assertStringContainsString('("name", "age") VALUES (:name, :age)', $stmt->getQueryString()); 
+    // $this->assertSame('DrivertestMysqlPrefetch', $connection->driver());
+    
+    // We should be able to specify values in any order if named.
+    $args = [
+      ':age' => '31',
+      ':name' => 'Curly',
+    ];
+    $this->assertTrue($stmt->execute($args, $options));
+
+    $num_records_after = $connection->select('test')->countQuery()->execute()->fetchField();
+    $this->assertEquals($num_records_before + 2, $num_records_after);
+    $this->assertSame('30', $connection->query('SELECT age FROM {test} WHERE name = :name', [':name' => 'Larry'])->fetchField());
+    $this->assertSame('31', $connection->query('SELECT age FROM {test} WHERE name = :name', [':name' => 'Curly'])->fetchField());
+  }
+
+}
diff --git a/core/tests/Drupal/KernelTests/Core/Database/DatabaseExceptionWrapperTest.php b/core/tests/Drupal/KernelTests/Core/Database/DatabaseExceptionWrapperTest.php
index 54cc6cd3..5000de55 100644
--- a/core/tests/Drupal/KernelTests/Core/Database/DatabaseExceptionWrapperTest.php
+++ b/core/tests/Drupal/KernelTests/Core/Database/DatabaseExceptionWrapperTest.php
@@ -14,9 +14,12 @@
 class DatabaseExceptionWrapperTest extends KernelTestBase {
 
   /**
-   * Tests the expected database exception thrown for prepared statements.
+   * Tests deprecation of Connection::prepare.
+   *
+   * @group legacy
+   * @expectedDeprecation Connection::prepare() is deprecated in drupal:9.1.0 and is removed in drupal:10.0.0. See https://www.drupal.org/node/TODO
    */
-  public function testPreparedStatement() {
+  public function testPrepare() {
     $connection = Database::getConnection();
     try {
       // SQLite validates the syntax upon preparing a statement already.
@@ -40,6 +43,51 @@ public function testPreparedStatement() {
     }
   }
 
+  /**
+   * Tests deprecation of Connection::prepareQuery.
+   *
+   * @group legacy
+   * @expectedDeprecation Connection::prepareQuery() is deprecated in drupal:9.1.0 and is removed in drupal:10.0.0. Use ::prepareStatement() instead. See https://www.drupal.org/node/TODO
+   */
+  public function testPrepareQuery() {
+    $connection = Database::getConnection();
+    try {
+      // SQLite validates the syntax upon preparing a statement already.
+      // @throws \PDOException
+      $query = $connection->prepareQuery('bananas');
+
+      // MySQL only validates the syntax upon trying to execute a query.
+      // @throws \Drupal\Core\Database\DatabaseExceptionWrapper
+      $connection->query($query);
+
+      $this->fail("A \\PDOException or a DatabaseExceptionWrapper should be caught, none was thrown.");
+    }
+    catch (\Exception $e) {
+      $this->assertTrue($e instanceof \PDOException || $e instanceof DatabaseExceptionWrapper, "A \\PDOException or a DatabaseExceptionWrapper should be thrown, " . get_class($e) . " was thrown instead:\n" . (string) $e);
+    }
+  }
+
+  /**
+   * Tests Connection::prepareStatement exceptions.
+   */
+  public function testPrepareStatement() {
+    $connection = Database::getConnection();
+    try {
+      // SQLite validates the syntax upon preparing a statement already.
+      // @throws \PDOException
+      $query = $connection->prepareStatement('bananas', [], []);
+
+      // MySQL only validates the syntax upon trying to execute a query.
+      // @throws \Drupal\Core\Database\DatabaseExceptionWrapper
+      $connection->query($query);
+
+      $this->fail("A \\PDOException or a DatabaseExceptionWrapper should be caught, none was thrown.");
+    }
+    catch (\Exception $e) {
+      $this->assertTrue($e instanceof \PDOException || $e instanceof DatabaseExceptionWrapper, "A \\PDOException or a DatabaseExceptionWrapper should be thrown, " . get_class($e) . " was thrown instead:\n" . (string) $e);
+    }
+  }
+
   /**
    * Tests the expected database exception thrown for inexistent tables.
    */
diff --git a/core/tests/Drupal/KernelTests/Core/Database/StatementTest.php b/core/tests/Drupal/KernelTests/Core/Database/StatementTest.php
new file mode 100644
index 00000000..e1faec3d
--- /dev/null
+++ b/core/tests/Drupal/KernelTests/Core/Database/StatementTest.php
@@ -0,0 +1,48 @@
+<?php
+
+namespace Drupal\KernelTests\Core\Database;
+
+use Drupal\Core\Database\Database;
+use Drupal\Core\Database\StatementInterface;
+
+/**
+ * Tests the Statement classes.
+ *
+ * @group Database
+ */
+class StatementTest extends DatabaseTestBase {
+
+  /**
+   * Tests that a prepared statement object can be reused for multiple inserts.
+   */
+  public function testRepeatedInsertStatementReuse() {
+    $num_records_before = $this->connection->select('test')->countQuery()->execute()->fetchField();
+
+    $sql = "INSERT INTO {test} ([name], [age]) VALUES (:name, :age)";
+    $args = [
+      ':name' => 'Larry',
+      ':age' => '30',
+    ];
+    $options = [
+      'return' => Database::RETURN_STATEMENT,
+      'allow_square_brackets' => FALSE,
+    ];
+
+    $stmt = $this->connection->prepareStatement($sql, $args, $options);
+    $this->assertInstanceOf(StatementInterface::class, $stmt);
+    $this->assertTrue($stmt->execute($args, $options));
+
+    // We should be able to specify values in any order if named.
+    $args = [
+      ':age' => '31',
+      ':name' => 'Curly',
+    ];
+    $this->assertTrue($stmt->execute($args, $options));
+
+    $num_records_after = $this->connection->select('test')->countQuery()->execute()->fetchField();
+    $this->assertEquals($num_records_before + 2, $num_records_after);
+    $this->assertSame('30', $this->connection->query('SELECT age FROM {test} WHERE name = :name', [':name' => 'Larry'])->fetchField());
+    $this->assertSame('31', $this->connection->query('SELECT age FROM {test} WHERE name = :name', [':name' => 'Curly'])->fetchField());
+  }
+
+}
