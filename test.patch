diff --git a/core/lib/Drupal/Core/Database/Connection.php b/core/lib/Drupal/Core/Database/Connection.php
index 142e452ceb..a43668e04e 100644
--- a/core/lib/Drupal/Core/Database/Connection.php
+++ b/core/lib/Drupal/Core/Database/Connection.php
@@ -3,6 +3,7 @@
 namespace Drupal\Core\Database;
 
 use Drupal\Component\Assertion\Inspector;
+use Drupal\Component\EventDispatcher\Event;
 use Drupal\Core\Database\Query\Condition;
 use Drupal\Core\Database\Query\Delete;
 use Drupal\Core\Database\Query\Insert;
@@ -216,6 +217,11 @@ abstract class Connection {
    */
   protected $identifierQuotes;
 
+  /**
+   * @todo
+   */
+  protected bool $statementEventsEnabled = FALSE;
+
   /**
    * Constructs a Connection object.
    *
@@ -1865,4 +1871,106 @@ public function hasJson(): bool {
     }
   }
 
+  /**
+   * @todo
+   */
+  public function areStatementEventsEnabled(): bool {
+    return $this->statementEventsEnabled;
+  }
+
+  /**
+   * @todo
+   */
+  public function enableStatementEvents($bool $toggle): static {
+    $this->statementEventsEnabled = $toggle;
+    return $this;
+  }
+
+  /**
+   * @todo
+   */
+  public function dispatchEvent(Event $event, ?string $eventName = NULL): Event {
+    return $event;
+  }
+
+  /**
+   * Determine the last non-database method that called the database API.
+   *
+   * Traversing the call stack from the very first call made during the
+   * request, we define "the routine that called this query" as the last entry
+   * in the call stack that is not any method called from the namespace of the
+   * database driver, is not inside the Drupal\Core\Database namespace and does
+   * have a file (which excludes call_user_func_array(), anonymous functions
+   * and similar). That makes the climbing logic very simple, and handles the
+   * variable stack depth caused by the query builders.
+   *
+   * See the @link http://php.net/debug_backtrace debug_backtrace() @endlink
+   * function.
+   *
+   * @return array
+   *   This method returns a stack trace entry similar to that generated by
+   *   debug_backtrace(). However, it flattens the trace entry and the trace
+   *   entry before it so that we get the function and args of the function that
+   *   called into the database system, not the function and args of the
+   *   database call itself.
+   */
+  public function findCaller(): array {
+    $stack = $this->removeDatabaseEntries($this->getDebugBacktrace());
+
+    // Return the first function call whose stack entry has a 'file' key, that
+    // is, it is not a callback or a closure.
+    for ($i = 0; $i < count($stack); $i++) {
+      if (!empty($stack[$i]['file'])) {
+        return [
+          'file' => $stack[$i]['file'],
+          'line' => $stack[$i]['line'],
+          'function' => $stack[$i + 1]['function'],
+          'class' => $stack[$i + 1]['class'] ?? NULL,
+          'type' => $stack[$i + 1]['type'] ?? NULL,
+          'args' => $stack[$i + 1]['args'] ?? [],
+        ];
+      }
+    }
+
+    return [];
+  }
+
+  /**
+   * Removes database related calls from a backtrace array.
+   *
+   * @param array $backtrace
+   *   A standard PHP backtrace. Passed by reference.
+   *
+   * @return array
+   *   The cleaned backtrace array.
+   */
+  protected function removeDatabaseEntries(array $backtrace): array {
+    // Starting from the very first entry processed during the request, find
+    // the first function call that can be identified as a call to a
+    // method/function in the database layer.
+    for ($n = count($backtrace) - 1; $n >= 0; $n--) {
+      // If the call was made from a function, 'class' will be empty. We give
+      // it a default empty string value in that case.
+      $class = $backtrace[$n]['class'] ?? '';
+      if (strpos($class, __NAMESPACE__, 0) === 0 || strpos($class, $this->getConnectionOptions()['namespace'], 0) === 0) {
+        break;
+      }
+    }
+
+    return array_values(array_slice($backtrace, $n));
+  }
+
+  /**
+   * Gets the debug backtrace.
+   *
+   * Wraps the debug_backtrace function to allow mocking results in PHPUnit
+   * tests.
+   *
+   * @return array[]
+   *   The debug backtrace.
+   */
+  protected function getDebugBacktrace(): array {
+    return debug_backtrace();
+  }
+
 }
diff --git a/core/lib/Drupal/Core/Database/Database.php b/core/lib/Drupal/Core/Database/Database.php
index 9b5364942b..039960f38c 100644
--- a/core/lib/Drupal/Core/Database/Database.php
+++ b/core/lib/Drupal/Core/Database/Database.php
@@ -122,6 +122,7 @@ abstract class Database {
       // logging object associated with it.
       if (!empty(self::$connections[$key])) {
         foreach (self::$connections[$key] as $connection) {
+          $connection->enableStatementEvents(TRUE);
           $connection->setLogger(self::$logs[$key]);
         }
       }
@@ -450,6 +451,7 @@ abstract class Database {
     // If we have any active logging objects for this connection key, we need
     // to associate them with the connection we just opened.
     if (!empty(self::$logs[$key])) {
+      $new_connection->enableStatementEvents(TRUE);
       $new_connection->setLogger(self::$logs[$key]);
     }
 
diff --git a/core/lib/Drupal/Core/Database/DatabaseEvents.php b/core/lib/Drupal/Core/Database/DatabaseEvents.php
new file mode 100644
index 0000000000..95fdf6893f
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/DatabaseEvents.php
@@ -0,0 +1,28 @@
+<?php
+
+namespace Drupal\Core\Database;
+
+/**
+ * Defines events for the database system.
+ */
+final class DatabaseEvents {
+
+  /**
+   * Name of the event fired when starting a statement execution.
+   *
+   * @Event
+   *
+   * @var string
+   */
+  const STATEMENT_EXECUTION_START = 'database.statement.execution.start';
+
+  /**
+   * Name of the event fired when a statement execution is finished.
+   *
+   * @Event
+   *
+   * @var string
+   */
+  const STATEMENT_EXECUTION_END = 'database.statement.execution.end';
+
+}
diff --git a/core/lib/Drupal/Core/Database/Event/StatementExecutionEvent.php b/core/lib/Drupal/Core/Database/Event/StatementExecutionEvent.php
new file mode 100644
index 0000000000..ab6ebf3713
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/Event/StatementExecutionEvent.php
@@ -0,0 +1,47 @@
+<?php
+
+namespace Drupal\Core\Database\Event;
+
+use Drupal\Component\EventDispatcher\Event;
+
+/**
+ * Represents a statement execution as an event.
+ */
+class StatementExecutionEvent extends Event {
+
+  /**
+   * The time of the statement execution start.
+   */
+  protected float $startTime;
+
+  /**
+   * The time of the statement execution end.
+   */
+  protected float $endTime;
+
+  /**
+   * Constructs a StatementExecutionEvent object.
+   */
+  public function __construct(
+    public readonly string $key,
+    public readonly string $target,
+    public readonly string $queryString,
+    public readonly array $args,
+    public readonly array $caller,
+  ) {}
+
+  /**
+   * Sets the query start time.
+   */
+  public function setStartTime(float $time): void {
+    $this->startTime = $time;
+  }
+
+  /**
+   * Sets the query end time.
+   */
+  public function setEndTime(float $time): void {
+    $this->endTime = $time;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Database/Log.php b/core/lib/Drupal/Core/Database/Log.php
index b310d17284..71e7f5f3fd 100644
--- a/core/lib/Drupal/Core/Database/Log.php
+++ b/core/lib/Drupal/Core/Database/Log.php
@@ -115,6 +115,7 @@ public function end($logging_key) {
    *   with microsecond precision).
    */
   public function log(StatementInterface $statement, $args, $time, float $start = NULL) {
+    @trigger_error(__METHOD__ . '() is deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. Use ::logFromEvent(). See https://www.drupal.org/node/7654321', E_USER_DEPRECATED);
     foreach (array_keys($this->queryLog) as $key) {
       $this->queryLog[$key][] = [
         'query' => $statement->getQueryString(),
@@ -149,6 +150,7 @@ public function log(StatementInterface $statement, $args, $time, float $start =
    *   database call itself.
    */
   public function findCaller() {
+    @trigger_error(__METHOD__ . '() is deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. Use Connection::findCaller(). See https://www.drupal.org/node/7654321', E_USER_DEPRECATED);
     $driver_namespace = Database::getConnectionInfo($this->connectionKey)['default']['namespace'];
     $stack = static::removeDatabaseEntries($this->getDebugBacktrace(), $driver_namespace);
 
@@ -180,6 +182,7 @@ public function findCaller() {
    *   The cleaned backtrace array.
    */
   public static function removeDatabaseEntries(array $backtrace, string $driver_namespace): array {
+    @trigger_error(__METHOD__ . '() is deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. Use Connection::removeDatabaseEntries(). See https://www.drupal.org/node/7654321', E_USER_DEPRECATED);
     // Starting from the very first entry processed during the request, find
     // the first function call that can be identified as a call to a
     // method/function in the database layer.
@@ -205,6 +208,7 @@ public static function removeDatabaseEntries(array $backtrace, string $driver_na
    *   The debug backtrace.
    */
   protected function getDebugBacktrace() {
+    @trigger_error(__METHOD__ . '() is deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. There is no replacement. See https://www.drupal.org/node/7654321', E_USER_DEPRECATED);
     return debug_backtrace();
   }
 
diff --git a/core/lib/Drupal/Core/Database/StatementPrefetch.php b/core/lib/Drupal/Core/Database/StatementPrefetch.php
index 0702bd1de4..90ad57c52f 100644
--- a/core/lib/Drupal/Core/Database/StatementPrefetch.php
+++ b/core/lib/Drupal/Core/Database/StatementPrefetch.php
@@ -2,6 +2,8 @@
 
 namespace Drupal\Core\Database;
 
+use Drupal\Core\Database\Event\StatementExecutionEvent;
+
 /**
  * An implementation of StatementInterface that prefetches all data.
  *
@@ -172,9 +174,16 @@ public function execute($args = [], $options = []) {
       }
     }
 
-    $logger = $this->connection->getLogger();
-    if (!empty($logger)) {
-      $query_start = microtime(TRUE);
+    if ($this->connection->areStatementEventsEnabled()) {
+      $event = new StatementExecutionEvent(
+        $this->connection->getKey(),
+        $this->connection->getTarget(),
+        $this->getQueryString(),
+        $args ?? [],
+        $this->connection->findCaller()
+      );
+      $event->setStartTime(microtime(TRUE));
+      $this->connection->dispatchEvent($event, DatabaseEvents::STATEMENT_EXECUTION_START);
     }
 
     // Prepare the query.
@@ -207,9 +216,9 @@ public function execute($args = [], $options = []) {
       $this->columnNames = [];
     }
 
-    if (!empty($logger)) {
-      $query_end = microtime(TRUE);
-      $logger->log($this, $args, $query_end - $query_start, $query_start);
+    if (isset($event)) {
+      $event->setEndTime(microtime(TRUE));
+      $this->connection->dispatchEvent($event, DatabaseEvents::STATEMENT_EXECUTION_END);
     }
 
     // Initialize the first row in $this->currentRow.
diff --git a/core/lib/Drupal/Core/Database/StatementWrapper.php b/core/lib/Drupal/Core/Database/StatementWrapper.php
index 8a3bc208c5..37e089592b 100644
--- a/core/lib/Drupal/Core/Database/StatementWrapper.php
+++ b/core/lib/Drupal/Core/Database/StatementWrapper.php
@@ -2,6 +2,8 @@
 
 namespace Drupal\Core\Database;
 
+use Drupal\Core\Database\Event\StatementExecutionEvent;
+
 // cSpell:ignore maxlen driverdata INOUT
 
 /**
@@ -87,16 +89,23 @@ public function execute($args = [], $options = []) {
       }
     }
 
-    $logger = $this->connection->getLogger();
-    if (!empty($logger)) {
-      $query_start = microtime(TRUE);
+    if ($this->connection->areStatementEventsEnabled()) {
+      $event = new StatementExecutionEvent(
+        $this->connection->getKey(),
+        $this->connection->getTarget(),
+        $this->getQueryString(),
+        $args ?? [],
+        $this->connection->findCaller()
+      );
+      $event->setStartTime(microtime(TRUE));
+      $this->connection->dispatchEvent($event, DatabaseEvents::STATEMENT_EXECUTION_START);
     }
 
     $return = $this->clientStatement->execute($args);
 
-    if (!empty($logger)) {
-      $query_end = microtime(TRUE);
-      $logger->log($this, $args, $query_end - $query_start, $query_start);
+    if (isset($event)) {
+      $event->setEndTime(microtime(TRUE));
+      $this->connection->dispatchEvent($event, DatabaseEvents::STATEMENT_EXECUTION_END);
     }
 
     return $return;
diff --git a/core/phpstan-baseline.neon b/core/phpstan-baseline.neon
index cf84abce27..e9f0f726b9 100644
--- a/core/phpstan-baseline.neon
+++ b/core/phpstan-baseline.neon
@@ -330,16 +330,6 @@ parameters:
 			count: 1
 			path: lib/Drupal/Core/Database/Query/Upsert.php
 
-		-
-			message: "#^Variable \\$query_start might not be defined\\.$#"
-			count: 2
-			path: lib/Drupal/Core/Database/StatementPrefetch.php
-
-		-
-			message: "#^Variable \\$query_start might not be defined\\.$#"
-			count: 2
-			path: lib/Drupal/Core/Database/StatementWrapper.php
-
 		-
 			message: "#^Call to deprecated constant REQUEST_TIME\\: Deprecated in drupal\\:8\\.3\\.0 and is removed from drupal\\:10\\.0\\.0\\. Use \\\\Drupal\\:\\:time\\(\\)\\-\\>getRequestTime\\(\\); $#"
 			count: 2
