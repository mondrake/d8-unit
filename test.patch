diff --git a/core/modules/mysqli/mysqli.info.yml b/core/modules/mysqli/mysqli.info.yml
new file mode 100644
index 0000000000..38a9239f3e
--- /dev/null
+++ b/core/modules/mysqli/mysqli.info.yml
@@ -0,0 +1,9 @@
+name: MySQLi
+type: module
+description: 'Database driver for MySQLi.'
+version: VERSION
+package: Core (Experimental)
+lifecycle: experimental
+hidden: true
+dependencies:
+  - drupal:mysql
diff --git a/core/modules/mysqli/mysqli.module b/core/modules/mysqli/mysqli.module
new file mode 100644
index 0000000000..e243b3fce5
--- /dev/null
+++ b/core/modules/mysqli/mysqli.module
@@ -0,0 +1,25 @@
+<?php
+
+/**
+ * @file
+ * Database driver for MySQLi.
+ *
+ * The MySQLi module provides the connection between Drupal and a MySQL, MariaDB
+ * or equivalent database using the mysqli PHP extension.
+ */
+
+use Drupal\Core\Routing\RouteMatchInterface;
+
+/**
+ * Implements hook_help().
+ */
+function mysqli_help($route_name, RouteMatchInterface $route_match) {
+  switch ($route_name) {
+    case 'help.page.mysqli':
+      $output = '';
+      $output .= '<h3>' . t('About') . '</h3>';
+      $output .= '<p>' . t('The MySQLi module provides the connection between Drupal and a MySQL, MariaDB or equivalent database using the mysqli PHP extension. For more information, see the <a href=":mysqli">online documentation for the MySQLi module</a>.', [':mysqli' => 'https://www.drupal.org/documentation/modules/mysqli']) . '</p>';
+      return $output;
+
+  }
+}
diff --git a/core/modules/mysqli/mysqli.services.yml b/core/modules/mysqli/mysqli.services.yml
new file mode 100644
index 0000000000..82a476ceb9
--- /dev/null
+++ b/core/modules/mysqli/mysqli.services.yml
@@ -0,0 +1,4 @@
+services:
+  mysqli.views.cast_sql:
+    class: Drupal\mysqli\Plugin\views\query\MysqliCastSql
+    public: false
diff --git a/core/modules/mysqli/src/Driver/Database/mysqli/Connection.php b/core/modules/mysqli/src/Driver/Database/mysqli/Connection.php
new file mode 100644
index 0000000000..6858b7fed8
--- /dev/null
+++ b/core/modules/mysqli/src/Driver/Database/mysqli/Connection.php
@@ -0,0 +1,192 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\mysqli\Driver\Database\mysqli;
+
+use Drupal\Core\Database\ConnectionNotDefinedException;
+use Drupal\Core\Database\DatabaseAccessDeniedException;
+use Drupal\Core\Database\DatabaseNotFoundException;
+use Drupal\Core\Database\Transaction\TransactionManagerInterface;
+use Drupal\mysql\Driver\Database\mysql\Connection as BaseMySqlConnection;
+
+/**
+ * MySQLi implementation of \Drupal\Core\Database\Connection.
+ */
+class Connection extends BaseMySqlConnection {
+
+  /**
+   * {@inheritdoc}
+   */
+  protected $statementWrapperClass = Statement::class;
+
+  /**
+   * Stores the server version after it has been retrieved from the database.
+   */
+  private string $serverVersion;
+
+  public function __construct(\mysqli $connection, array $connection_options) {
+    // If the SQL mode doesn't include 'ANSI_QUOTES' (explicitly or via a
+    // combination mode), then MySQL doesn't interpret a double quote as an
+    // identifier quote, in which case use the non-ANSI-standard backtick.
+    //
+    // Because we still support MySQL 5.7, check for the deprecated combination
+    // modes as well.
+    //
+    // @see https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_ansi_quotes
+    $ansi_quotes_modes = ['ANSI_QUOTES', 'ANSI', 'DB2', 'MAXDB', 'MSSQL', 'ORACLE', 'POSTGRESQL'];
+    $is_ansi_quotes_mode = FALSE;
+    foreach ($ansi_quotes_modes as $mode) {
+      // None of the modes in $ansi_quotes_modes are substrings of other modes
+      // that are not in $ansi_quotes_modes, so a simple stripos() does not
+      // return false positives.
+      if (stripos($connection_options['init_commands']['sql_mode'], $mode) !== FALSE) {
+        $is_ansi_quotes_mode = TRUE;
+        break;
+      }
+    }
+    if ($this->identifierQuotes === ['"', '"'] && !$is_ansi_quotes_mode) {
+      $this->identifierQuotes = ['`', '`'];
+    }
+
+    // Manage the table prefix.
+    $connection_options['prefix'] = $connection_options['prefix'] ?? '';
+    $this->setPrefix($connection_options['prefix']);
+
+    // Work out the database driver namespace if none is provided. This normally
+    // written to setting.php by installer or set by
+    // \Drupal\Core\Database\Database::parseConnectionInfo().
+    if (empty($connection_options['namespace'])) {
+      $connection_options['namespace'] = (new \ReflectionObject($this))->getNamespaceName();
+    }
+
+    $this->connection = $connection;
+    $this->connectionOptions = $connection_options;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function open(array &$connection_options = []) {
+    // Sets mysqli error reporting mode to report errors from mysqli function
+    // calls and to throw mysqli_sql_exception for errors.
+    // @see https://www.php.net/manual/en/mysqli-driver.report-mode.php
+    mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);
+
+    if (isset($connection_options['_dsn_utf8_fallback']) && $connection_options['_dsn_utf8_fallback'] === TRUE) {
+      // Only used during the installer version check, as a fallback from utf8mb4.
+      $charset = 'utf8';
+    }
+    else {
+      $charset = 'utf8mb4';
+    }
+
+    // Allow PDO options to be overridden.
+    $connection_options += [
+      'pdo' => [],
+    ];
+
+    try {
+      $mysqli = new \mysqli(
+        $connection_options['host'],
+        $connection_options['username'],
+        $connection_options['password'],
+        $connection_options['database'] ?? '',
+        !empty($connection_options['port']) ? (int) $connection_options['port'] : 3306,
+        $connection_options['unix_socket'] ?? ''
+      );
+      if (!$mysqli->set_charset($charset)) {
+        throw new InvalidCharsetException('Invalid charset ' . $charset);
+      }
+    }
+    catch (\mysqli_sql_exception $e) {
+      if ($e->getCode() === static::DATABASE_NOT_FOUND) {
+        throw new DatabaseNotFoundException($e->getMessage(), $e->getCode(), $e);
+      }
+      elseif ($e->getCode() === static::ACCESS_DENIED) {
+        throw new DatabaseAccessDeniedException($e->getMessage(), $e->getCode(), $e);
+      }
+      else {
+        throw new ConnectionNotDefinedException('Invalid database connection: ' . $e->getMessage(), $e->getCode(), $e);
+      }
+      throw $e;
+    }
+
+    // Force MySQL to use the UTF-8 character set. Also set the collation, if a
+    // certain one has been set; otherwise, MySQL defaults to
+    // 'utf8mb4_general_ci' (MySQL 5) or 'utf8mb4_0900_ai_ci' (MySQL 8) for
+    // utf8mb4.
+    if (!empty($connection_options['collation'])) {
+      $mysqli->query('SET NAMES ' . $charset . ' COLLATE ' . $connection_options['collation']);
+    }
+    else {
+      $mysqli->query('SET NAMES ' . $charset);
+    }
+
+    // Set MySQL init_commands if not already defined.  Default Drupal's MySQL
+    // behavior to conform more closely to SQL standards.  This allows Drupal
+    // to run almost seamlessly on many different kinds of database systems.
+    // These settings force MySQL to behave the same as postgresql, or sqlite
+    // in regards to syntax interpretation and invalid data handling.  See
+    // https://www.drupal.org/node/344575 for further discussion. Also, as MySQL
+    // 5.5 changed the meaning of TRADITIONAL we need to spell out the modes one
+    // by one.
+    $connection_options += [
+      'init_commands' => [],
+    ];
+
+    $connection_options['init_commands'] += [
+      'sql_mode' => "SET sql_mode = 'ANSI,TRADITIONAL'",
+    ];
+
+    // Execute initial commands.
+    foreach ($connection_options['init_commands'] as $sql) {
+      $mysqli->query($sql);
+    }
+
+    return $mysqli;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function driver() {
+    return 'mysqli';
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function clientVersion() {
+    return \mysqli_get_client_info();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function quote($string, $parameter_type = \PDO::PARAM_STR) {
+    return "'" . $this->connection->escape_string($string) . "'";
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function lastInsertId(?string $name = NULL): string {
+    return (string) $this->connection->insert_id;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function exceptionHandler() {
+    return new ExceptionHandler();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function driverTransactionManager(): TransactionManagerInterface {
+    return new TransactionManager($this);
+  }
+
+}
diff --git a/core/modules/mysqli/src/Driver/Database/mysqli/ExceptionHandler.php b/core/modules/mysqli/src/Driver/Database/mysqli/ExceptionHandler.php
new file mode 100644
index 0000000000..127f0a68f1
--- /dev/null
+++ b/core/modules/mysqli/src/Driver/Database/mysqli/ExceptionHandler.php
@@ -0,0 +1,61 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\mysqli\Driver\Database\mysqli;
+
+use Drupal\Component\Utility\Unicode;
+use Drupal\Core\Database\DatabaseExceptionWrapper;
+use Drupal\Core\Database\ExceptionHandler as BaseExceptionHandler;
+use Drupal\Core\Database\Exception\SchemaTableColumnSizeTooLargeException;
+use Drupal\Core\Database\Exception\SchemaTableKeyTooLargeException;
+use Drupal\Core\Database\IntegrityConstraintViolationException;
+use Drupal\Core\Database\StatementInterface;
+
+/**
+ * MySQLi database exception handler class.
+ */
+class ExceptionHandler extends BaseExceptionHandler {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function handleExecutionException(\Exception $exception, StatementInterface $statement, array $arguments = [], array $options = []): void {
+    if (!($exception instanceof \mysqli_sql_exception)) {
+      throw $exception;
+    }
+
+    // Wrap the exception in another exception, because PHP does not allow
+    // overriding Exception::getMessage(). Its message is the extra database
+    // debug information.
+    $code = is_int($exception->getCode()) ? $exception->getCode() : 0;
+
+    // If a max_allowed_packet error occurs the message length is truncated.
+    // This should prevent the error from recurring if the exception is logged
+    // to the database using dblog or the like.
+    if ($code === 1153) {
+      $message = Unicode::truncateBytes($exception->getMessage(), Connection::MIN_MAX_ALLOWED_PACKET);
+      throw new DatabaseExceptionWrapper($message, $code, $exception);
+    }
+
+    $message = $exception->getMessage() . ": " . $statement->getQueryString() . "; " . print_r($arguments, TRUE);
+
+    // SQLSTATE 23xxx errors indicate an integrity constraint violation. Also,
+    // in case of attempted INSERT of a record with an undefined column and no
+    // default value indicated in schema, MySql returns a 1364 error code.
+    if (substr($exception->getSqlState(), -6, -3) == '23' || $code === 1364) {
+      throw new IntegrityConstraintViolationException($message, $code, $exception);
+    }
+
+    if ($exception->getSqlState() === '42000') {
+      match ($code) {
+        1071 => throw new SchemaTableKeyTooLargeException($message, $code, $exception),
+        1074 => throw new SchemaTableColumnSizeTooLargeException($message, $code, $exception),
+        default => throw new DatabaseExceptionWrapper($message, 0, $exception),
+      };
+    }
+
+    throw new DatabaseExceptionWrapper($message, 0, $exception);
+  }
+
+}
diff --git a/core/modules/mysqli/src/Driver/Database/mysqli/Install/Tasks.php b/core/modules/mysqli/src/Driver/Database/mysqli/Install/Tasks.php
new file mode 100644
index 0000000000..41c011084d
--- /dev/null
+++ b/core/modules/mysqli/src/Driver/Database/mysqli/Install/Tasks.php
@@ -0,0 +1,28 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\mysqli\Driver\Database\mysqli\Install;
+
+use Drupal\mysql\Driver\Database\mysql\Install\Tasks as BaseInstallTasks;
+
+/**
+ * Specifies installation tasks for MySQLi.
+ */
+class Tasks extends BaseInstallTasks {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function installable() {
+    return extension_loaded('mysqli');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function name() {
+    return $this->t('@parent via mysqli', ['@parent' => parent::name()]);
+  }
+
+}
diff --git a/core/modules/mysqli/src/Driver/Database/mysqli/InvalidCharsetException.php b/core/modules/mysqli/src/Driver/Database/mysqli/InvalidCharsetException.php
new file mode 100644
index 0000000000..e6f2c86148
--- /dev/null
+++ b/core/modules/mysqli/src/Driver/Database/mysqli/InvalidCharsetException.php
@@ -0,0 +1,13 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\mysqli\Driver\Database\mysqli;
+
+use Drupal\Core\Database\DatabaseExceptionWrapper;
+
+/**
+ * This exception class signals an invalid charset is being used.
+ */
+class InvalidCharsetException extends DatabaseExceptionWrapper {
+}
diff --git a/core/modules/mysqli/src/Driver/Database/mysqli/NamedPlaceholderConverter.php b/core/modules/mysqli/src/Driver/Database/mysqli/NamedPlaceholderConverter.php
new file mode 100644
index 0000000000..94e7be3f94
--- /dev/null
+++ b/core/modules/mysqli/src/Driver/Database/mysqli/NamedPlaceholderConverter.php
@@ -0,0 +1,227 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\mysqli\Driver\Database\mysqli;
+
+// cspell:ignore DBAL MULTICHAR
+
+/**
+ * A class to convert a SQL statement with named placeholders to positional.
+ *
+ * The parsing logic and the implementation is inspired by the PHP PDO parser,
+ * and a simplified copy of the parser implementation done by the Doctrine DBAL
+ * project.
+ *
+ * @internal
+ *
+ * @see https://github.com/doctrine/dbal/blob/3.6.x/src/SQL/Parser.php
+ */
+final class NamedPlaceholderConverter {
+  /**
+   * A list of regex patterns for parsing.
+   */
+  private const SPECIAL_CHARS = ':\?\'"`\\[\\-\\/';
+  private const BACKTICK_IDENTIFIER = '`[^`]*`';
+  private const BRACKET_IDENTIFIER = '(?<!\b(?i:ARRAY))\[(?:[^\]])*\]';
+  private const MULTICHAR = ':{2,}';
+  private const NAMED_PARAMETER = ':[a-zA-Z0-9_]+';
+  private const POSITIONAL_PARAMETER = '(?<!\\?)\\?(?!\\?)';
+  private const ONE_LINE_COMMENT = '--[^\r\n]*';
+  private const MULTI_LINE_COMMENT = '/\*([^*]+|\*+[^/*])*\**\*/';
+  private const SPECIAL = '[' . self::SPECIAL_CHARS . ']';
+  private const OTHER = '[^' . self::SPECIAL_CHARS . ']+';
+
+  /**
+   * The combined regex pattern for parsing.
+   */
+  private string $sqlPattern;
+
+  /**
+   * The list of original named arguments.
+   *
+   * The initial placeholder colon is removed.
+   */
+  private array $originalParameters = [];
+
+  /**
+   * The maximum positional placeholder parsed.
+   *
+   * Normally Drupal does not produce SQL with positional placeholders, but
+   * this is to manage the edge case.
+   */
+  private int $originalParameterIndex = 0;
+
+  /**
+   * The converted SQL statement in its parts.
+   *
+   * @var string[]
+   */
+  private array $convertedSQL = [];
+
+  /**
+   * The list of converted arguments.
+   *
+   * @var mixed[]
+   */
+  private array $convertedParameters = [];
+
+  public function __construct() {
+    // Builds the combined regex pattern for parsing.
+    $this->sqlPattern = sprintf('(%s)', implode('|', [
+      $this->getAnsiSQLStringLiteralPattern("'"),
+      $this->getAnsiSQLStringLiteralPattern('"'),
+      self::BACKTICK_IDENTIFIER,
+      self::BRACKET_IDENTIFIER,
+      self::MULTICHAR,
+      self::ONE_LINE_COMMENT,
+      self::MULTI_LINE_COMMENT,
+      self::OTHER,
+    ]));
+  }
+
+  /**
+   * Parses an SQL statement with named placeholders.
+   *
+   * This methods explodes the SQL statement in parts that can be reassembled
+   * into a string with positional placeholders.
+   *
+   * @param string $sql
+   *   The SQL statement with named placeholders.
+   * @param mixed[] $args
+   *   The statement arguments.
+   */
+  public function parse(string $sql, array $args): void {
+    foreach ($args as $key => $value) {
+      if (is_int($key)) {
+        // Positional placeholder; edge case.
+        $this->originalParameters[$key] = $value;
+      }
+      else {
+        // Named placeholder like ':placeholder'; remove the initial colon.
+        $parameter = $key[0] === ':' ? substr($key, 1) : $key;
+        $this->originalParameters[$parameter] = $value;
+      }
+    }
+    $this->originalParameterIndex = 0;
+    $this->convertedSQL = [];
+    $this->convertedParameters = [];
+
+    /** @var array<string,callable> $patterns */
+    $patterns = [
+      self::NAMED_PARAMETER => function (string $sql): void {
+        $this->addNamedParameter($sql);
+      },
+      self::POSITIONAL_PARAMETER => function (string $sql): void {
+        $this->addPositionalParameter($sql);
+      },
+      $this->sqlPattern => function (string $sql): void {
+        $this->addOther($sql);
+      },
+      self::SPECIAL => function (string $sql): void {
+        $this->addOther($sql);
+      },
+    ];
+
+    $offset = 0;
+
+    while (($handler = current($patterns)) !== FALSE) {
+      if (preg_match('~\G' . key($patterns) . '~s', $sql, $matches, 0, $offset) === 1) {
+        $handler($matches[0]);
+        reset($patterns);
+        $offset += strlen($matches[0]);
+      }
+      elseif (preg_last_error() !== PREG_NO_ERROR) {
+        throw new \RuntimeException('Regular expression error');
+      }
+      else {
+        next($patterns);
+      }
+    }
+
+    assert($offset === strlen($sql));
+  }
+
+  /**
+   * Helper to return a regex pattern from a delimiter character..
+   *
+   * @param string $delimiter
+   *   A delimiter character.
+   *
+   * @return string
+   *   The regex pattern.
+   */
+  private function getAnsiSQLStringLiteralPattern(string $delimiter): string {
+    return $delimiter . '[^' . $delimiter . ']*' . $delimiter;
+  }
+
+  /**
+   * Adds a positional placeholder to the converted parts.
+   *
+   * Normally Drupal does not produce SQL with positional placeholders, but
+   * this is to manage the edge case.
+   *
+   * @param string $sql
+   *   The SQL part.
+   */
+  private function addPositionalParameter(string $sql): void {
+    $index = $this->originalParameterIndex;
+
+    if (!array_key_exists($index, $this->originalParameters)) {
+      throw new \RuntimeException('Missing Positional Parameter ' . $index);
+    }
+
+    $this->convertedSQL[] = '?';
+    $this->convertedParameters[] = $this->originalParameters[$index];
+
+    $this->originalParameterIndex++;
+  }
+
+  /**
+   * Adds a named placeholder to the converted parts.
+   *
+   * @param string $sql
+   *   The SQL part.
+   */
+  private function addNamedParameter(string $sql): void {
+    $name = substr($sql, 1);
+
+    if (!array_key_exists($name, $this->originalParameters)) {
+      throw new \RuntimeException('Missing Named Parameter ' . $name);
+    }
+
+    $this->convertedSQL[] = '?';
+    $this->convertedParameters[] = $this->originalParameters[$name];
+  }
+
+  /**
+   * Adds a generic SQL string fragment to the converted parts.
+   *
+   * @param string $sql
+   *   The SQL part.
+   */
+  private function addOther(string $sql): void {
+    $this->convertedSQL[] = $sql;
+  }
+
+  /**
+   * Returns the converted SQL statement with positional placeholders.
+   *
+   * @return string
+   *   The converted SQL statement with positional placeholders.
+   */
+  public function getConvertedSQL(): string {
+    return implode('', $this->convertedSQL);
+  }
+
+  /**
+   * Returns the array of arguments for use with positional placeholders.
+   *
+   * @return mixed[]
+   *   The array of arguments for use with positional placeholders.
+   */
+  public function getConvertedParameters(): array {
+    return $this->convertedParameters;
+  }
+
+}
diff --git a/core/modules/mysqli/src/Driver/Database/mysqli/Statement.php b/core/modules/mysqli/src/Driver/Database/mysqli/Statement.php
new file mode 100644
index 0000000000..82c8fa2454
--- /dev/null
+++ b/core/modules/mysqli/src/Driver/Database/mysqli/Statement.php
@@ -0,0 +1,359 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\mysqli\Driver\Database\mysqli;
+
+use Drupal\Core\Database\Connection;
+use Drupal\Core\Database\DatabaseExceptionWrapper;
+use Drupal\Core\Database\Event\StatementExecutionEndEvent;
+use Drupal\Core\Database\Event\StatementExecutionStartEvent;
+use Drupal\Core\Database\RowCountException;
+use Drupal\Core\Database\StatementWrapperIterator;
+
+/**
+ * MySQLi implementation of \Drupal\Core\Database\Query\StatementInterface.
+ */
+class Statement extends StatementWrapperIterator {
+
+  /**
+   * Holds the index position of named parameters.
+   *
+   * The mysqli driver only allows positional placeholders '?', whereas in
+   * Drupal the SQL is generated with named placeholders ':name'. In order to
+   * execute the SQL, the string containing the named placeholders is converted
+   * to using positional ones, and the position (index) of each named
+   * placeholder in the string is stored here.
+   */
+  protected array $paramsPositions;
+
+  /**
+   * The default fetch mode.
+   *
+   * See http://php.net/manual/pdo.constants.php for the definition of the
+   * constants used.
+   */
+  protected int $defaultFetchStyle;
+
+  /**
+   * Holds fetch options.
+   *
+   * @var string[]
+   */
+  protected array $fetchOptions = [
+    'class' => 'stdClass',
+    'constructor_args' => [],
+    'object' => NULL,
+    'column' => 0,
+  ];
+
+  /**
+   * The mysqli result object.
+   *
+   * Stores results of a data selection query.
+   */
+  protected ?\mysqli_result $mysqliResult;
+
+  /**
+   * Constructs a Statement object.
+   *
+   * @param \Drupal\Core\Database\Connection $connection
+   *   Drupal database connection object.
+   * @param \mysqli $mysqliConnection
+   *   Client database connection object, for example \PDO.
+   * @param string $queryString
+   *   The SQL query string.
+   * @param array $driverOpts
+   *   (optional) Array of query options.
+   * @param bool $rowCountEnabled
+   *   (optional) Enables counting the rows affected. Defaults to FALSE.
+   */
+  public function __construct(
+    protected readonly Connection $connection,
+    protected readonly \mysqli $mysqliConnection,
+    protected string $queryString,
+    protected array $driverOpts = [],
+    protected readonly bool $rowCountEnabled = FALSE,
+  ) {
+    $this->setFetchMode(\PDO::FETCH_OBJ);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function execute($args = [], $options = []) {
+    // Prepare the lower-level statement if it's not been prepared already.
+    if (!isset($this->clientStatement)) {
+      // Replace named placeholders with positional ones if needed.
+      $this->paramsPositions = array_flip(array_keys($args));
+      $converter = new NamedPlaceholderConverter();
+      $converter->parse($this->queryString, $args);
+      [$this->queryString, $args] = [$converter->getConvertedSQL(), $converter->getConvertedParameters()];
+      $this->clientStatement = $this->mysqliConnection->prepare($this->queryString);
+    }
+    else {
+      // Transform the $args to positional.
+      $tmp = [];
+      foreach ($this->paramsPositions as $param => $pos) {
+        $tmp[$pos] = $args[$param];
+      }
+      $args = $tmp;
+    }
+
+    if (isset($options['fetch'])) {
+      if (is_string($options['fetch'])) {
+        $this->setFetchMode(\PDO::FETCH_CLASS, $options['fetch']);
+      }
+      else {
+        $this->setFetchMode($options['fetch']);
+      }
+    }
+
+    if ($this->connection->isEventEnabled(StatementExecutionStartEvent::class)) {
+      $startEvent = new StatementExecutionStartEvent(
+        spl_object_id($this),
+        $this->connection->getKey(),
+        $this->connection->getTarget(),
+        $this->getQueryString(),
+        $args,
+        $this->connection->findCallerFromDebugBacktrace()
+      );
+      $this->connection->dispatchEvent($startEvent);
+    }
+
+    // In mysqli, the results of the statement execution are returned in a
+    // different object than the statement itself.
+    $return = $this->clientStatement->execute($args);
+    $this->markResultsetIterable($return);
+    $result = $this->clientStatement->get_result();
+    $this->mysqliResult = $result !== FALSE ? $result : NULL;
+
+    if (isset($startEvent) && $this->connection->isEventEnabled(StatementExecutionEndEvent::class)) {
+      $this->connection->dispatchEvent(new StatementExecutionEndEvent(
+        $startEvent->statementObjectId,
+        $startEvent->key,
+        $startEvent->target,
+        $startEvent->queryString,
+        $startEvent->args,
+        $startEvent->caller,
+        $startEvent->time
+      ));
+    }
+
+    return $return;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getQueryString() {
+    return $this->queryString;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetch($mode = NULL, $cursor_orientation = NULL, $cursor_offset = NULL) {
+    if (is_string($mode)) {
+      $this->setFetchMode(\PDO::FETCH_CLASS, $mode);
+      $mode = \PDO::FETCH_CLASS;
+    }
+    else {
+      if (isset($mode) && !in_array($mode, $this->supportedFetchModes)) {
+        @trigger_error('Fetch mode ' . ($this->fetchModeLiterals[$mode] ?? $mode) . ' is deprecated in drupal:10.2.0 and is removed from drupal:11.0.0. Use supported modes only. See https://www.drupal.org/node/3377999', E_USER_DEPRECATED);
+      }
+      $mode = $mode ?: $this->defaultFetchStyle;
+    }
+
+    $mysqli_row = $this->mysqliResult->fetch_assoc();
+
+    if (!$mysqli_row) {
+      $this->markResultsetFetchingComplete();
+      return FALSE;
+    }
+
+    $columnNames = array_keys($mysqli_row);
+
+    // Stringify all non-NULL column values.
+    $row = [];
+    foreach ($mysqli_row as $column => $value) {
+      $row[$column] = $value === NULL ? NULL : (string) $value;
+    }
+
+    $returnValue = match($mode) {
+      \PDO::FETCH_ASSOC => $row,
+      // @phpstan-ignore-next-line
+      \PDO::FETCH_BOTH => $this->assocToBoth($row),
+      \PDO::FETCH_NUM => $this->assocToNum($row),
+      \PDO::FETCH_LAZY, \PDO::FETCH_OBJ => $this->assocToObj($row),
+      // @phpstan-ignore-next-line
+      \PDO::FETCH_CLASS | \PDO::FETCH_CLASSTYPE => $this->assocToClassType($row, $this->fetchOptions['constructor_args']),
+      \PDO::FETCH_CLASS => $this->assocToClass($row, $this->fetchOptions['class'], $this->fetchOptions['constructor_args']),
+      // @phpstan-ignore-next-line
+      \PDO::FETCH_INTO => $this->assocIntoObject($row, $this->fetchOptions['object']),
+      \PDO::FETCH_COLUMN => $this->assocToColumn($row, $columnNames, $this->fetchOptions['column']),
+      default => throw new DatabaseExceptionWrapper('Fetch mode ' . ($this->fetchModeLiterals[$mode] ?? $mode) . ' is not supported.'),
+    };
+
+    $this->setResultsetCurrentRow($returnValue);
+    return $returnValue;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchAll($mode = NULL, $column_index = NULL, $constructor_arguments = NULL) {
+    if (isset($mode) && !in_array($mode, $this->supportedFetchModes)) {
+      @trigger_error('Fetch mode ' . ($this->fetchModeLiterals[$mode] ?? $mode) . ' is deprecated in drupal:10.2.0 and is removed from drupal:11.0.0. Use supported modes only. See https://www.drupal.org/node/3377999', E_USER_DEPRECATED);
+    }
+    if (is_string($mode)) {
+      $this->setFetchMode(\PDO::FETCH_CLASS, $mode);
+      $mode = \PDO::FETCH_CLASS;
+    }
+    else {
+      $mode = $mode ?: $this->defaultFetchStyle;
+    }
+
+    $rows = [];
+    if (\PDO::FETCH_COLUMN == $mode) {
+      // When fetching a column's value across the entire dataset, fetch
+      // through it and pick the requested column value for each row.
+      if ($column_index === NULL) {
+        $column_index = 0;
+      }
+      while (($record = $this->fetch(\PDO::FETCH_ASSOC)) !== FALSE) {
+        $cols = array_keys($record);
+        $rows[] = $record[$cols[$column_index]];
+      }
+    }
+    else {
+      while (($row = $this->fetch($mode)) !== FALSE) {
+        $rows[] = $row;
+      }
+    }
+
+    return $rows;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchAllAssoc($key, $fetch = NULL) {
+    $return = [];
+    if (isset($fetch)) {
+      if (is_string($fetch)) {
+        $this->setFetchMode(\PDO::FETCH_CLASS, $fetch);
+      }
+      else {
+        $this->setFetchMode($fetch ?: $this->defaultFetchStyle);
+      }
+    }
+
+    while ($record = $this->fetch()) {
+      $record_key = is_object($record) ? $record->$key : $record[$key];
+      $return[$record_key] = $record;
+    }
+
+    return $return;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchAllKeyed($key_index = 0, $value_index = 1) {
+    $return = [];
+    $this->setFetchMode(\PDO::FETCH_ASSOC);
+    while ($record = $this->fetch(\PDO::FETCH_ASSOC)) {
+      $cols = array_keys($record);
+      $return[$record[$cols[$key_index]]] = $record[$cols[$value_index]];
+    }
+    return $return;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchField($index = 0) {
+    if (($ret = $this->fetch(\PDO::FETCH_NUM)) === FALSE) {
+      return FALSE;
+    }
+    return $ret[$index] === NULL ? NULL : (string) $ret[$index];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchObject(string $class_name = NULL, array $constructor_arguments = []) {
+    if (isset($class_name)) {
+      $this->defaultFetchStyle = \PDO::FETCH_CLASS;
+      $this->fetchOptions = [
+        'class' => $class_name,
+        'constructor_args' => $constructor_arguments,
+      ];
+    }
+    return $this->fetch($class_name ?? \PDO::FETCH_OBJ);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function rowCount() {
+    // SELECT query should not use this method.
+    if ($this->rowCountEnabled) {
+      // @todo The most accurate value to return for Drupal here is the first
+      //   occurrence of an integer in the string stored by the connection's
+      //   $info property.
+      //   This is something like 'Rows matched: 1  Changed: 1  Warnings: 0' for
+      //   UPDATE or DELETE operations, and
+      //   'Records: 2  Duplicates: 1  Warnings: 0' for INSERT ones.
+      //   This however requires a regex parsing of the string which is
+      //   expensive; $affected_rows would be less accurate but much faster. We
+      //   would need Drupal to be less strict in testing, and never rely on
+      //   this value in runtime (which would be healthy anyway).
+      if ($this->mysqliConnection->info !== NULL) {
+        $matches = [];
+        if (preg_match('/\s(\d+)\s/', $this->mysqliConnection->info, $matches) === 1) {
+          return (int) $matches[0];
+        }
+        else {
+          throw new DatabaseExceptionWrapper('Invalid data in the $info property of the mysqli connection - ' . $this->mysqliConnection->info);
+        }
+      }
+      elseif ($this->mysqliConnection->affected_rows !== NULL) {
+        return $this->mysqliConnection->affected_rows;
+      }
+      throw new DatabaseExceptionWrapper('Unable to retrieve affected rows data');
+    }
+    else {
+      throw new RowCountException();
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setFetchMode($mode, $a1 = NULL, $a2 = []) {
+    if (!in_array($mode, $this->supportedFetchModes)) {
+      @trigger_error('Fetch mode ' . ($this->fetchModeLiterals[$mode] ?? $mode) . ' is deprecated in drupal:10.2.0 and is removed from drupal:11.0.0. Use supported modes only. See https://www.drupal.org/node/3377999', E_USER_DEPRECATED);
+    }
+    $this->defaultFetchStyle = $mode;
+    switch ($mode) {
+      case \PDO::FETCH_CLASS:
+        $this->fetchOptions['class'] = $a1;
+        if ($a2) {
+          $this->fetchOptions['constructor_args'] = $a2;
+        }
+        break;
+
+      case \PDO::FETCH_COLUMN:
+        $this->fetchOptions['column'] = $a1;
+        break;
+
+      case \PDO::FETCH_INTO:
+        $this->fetchOptions['object'] = $a1;
+        break;
+    }
+    return TRUE;
+  }
+
+}
diff --git a/core/modules/mysqli/src/Driver/Database/mysqli/TransactionManager.php b/core/modules/mysqli/src/Driver/Database/mysqli/TransactionManager.php
new file mode 100644
index 0000000000..51395dac57
--- /dev/null
+++ b/core/modules/mysqli/src/Driver/Database/mysqli/TransactionManager.php
@@ -0,0 +1,85 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\mysqli\Driver\Database\mysqli;
+
+use Drupal\Core\Database\Transaction\ClientConnectionTransactionState;
+use Drupal\Core\Database\Transaction\TransactionManagerBase;
+
+/**
+ * MySqli implementation of TransactionManagerInterface.
+ */
+class TransactionManager extends TransactionManagerBase {
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function beginClientTransaction(): bool {
+    return $this->connection->getClientConnection()->begin_transaction();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function addClientSavepoint(string $name): bool {
+    return $this->connection->getClientConnection()->savepoint($name);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function rollbackClientSavepoint(string $name): bool {
+    // Mysqli does not have a rollback_to_savepoint method, and it does not
+    // allow a prepared statement for 'ROLLBACK TO SAVEPOINT', so we need to
+    // fallback to query on the client connection directly.
+    try {
+      return (bool) $this->connection->getClientConnection()->query('ROLLBACK TO SAVEPOINT ' . $name);
+    }
+    catch (\mysqli_sql_exception $e) {
+      // If the rollback failed, most likely the savepoint was not there
+      // because the transaction is no longer active. In this case we void the
+      // transaction stack.
+      $this->voidClientTransaction();
+      return TRUE;
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function releaseClientSavepoint(string $name): bool {
+    return $this->connection->getClientConnection()->release_savepoint($name);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function rollbackClientTransaction(): bool {
+    // Note: mysqli::rollback() returns TRUE if there's no active transaction.
+    // This is diverging from PDO MySql.
+    // TransactionTest::testTransactionWithDdlStatement() fails for this reason.
+    // A PHP bug report exists.
+    //
+    // @see https://bugs.php.net/bug.php?id=81533.
+    $clientRollback = $this->connection->getClientConnection()->rollBack();
+    $this->setConnectionTransactionState($clientRollback ?
+      ClientConnectionTransactionState::RolledBack :
+      ClientConnectionTransactionState::RollbackFailed
+    );
+    return $clientRollback;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function commitClientTransaction(): bool {
+    $clientCommit = $this->connection->getClientConnection()->commit();
+    $this->setConnectionTransactionState($clientCommit ?
+      ClientConnectionTransactionState::Committed :
+      ClientConnectionTransactionState::CommitFailed
+    );
+    return $clientCommit;
+  }
+
+}
diff --git a/core/modules/mysqli/src/Plugin/views/query/MysqliCastSql.php b/core/modules/mysqli/src/Plugin/views/query/MysqliCastSql.php
new file mode 100644
index 0000000000..d1f1ca55f8
--- /dev/null
+++ b/core/modules/mysqli/src/Plugin/views/query/MysqliCastSql.php
@@ -0,0 +1,11 @@
+<?php
+
+namespace Drupal\mysqli\Plugin\views\query;
+
+use Drupal\mysql\Plugin\views\query\MysqlCastSql;
+
+/**
+ * MySQLi specific cast handling.
+ */
+class MysqliCastSql extends MysqlCastSql {
+}
diff --git a/core/modules/mysqli/tests/src/Functional/GenericTest.php b/core/modules/mysqli/tests/src/Functional/GenericTest.php
new file mode 100644
index 0000000000..8685fab5ba
--- /dev/null
+++ b/core/modules/mysqli/tests/src/Functional/GenericTest.php
@@ -0,0 +1,26 @@
+<?php
+
+namespace Drupal\Tests\mysqli\Functional;
+
+use Drupal\Core\Extension\ExtensionLifecycle;
+use Drupal\Tests\system\Functional\Module\GenericModuleTestBase;
+
+/**
+ * Generic module test for mysqli.
+ *
+ * @group mysqli
+ */
+class GenericTest extends GenericModuleTestBase {
+
+  /**
+   * Checks visibility of the module.
+   */
+  public function testMysqliModule(): void {
+    $module = $this->getModule();
+    \Drupal::service('module_installer')->install([$module]);
+    $info = \Drupal::service('extension.list.module')->getExtensionInfo($module);
+    $this->assertTrue($info['hidden']);
+    $this->assertSame(ExtensionLifecycle::EXPERIMENTAL, $info['lifecycle']);
+  }
+
+}
diff --git a/core/modules/mysqli/tests/src/Kernel/mysqli/ConnectionTest.php b/core/modules/mysqli/tests/src/Kernel/mysqli/ConnectionTest.php
new file mode 100644
index 0000000000..f0d1821d2c
--- /dev/null
+++ b/core/modules/mysqli/tests/src/Kernel/mysqli/ConnectionTest.php
@@ -0,0 +1,13 @@
+<?php
+
+namespace Drupal\Tests\mysqli\Kernel\mysqli;
+
+use Drupal\Tests\mysql\Kernel\mysql\ConnectionTest as BaseMySqlTest;
+
+/**
+ * MySQL-specific connection tests.
+ *
+ * @group Database
+ */
+class ConnectionTest extends BaseMySqlTest {
+}
diff --git a/core/modules/mysqli/tests/src/Kernel/mysqli/ConnectionUnitTest.php b/core/modules/mysqli/tests/src/Kernel/mysqli/ConnectionUnitTest.php
new file mode 100644
index 0000000000..0cb054ba15
--- /dev/null
+++ b/core/modules/mysqli/tests/src/Kernel/mysqli/ConnectionUnitTest.php
@@ -0,0 +1,21 @@
+<?php
+
+namespace Drupal\Tests\mysqli\Kernel\mysqli;
+
+use Drupal\Tests\mysql\Kernel\mysql\ConnectionUnitTest as BaseMySqlTest;
+
+/**
+ * MySQL-specific connection unit tests.
+ *
+ * @group Database
+ */
+class ConnectionUnitTest extends BaseMySqlTest {
+
+  /**
+   * Tests pdo options override.
+   */
+  public function testConnectionOpen() {
+    $this->markTestSkipped('mysqli is not a pdo driver.');
+  }
+
+}
diff --git a/core/modules/mysqli/tests/src/Kernel/mysqli/DatabaseExceptionWrapperTest.php b/core/modules/mysqli/tests/src/Kernel/mysqli/DatabaseExceptionWrapperTest.php
new file mode 100644
index 0000000000..b5ea6be348
--- /dev/null
+++ b/core/modules/mysqli/tests/src/Kernel/mysqli/DatabaseExceptionWrapperTest.php
@@ -0,0 +1,36 @@
+<?php
+
+namespace Drupal\Tests\mysqli\Kernel\mysqli;
+
+use Drupal\Tests\mysql\Kernel\mysql\DatabaseExceptionWrapperTest as BaseMySqlTest;
+
+/**
+ * Tests exceptions thrown by queries.
+ *
+ * @group Database
+ */
+class DatabaseExceptionWrapperTest extends BaseMySqlTest {
+
+  /**
+   * Tests Connection::prepareStatement exceptions on preparation.
+   *
+   * Core database drivers use PDO emulated statements or the StatementPrefetch
+   * class, which defer the statement check to the moment of the execution. In
+   * order to test a failure at preparation time, we have to force the
+   * connection not to emulate statement preparation. Still, this is only valid
+   * for the MySql driver.
+   */
+  public function testPrepareStatementFailOnPreparation() {
+    $this->markTestSkipped('mysqli is not a pdo driver.');
+  }
+
+  /**
+   * Tests Connection::prepareStatement exception on execution.
+   */
+  public function testPrepareStatementFailOnExecution() {
+    $this->expectException(\mysqli_sql_exception::class);
+    $stmt = $this->connection->prepareStatement('bananas', []);
+    $stmt->execute();
+  }
+
+}
diff --git a/core/modules/mysqli/tests/src/Kernel/mysqli/LargeQueryTest.php b/core/modules/mysqli/tests/src/Kernel/mysqli/LargeQueryTest.php
new file mode 100644
index 0000000000..8f30105ba5
--- /dev/null
+++ b/core/modules/mysqli/tests/src/Kernel/mysqli/LargeQueryTest.php
@@ -0,0 +1,50 @@
+<?php
+
+namespace Drupal\Tests\mysqli\Kernel\mysqli;
+
+use Drupal\Component\Utility\Environment;
+use Drupal\Core\Database\Database;
+use Drupal\Core\Database\DatabaseExceptionWrapper;
+use Drupal\Tests\mysql\Kernel\mysql\LargeQueryTest as BaseMySqlTest;
+
+/**
+ * Tests handling of large queries.
+ *
+ * @group Database
+ */
+class LargeQueryTest extends BaseMySqlTest {
+
+  /**
+   * Tests truncation of messages when max_allowed_packet exception occurs.
+   */
+  public function testMaxAllowedPacketQueryTruncating(): void {
+    $connectionInfo = Database::getConnectionInfo('default');
+    Database::addConnectionInfo('default', 'testMaxAllowedPacketQueryTruncating', $connectionInfo['default']);
+    $testConnection = Database::getConnection('testMaxAllowedPacketQueryTruncating');
+
+    // The max_allowed_packet value is configured per database instance.
+    // Retrieve the max_allowed_packet value from the current instance and
+    // check if PHP is configured with sufficient allowed memory to be able
+    // to generate a query larger than max_allowed_packet.
+    $max_allowed_packet = $testConnection->query('SELECT @@global.max_allowed_packet')->fetchField();
+    if (!Environment::checkMemoryLimit($max_allowed_packet + (16 * 1024 * 1024))) {
+      $this->markTestSkipped('The configured max_allowed_packet exceeds the php memory limit. Therefore the test is skipped.');
+    }
+
+    $long_name = str_repeat('a', $max_allowed_packet + 1);
+    try {
+      $testConnection->query('SELECT [name] FROM {test} WHERE [name] = :name', [':name' => $long_name]);
+      $this->fail("An exception should be thrown for queries larger than 'max_allowed_packet'");
+    }
+    catch (\Throwable $e) {
+      Database::closeConnection('testMaxAllowedPacketQueryTruncating');
+      // Got a packet bigger than 'max_allowed_packet' bytes exception thrown.
+      $this->assertInstanceOf(DatabaseExceptionWrapper::class, $e);
+      $this->assertEquals(1153, $e->getCode());
+      // 'max_allowed_packet' exception message truncated.
+      // Use strlen() to count the bytes exactly, not the unicode chars.
+      $this->assertLessThanOrEqual($max_allowed_packet, strlen($e->getMessage()));
+    }
+  }
+
+}
diff --git a/core/modules/mysqli/tests/src/Kernel/mysqli/NextIdTest.php b/core/modules/mysqli/tests/src/Kernel/mysqli/NextIdTest.php
new file mode 100644
index 0000000000..1ce4674700
--- /dev/null
+++ b/core/modules/mysqli/tests/src/Kernel/mysqli/NextIdTest.php
@@ -0,0 +1,14 @@
+<?php
+
+namespace Drupal\Tests\mysqli\Kernel\mysqli;
+
+use Drupal\Tests\mysql\Kernel\mysql\NextIdTest as BaseMySqlTest;
+
+/**
+ * Tests the sequences API.
+ *
+ * @group Database
+ * @group legacy
+ */
+class NextIdTest extends BaseMySqlTest {
+}
diff --git a/core/modules/mysqli/tests/src/Kernel/mysqli/PrefixInfoTest.php b/core/modules/mysqli/tests/src/Kernel/mysqli/PrefixInfoTest.php
new file mode 100644
index 0000000000..ff056f25ad
--- /dev/null
+++ b/core/modules/mysqli/tests/src/Kernel/mysqli/PrefixInfoTest.php
@@ -0,0 +1,13 @@
+<?php
+
+namespace Drupal\Tests\mysqli\Kernel\mysqli;
+
+use Drupal\Tests\mysql\Kernel\mysql\PrefixInfoTest as BaseMySqlTest;
+
+/**
+ * Tests that the prefix info for a database schema is correct.
+ *
+ * @group Database
+ */
+class PrefixInfoTest extends BaseMySqlTest {
+}
diff --git a/core/modules/mysqli/tests/src/Kernel/mysqli/SchemaTest.php b/core/modules/mysqli/tests/src/Kernel/mysqli/SchemaTest.php
new file mode 100644
index 0000000000..8f6f3839dc
--- /dev/null
+++ b/core/modules/mysqli/tests/src/Kernel/mysqli/SchemaTest.php
@@ -0,0 +1,13 @@
+<?php
+
+namespace Drupal\Tests\mysqli\Kernel\mysqli;
+
+use Drupal\Tests\mysql\Kernel\mysql\SchemaTest as BaseMySqlTest;
+
+/**
+ * Tests schema API for the MySQL driver.
+ *
+ * @group Database
+ */
+class SchemaTest extends BaseMySqlTest {
+}
diff --git a/core/modules/mysqli/tests/src/Kernel/mysqli/SqlModeTest.php b/core/modules/mysqli/tests/src/Kernel/mysqli/SqlModeTest.php
new file mode 100644
index 0000000000..aa5866733d
--- /dev/null
+++ b/core/modules/mysqli/tests/src/Kernel/mysqli/SqlModeTest.php
@@ -0,0 +1,41 @@
+<?php
+
+namespace Drupal\Tests\mysqli\Kernel\mysqli;
+
+use Drupal\KernelTests\Core\Database\DriverSpecificDatabaseTestBase;
+
+/**
+ * Tests compatibility of the MySQL driver with various sql_mode options.
+ *
+ * @group Database
+ */
+class SqlModeTest extends DriverSpecificDatabaseTestBase {
+
+  /**
+   * Tests quoting identifiers in queries.
+   */
+  public function testQuotingIdentifiers(): void {
+    // Use SQL-reserved words for both the table and column names.
+    $query = $this->connection->query('SELECT [update] FROM {select}');
+    $this->assertEquals('Update value 1', $query->fetchObject()->update);
+    $this->assertStringContainsString('SELECT `update` FROM `', $query->getQueryString());
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function getDatabaseConnectionInfo() {
+    $info = parent::getDatabaseConnectionInfo();
+
+    // This runs during setUp(), so is not yet skipped for non MySQL databases.
+    // We defer skipping the test to later in setUp(), so that that can be
+    // based on databaseType() rather than 'driver', but here all we have to go
+    // on is 'driver'.
+    if ($info['default']['driver'] === 'mysqli') {
+      $info['default']['init_commands']['sql_mode'] = "SET sql_mode = ''";
+    }
+
+    return $info;
+  }
+
+}
diff --git a/core/modules/mysqli/tests/src/Kernel/mysqli/SyntaxTest.php b/core/modules/mysqli/tests/src/Kernel/mysqli/SyntaxTest.php
new file mode 100644
index 0000000000..6b938b06c9
--- /dev/null
+++ b/core/modules/mysqli/tests/src/Kernel/mysqli/SyntaxTest.php
@@ -0,0 +1,26 @@
+<?php
+
+namespace Drupal\Tests\mysqli\Kernel\mysqli;
+
+use Drupal\KernelTests\Core\Database\DriverSpecificSyntaxTestBase;
+
+/**
+ * Tests MySql syntax interpretation.
+ *
+ * @group Database
+ */
+class SyntaxTest extends DriverSpecificSyntaxTestBase {
+
+  /**
+   * Tests string concatenation with separator, with field values.
+   */
+  public function testConcatWsFields() {
+    $result = $this->connection->query("SELECT CONCAT_WS('-', CONVERT(:a1 USING utf8mb4), [name], CONVERT(:a2 USING utf8mb4), [age]) FROM {test} WHERE [age] = :age", [
+      ':a1' => 'name',
+      ':a2' => 'age',
+      ':age' => 25,
+    ]);
+    $this->assertSame('name-John-age-25', $result->fetchField());
+  }
+
+}
diff --git a/core/modules/mysqli/tests/src/Kernel/mysqli/TemporaryQueryTest.php b/core/modules/mysqli/tests/src/Kernel/mysqli/TemporaryQueryTest.php
new file mode 100644
index 0000000000..807c55ae1c
--- /dev/null
+++ b/core/modules/mysqli/tests/src/Kernel/mysqli/TemporaryQueryTest.php
@@ -0,0 +1,13 @@
+<?php
+
+namespace Drupal\Tests\mysqli\Kernel\mysqli;
+
+use Drupal\Tests\mysql\Kernel\mysql\TemporaryQueryTest as BaseMySqlTest;
+
+/**
+ * Tests the temporary query functionality.
+ *
+ * @group Database
+ */
+class TemporaryQueryTest extends BaseMySqlTest {
+}
diff --git a/core/modules/mysqli/tests/src/Kernel/mysqli/TransactionTest.php b/core/modules/mysqli/tests/src/Kernel/mysqli/TransactionTest.php
new file mode 100644
index 0000000000..b812724eb9
--- /dev/null
+++ b/core/modules/mysqli/tests/src/Kernel/mysqli/TransactionTest.php
@@ -0,0 +1,150 @@
+<?php
+
+namespace Drupal\Tests\mysqli\Kernel\mysqli;
+
+use Drupal\KernelTests\Core\Database\DriverSpecificTransactionTestBase;
+use PHPUnit\Framework\Error\Warning;
+
+/**
+ * Tests transaction for the MySQL driver.
+ *
+ * @group Database
+ */
+class TransactionTest extends DriverSpecificTransactionTestBase {
+
+  /**
+   * Tests the compatibility of transactions with DDL statements.
+   */
+  public function testTransactionWithDdlStatement() {
+    // First, test that a commit works normally, even with DDL statements.
+    $transaction = $this->connection->startTransaction();
+    $this->insertRow('row');
+    $this->executeDDLStatement();
+    unset($transaction);
+    $this->assertRowPresent('row');
+
+    // Even in different order.
+    $this->cleanUp();
+    $transaction = $this->connection->startTransaction();
+    $this->executeDDLStatement();
+    $this->insertRow('row');
+    unset($transaction);
+    $this->assertRowPresent('row');
+
+    // Even with stacking.
+    $this->cleanUp();
+    $transaction = $this->connection->startTransaction();
+    $transaction2 = $this->connection->startTransaction();
+    $this->executeDDLStatement();
+    unset($transaction2);
+    $transaction3 = $this->connection->startTransaction();
+    $this->insertRow('row');
+    unset($transaction3);
+    unset($transaction);
+    $this->assertRowPresent('row');
+
+    // Note: THIS IS DIFFERENT FROM MySQL.
+    // MySQLi will only cleanup the transaction stack on rollback, because the
+    // rollback will fail since no savepoint is any longer present given the
+    // auto-commit related to the DDL statement.
+    // So a transaction after a DDL statement should still work the same.
+    $this->cleanUp();
+    $transaction = $this->connection->startTransaction();
+    $transaction2 = $this->connection->startTransaction();
+    $this->executeDDLStatement();
+    unset($transaction2);
+    $transaction3 = $this->connection->startTransaction();
+    $this->insertRow('row');
+    // $transaction3->rollBack();
+    unset($transaction3);
+    unset($transaction);
+    // $this->assertRowAbsent('row');
+
+    // The behavior of a rollback depends on the type of database server.
+    if ($this->connection->supportsTransactionalDDL()) {
+      // For database servers that support transactional DDL, a rollback
+      // of a transaction including DDL statements should be possible.
+      $this->cleanUp();
+      $transaction = $this->connection->startTransaction();
+      $this->insertRow('row');
+      $this->executeDDLStatement();
+      $transaction->rollBack();
+      unset($transaction);
+      $this->assertRowAbsent('row');
+
+      // Including with stacking.
+      $this->cleanUp();
+      $transaction = $this->connection->startTransaction();
+      $transaction2 = $this->connection->startTransaction();
+      $this->executeDDLStatement();
+      unset($transaction2);
+      $transaction3 = $this->connection->startTransaction();
+      $this->insertRow('row');
+      unset($transaction3);
+      $transaction->rollBack();
+      unset($transaction);
+      $this->assertRowAbsent('row');
+    }
+    else {
+      // For database servers that do not support transactional DDL,
+      // the DDL statement should commit the transaction stack.
+      $this->cleanUp();
+      $transaction = $this->connection->startTransaction();
+      $this->insertRow('row');
+      $this->executeDDLStatement();
+
+      try {
+        // Rollback the outer transaction.
+        $transaction->rollBack();
+        // Note: THIS IS DIFFERENT FROM MySQL.
+        // MySQLi does not fail when rolling back and no transaction active.
+        // $this->fail('Rolling back a transaction containing DDL should produce a warning.');
+      }
+      catch (Warning $warning) {
+        $this->assertSame('Rollback attempted when there is no active transaction. This can cause data integrity issues.', $warning->getMessage());
+      }
+      unset($transaction);
+      $this->assertRowPresent('row');
+    }
+  }
+
+  /**
+   * Tests deprecation of Connection methods.
+   *
+   * @group legacy
+   */
+  public function testConnectionDeprecations(): void {
+    $this->markTestSkipped('Skipping this test for MySQLi.');
+  }
+
+  /**
+   * Tests starting a transaction when there's one active on the client.
+   *
+   * MySQLi does not fail if multiple transactions are begun on the client, so
+   * this test is failing. Let's change this when MySQLi will provide a way to
+   * check if a client transaction is active.
+   */
+  public function testStartTransactionWhenActive(): void {
+    $this->markTestSkipped('Skipping this while MySQLi cannot detect if a client transaction is active.');
+    $this->connection->getClientConnection()->begin_transaction();
+    $this->connection->startTransaction();
+    $this->assertFalse($this->connection->inTransaction());
+  }
+
+  /**
+   * Tests committing a transaction when there's none active on the client.
+   *
+   * MySQLi does not fail if multiple commits are made on the client, so this
+   * test is failing. Let's change this when MySQLi will provide a way to check
+   * if a client transaction is active.
+   */
+  public function testCommitTransactionWhenInactive(): void {
+    $this->markTestSkipped('Skipping this while MySQLi cannot detect if a client transaction is active.');
+    $transaction = $this->connection->startTransaction();
+    $this->assertTrue($this->connection->inTransaction());
+    $this->connection->getClientConnection()->commit();
+    $this->assertFalse($this->connection->inTransaction());
+    $transaction = NULL;
+  }
+
+}
diff --git a/core/modules/mysqli/tests/src/Unit/NamedPlaceholderConverterTest.php b/core/modules/mysqli/tests/src/Unit/NamedPlaceholderConverterTest.php
new file mode 100644
index 0000000000..3a4e1408b9
--- /dev/null
+++ b/core/modules/mysqli/tests/src/Unit/NamedPlaceholderConverterTest.php
@@ -0,0 +1,376 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Tests\mysqli\Unit;
+
+use Drupal\mysqli\Driver\Database\mysqli\NamedPlaceholderConverter;
+use Drupal\Tests\UnitTestCase;
+
+/**
+ * @coversDefaultClass \Drupal\mysqli\Driver\Database\mysqli\NamedPlaceholderConverter
+ * @group Database
+ */
+class NamedPlaceholderConverterTest extends UnitTestCase {
+
+  /**
+   * @covers ::parse
+   * @covers ::getConvertedSQL
+   * @covers ::getConvertedParameters
+   * @dataProvider statementsWithParametersProvider
+   */
+  public function testParse(string $sql, array $parameters, string $expectedSql, array $expectedParameters): void {
+    $converter = new NamedPlaceholderConverter();
+    $converter->parse($sql, $parameters);
+    $this->assertSame($expectedSql, $converter->getConvertedSQL());
+    $this->assertSame($expectedParameters, $converter->getConvertedParameters());
+  }
+
+  /**
+   * Data for testParse.
+   */
+  public static function statementsWithParametersProvider(): iterable {
+    yield [
+      'SELECT ?',
+      ['foo'],
+      'SELECT ?',
+      ['foo'],
+    ];
+
+    yield [
+      'SELECT * FROM Foo WHERE bar IN (?, ?, ?)',
+      ['baz', 'qux', 'fred'],
+      'SELECT * FROM Foo WHERE bar IN (?, ?, ?)',
+      ['baz', 'qux', 'fred'],
+    ];
+
+    yield [
+      'SELECT ? FROM ?',
+      ['baz', 'qux'],
+      'SELECT ? FROM ?',
+      ['baz', 'qux'],
+    ];
+
+    yield [
+      'SELECT "?" FROM foo WHERE bar = ?',
+      ['baz'],
+      'SELECT "?" FROM foo WHERE bar = ?',
+      ['baz'],
+    ];
+
+    yield [
+      "SELECT '?' FROM foo WHERE bar = ?",
+      ['baz'],
+      "SELECT '?' FROM foo WHERE bar = ?",
+      ['baz'],
+    ];
+
+    yield [
+      'SELECT `?` FROM foo WHERE bar = ?',
+      ['baz'],
+      'SELECT `?` FROM foo WHERE bar = ?',
+      ['baz'],
+    ];
+
+    yield [
+      'SELECT [?] FROM foo WHERE bar = ?',
+      ['baz'],
+      'SELECT [?] FROM foo WHERE bar = ?',
+      ['baz'],
+    ];
+
+    yield [
+      'SELECT * FROM foo WHERE jsonb_exists_any(foo.bar, ARRAY[?])',
+      ['baz'],
+      'SELECT * FROM foo WHERE jsonb_exists_any(foo.bar, ARRAY[?])',
+      ['baz'],
+    ];
+
+    yield [
+      "SELECT 'foo-bar?' FROM foo WHERE bar = ?",
+      ['baz'],
+      "SELECT 'foo-bar?' FROM foo WHERE bar = ?",
+      ['baz'],
+    ];
+
+    yield [
+      'SELECT "foo-bar?" FROM foo WHERE bar = ?',
+      ['baz'],
+      'SELECT "foo-bar?" FROM foo WHERE bar = ?',
+      ['baz'],
+    ];
+
+    yield [
+      'SELECT `foo-bar?` FROM foo WHERE bar = ?',
+      ['baz'],
+      'SELECT `foo-bar?` FROM foo WHERE bar = ?',
+      ['baz'],
+    ];
+
+    yield [
+      'SELECT [foo-bar?] FROM foo WHERE bar = ?',
+      ['baz'],
+      'SELECT [foo-bar?] FROM foo WHERE bar = ?',
+      ['baz'],
+    ];
+
+    yield [
+      'SELECT :foo FROM :bar',
+      [':foo' => 'baz', ':bar' => 'qux'],
+      'SELECT ? FROM ?',
+      ['baz', 'qux'],
+    ];
+
+    yield [
+      'SELECT * FROM Foo WHERE bar IN (:name1, :name2)',
+      [':name1' => 'baz', ':name2' => 'qux'],
+      'SELECT * FROM Foo WHERE bar IN (?, ?)',
+      ['baz', 'qux'],
+    ];
+
+    yield [
+      'SELECT ":foo" FROM Foo WHERE bar IN (:name1, :name2)',
+      [':name1' => 'baz', ':name2' => 'qux'],
+      'SELECT ":foo" FROM Foo WHERE bar IN (?, ?)',
+      ['baz', 'qux'],
+    ];
+
+    yield [
+      "SELECT ':foo' FROM Foo WHERE bar IN (:name1, :name2)",
+      [':name1' => 'baz', ':name2' => 'qux'],
+      "SELECT ':foo' FROM Foo WHERE bar IN (?, ?)",
+      ['baz', 'qux'],
+    ];
+
+    yield [
+      'SELECT :foo_id',
+      [':foo_id' => 'bar'],
+      'SELECT ?',
+      ['bar'],
+    ];
+
+    yield [
+      'SELECT @rank := 1 AS rank, :foo AS foo FROM :bar',
+      [':foo' => 'baz', ':bar' => 'qux'],
+      'SELECT @rank := 1 AS rank, ? AS foo FROM ?',
+      ['baz', 'qux'],
+    ];
+
+    yield [
+      'SELECT * FROM Foo WHERE bar > :start_date AND baz > :start_date',
+      [':start_date' => 'qux'],
+      'SELECT * FROM Foo WHERE bar > ? AND baz > ?',
+      ['qux', 'qux'],
+    ];
+
+    yield [
+      'SELECT foo::date as date FROM Foo WHERE bar > :start_date AND baz > :start_date',
+      [':start_date' => 'qux'],
+      'SELECT foo::date as date FROM Foo WHERE bar > ? AND baz > ?',
+      ['qux', 'qux'],
+    ];
+
+    yield [
+      'SELECT `d.ns:col_name` FROM my_table d WHERE `d.date` >= :param1',
+      [':param1' => 'qux'],
+      'SELECT `d.ns:col_name` FROM my_table d WHERE `d.date` >= ?',
+      ['qux'],
+    ];
+
+    yield [
+      'SELECT [d.ns:col_name] FROM my_table d WHERE [d.date] >= :param1',
+      [':param1' => 'qux'],
+      'SELECT [d.ns:col_name] FROM my_table d WHERE [d.date] >= ?',
+      ['qux'],
+    ];
+
+    yield [
+      'SELECT * FROM foo WHERE jsonb_exists_any(foo.bar, ARRAY[:foo])',
+      [':foo' => 'qux'],
+      'SELECT * FROM foo WHERE jsonb_exists_any(foo.bar, ARRAY[?])',
+      ['qux'],
+    ];
+
+    yield [
+      'SELECT * FROM foo WHERE jsonb_exists_any(foo.bar, array[:foo])',
+      [':foo' => 'qux'],
+      'SELECT * FROM foo WHERE jsonb_exists_any(foo.bar, array[?])',
+      ['qux'],
+    ];
+
+    yield [
+      "SELECT table.column1, ARRAY['3'] FROM schema.table table WHERE table.f1 = :foo AND ARRAY['3']",
+      [':foo' => 'qux'],
+      "SELECT table.column1, ARRAY['3'] FROM schema.table table WHERE table.f1 = ? AND ARRAY['3']",
+      ['qux'],
+    ];
+
+    yield [
+      "SELECT table.column1, ARRAY['3']::integer[] FROM schema.table table" . " WHERE table.f1 = :foo AND ARRAY['3']::integer[]",
+      [':foo' => 'qux'],
+      "SELECT table.column1, ARRAY['3']::integer[] FROM schema.table table" . " WHERE table.f1 = ? AND ARRAY['3']::integer[]",
+      ['qux'],
+    ];
+
+    yield [
+      "SELECT table.column1, ARRAY[:foo] FROM schema.table table WHERE table.f1 = :bar AND ARRAY['3']",
+      [':foo' => 'qux', ':bar' => 'git'],
+      "SELECT table.column1, ARRAY[?] FROM schema.table table WHERE table.f1 = ? AND ARRAY['3']",
+      ['qux', 'git'],
+    ];
+
+    yield [
+      'SELECT table.column1, ARRAY[:foo]::integer[] FROM schema.table table' . " WHERE table.f1 = :bar AND ARRAY['3']::integer[]",
+      [':foo' => 'qux', ':bar' => 'git'],
+      'SELECT table.column1, ARRAY[?]::integer[] FROM schema.table table' . " WHERE table.f1 = ? AND ARRAY['3']::integer[]",
+      ['qux', 'git'],
+    ];
+
+    yield 'Parameter array with placeholder keys missing starting colon' => [
+      'SELECT table.column1, ARRAY[:foo]::integer[] FROM schema.table table' . " WHERE table.f1 = :bar AND ARRAY['3']::integer[]",
+      ['foo' => 'qux', 'bar' => 'git'],
+      'SELECT table.column1, ARRAY[?]::integer[] FROM schema.table table' . " WHERE table.f1 = ? AND ARRAY['3']::integer[]",
+      ['qux', 'git'],
+    ];
+
+    yield 'Quotes inside literals escaped by doubling' => [
+      <<<'SQL'
+SELECT * FROM foo
+WHERE bar = ':not_a_param1 ''":not_a_param2"'''
+   OR bar=:a_param1
+   OR bar=:a_param2||':not_a_param3'
+   OR bar=':not_a_param4 '':not_a_param5'' :not_a_param6'
+   OR bar=''
+   OR bar=:a_param3
+SQL,
+      [':a_param1' => 'qux', ':a_param2' => 'git', ':a_param3' => 'foo'],
+    <<<'SQL'
+SELECT * FROM foo
+WHERE bar = ':not_a_param1 ''":not_a_param2"'''
+   OR bar=?
+   OR bar=?||':not_a_param3'
+   OR bar=':not_a_param4 '':not_a_param5'' :not_a_param6'
+   OR bar=''
+   OR bar=?
+SQL,
+      ['qux', 'git', 'foo'],
+    ];
+
+    yield [
+      'SELECT data.age AS age, data.id AS id, data.name AS name, data.id AS id FROM test_data data' . " WHERE (data.description LIKE :condition_0 ESCAPE '\\\\')" . " AND (data.description LIKE :condition_1 ESCAPE '\\\\') ORDER BY id ASC",
+      [':condition_0' => 'qux', ':condition_1' => 'git'],
+      'SELECT data.age AS age, data.id AS id, data.name AS name, data.id AS id FROM test_data data' . " WHERE (data.description LIKE ? ESCAPE '\\\\')" . " AND (data.description LIKE ? ESCAPE '\\\\') ORDER BY id ASC",
+      ['qux', 'git'],
+    ];
+
+    yield [
+      'SELECT data.age AS age, data.id AS id, data.name AS name, data.id AS id FROM test_data data' . ' WHERE (data.description LIKE :condition_0 ESCAPE "\\\\")' . ' AND (data.description LIKE :condition_1 ESCAPE "\\\\") ORDER BY id ASC',
+      [':condition_0' => 'qux', ':condition_1' => 'git'],
+      'SELECT data.age AS age, data.id AS id, data.name AS name, data.id AS id FROM test_data data' . ' WHERE (data.description LIKE ? ESCAPE "\\\\")' . ' AND (data.description LIKE ? ESCAPE "\\\\") ORDER BY id ASC',
+      ['qux', 'git'],
+    ];
+
+    yield 'Combined single and double quotes' => [
+      <<<'SQL'
+SELECT data.age AS age, data.id AS id, data.name AS name, data.id AS id
+  FROM test_data data
+ WHERE (data.description LIKE :condition_0 ESCAPE "\\")
+   AND (data.description LIKE :condition_1 ESCAPE '\\') ORDER BY id ASC
+SQL,
+      [':condition_0' => 'qux', ':condition_1' => 'git'],
+      <<<'SQL'
+SELECT data.age AS age, data.id AS id, data.name AS name, data.id AS id
+  FROM test_data data
+ WHERE (data.description LIKE ? ESCAPE "\\")
+   AND (data.description LIKE ? ESCAPE '\\') ORDER BY id ASC
+SQL,
+      ['qux', 'git'],
+    ];
+
+    yield [
+      'SELECT data.age AS age, data.id AS id, data.name AS name, data.id AS id FROM test_data data' . ' WHERE (data.description LIKE :condition_0 ESCAPE `\\\\`)' . ' AND (data.description LIKE :condition_1 ESCAPE `\\\\`) ORDER BY id ASC',
+      [':condition_0' => 'qux', ':condition_1' => 'git'],
+      'SELECT data.age AS age, data.id AS id, data.name AS name, data.id AS id FROM test_data data' . ' WHERE (data.description LIKE ? ESCAPE `\\\\`)' . ' AND (data.description LIKE ? ESCAPE `\\\\`) ORDER BY id ASC',
+      ['qux', 'git'],
+    ];
+
+    yield 'Combined single quotes and backticks' => [
+      <<<'SQL'
+SELECT data.age AS age, data.id AS id, data.name AS name, data.id AS id
+  FROM test_data data
+ WHERE (data.description LIKE :condition_0 ESCAPE '\\')
+   AND (data.description LIKE :condition_1 ESCAPE `\\`) ORDER BY id ASC
+SQL,
+      [':condition_0' => 'qux', ':condition_1' => 'git'],
+      <<<'SQL'
+SELECT data.age AS age, data.id AS id, data.name AS name, data.id AS id
+  FROM test_data data
+ WHERE (data.description LIKE ? ESCAPE '\\')
+   AND (data.description LIKE ? ESCAPE `\\`) ORDER BY id ASC
+SQL,
+      ['qux', 'git'],
+    ];
+
+    yield '? placeholders inside comments' => [
+      <<<'SQL'
+/*
+ * test placeholder ?
+ */
+SELECT dummy as "dummy?"
+  FROM DUAL
+ WHERE '?' = '?'
+-- AND dummy <> ?
+   AND dummy = ?
+SQL,
+      ['baz'],
+      <<<'SQL'
+/*
+ * test placeholder ?
+ */
+SELECT dummy as "dummy?"
+  FROM DUAL
+ WHERE '?' = '?'
+-- AND dummy <> ?
+   AND dummy = ?
+SQL,
+      ['baz'],
+    ];
+
+    yield 'Named placeholders inside comments' => [
+      <<<'SQL'
+/*
+ * test :placeholder
+ */
+SELECT dummy as "dummy?"
+  FROM DUAL
+ WHERE '?' = '?'
+-- AND dummy <> :dummy
+   AND dummy = :key
+SQL,
+      [':key' => 'baz'],
+      <<<'SQL'
+/*
+ * test :placeholder
+ */
+SELECT dummy as "dummy?"
+  FROM DUAL
+ WHERE '?' = '?'
+-- AND dummy <> :dummy
+   AND dummy = ?
+SQL,
+      ['baz'],
+    ];
+
+    yield 'Escaped question' => [
+      <<<'SQL'
+SELECT '{"a":null}'::jsonb ?? :key
+SQL,
+      [':key' => 'qux'],
+      <<<'SQL'
+SELECT '{"a":null}'::jsonb ?? ?
+SQL,
+      ['qux'],
+    ];
+  }
+
+}
