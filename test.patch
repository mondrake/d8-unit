diff --git a/core/includes/form.inc b/core/includes/form.inc
index 4f353d0088..ef89b55d2f 100644
--- a/core/includes/form.inc
+++ b/core/includes/form.inc
@@ -6,6 +6,7 @@
  */
 
 use Drupal\Component\Utility\UrlHelper;
+use Drupal\Core\Database\IntegrityConstraintViolationException;
 use Drupal\Core\Render\Element;
 use Drupal\Core\Render\Element\RenderElement;
 use Drupal\Core\Template\Attribute;
@@ -897,9 +898,26 @@ function batch_process($redirect = NULL, Url $url = NULL, $redirect_callback = N
     // environments.
     \Drupal::moduleHandler()->alter('batch', $batch);
 
-    // Assign an arbitrary id: don't rely on a serial column in the 'batch'
-    // table, since non-progressive batches skip database storage completely.
-    $batch['id'] = \Drupal::database()->nextId();
+    // Assign an id to progressive batches. Non-progressive batches skip
+    // database storage completely.
+    try {
+      $batch['id'] = $batch['progressive'] ? \Drupal::service('batch.storage')->getId() : 'non-progressive';
+    }
+    catch (IntegrityConstraintViolationException $e) {
+      // @todo this is here to support the update path to deprecate
+      // Connection::nextId(). Remove in Drupal 11.
+      $connection = \Drupal::database();
+      $max_bid = (int) $connection->query('SELECT MAX([bid]) FROM {batch}')->fetchField();
+      $batch['id'] = $max_bid + 1;
+      $connection->insert('batch')
+        ->fields([
+          'bid' => $batch['id'],
+          'timestamp' => \Drupal::time()->getRequestTime(),
+          'token' => '',
+          'batch' => NULL,
+        ])
+        ->execute();
+    }
 
     // Move operations to a job queue. Non-progressive batches will use a
     // memory-based queue.
diff --git a/core/lib/Drupal/Core/Batch/BatchStorage.php b/core/lib/Drupal/Core/Batch/BatchStorage.php
index 3c44628ef9..6d078b585a 100644
--- a/core/lib/Drupal/Core/Batch/BatchStorage.php
+++ b/core/lib/Drupal/Core/Batch/BatchStorage.php
@@ -121,12 +121,29 @@ public function cleanup() {
    * {@inheritdoc}
    */
   public function create(array $batch) {
-    // Ensure that a session is started before using the CSRF token generator.
+    // Ensure that a session is started before using the CSRF token generator,
+    // and update the database record.
     $this->session->start();
+    $this->connection->update('batch')
+      ->fields([
+        'token' => $this->csrfToken->get($batch['id']),
+        'batch' => serialize($batch),
+      ])
+      ->condition('bid', $batch['id'])
+      ->execute();
+  }
+
+  /**
+   * Returns a new batch id.
+   *
+   * @return int
+   *   A batch id.
+   */
+  public function getId(): int {
     $try_again = FALSE;
     try {
       // The batch table might not yet exist.
-      $this->doCreate($batch);
+      return $this->doInsertBatchRecord();
     }
     catch (\Exception $e) {
       // If there was an exception, try to create the table.
@@ -138,23 +155,22 @@ public function create(array $batch) {
     }
     // Now that the table has been created, try again if necessary.
     if ($try_again) {
-      $this->doCreate($batch);
+      return $this->doInsertBatchRecord();
     }
   }
 
   /**
-   * Saves a batch.
+   * Inserts a record in the table and returns the batch id.
    *
-   * @param array $batch
-   *   The array representing the batch to create.
+   * @return int
+   *   A batch id.
    */
-  protected function doCreate(array $batch) {
-    $this->connection->insert('batch')
+  protected function doInsertBatchRecord(): int {
+    return $this->connection->insert('batch')
       ->fields([
-        'bid' => $batch['id'],
-        'timestamp' => REQUEST_TIME,
-        'token' => $this->csrfToken->get($batch['id']),
-        'batch' => serialize($batch),
+        'timestamp' => \Drupal::time()->getRequestTime(),
+        'token' => '',
+        'batch' => NULL,
       ])
       ->execute();
   }
@@ -208,9 +224,7 @@ public function schemaDefinition() {
       'fields' => [
         'bid' => [
           'description' => 'Primary Key: Unique batch ID.',
-          // This is not a serial column, to allow both progressive and
-          // non-progressive batches. See batch_process().
-          'type' => 'int',
+          'type' => 'serial',
           'unsigned' => TRUE,
           'not null' => TRUE,
         ],
diff --git a/core/lib/Drupal/Core/ProxyClass/Batch/BatchStorage.php b/core/lib/Drupal/Core/ProxyClass/Batch/BatchStorage.php
index 5e6fc6df6d..4b54090cab 100644
--- a/core/lib/Drupal/Core/ProxyClass/Batch/BatchStorage.php
+++ b/core/lib/Drupal/Core/ProxyClass/Batch/BatchStorage.php
@@ -107,6 +107,14 @@ public function create(array $batch)
             return $this->lazyLoadItself()->create($batch);
         }
 
+        /**
+         * {@inheritdoc}
+         */
+        public function getId(): int
+        {
+            return $this->lazyLoadItself()->getId();
+        }
+
         /**
          * {@inheritdoc}
          */
diff --git a/core/modules/system/system.install b/core/modules/system/system.install
index a896ba9897..abef98d2a9 100644
--- a/core/modules/system/system.install
+++ b/core/modules/system/system.install
@@ -1757,3 +1757,22 @@ function system_update_10100(&$sandbox = NULL) {
   }
 
 }
+
+/**
+ * Change the {batch} table [bid] field to serial.
+ */
+function system_update_10101(&$sandbox = NULL) {
+  $connection = \Drupal::database();
+  $schema = $connection->schema();
+
+  // Update batch table.
+  if ($schema->tableExists('batch')) {
+    $schema->changeField('batch', 'bid', 'bid', [
+      'description' => 'Primary Key: Unique batch ID.',
+      'type' => 'serial',
+      'unsigned' => TRUE,
+      'not null' => TRUE,
+    ]);
+  }
+
+}
diff --git a/core/modules/system/tests/src/Functional/Update/BatchBidSerialUpdateTest.php b/core/modules/system/tests/src/Functional/Update/BatchBidSerialUpdateTest.php
new file mode 100644
index 0000000000..72d7fb98fd
--- /dev/null
+++ b/core/modules/system/tests/src/Functional/Update/BatchBidSerialUpdateTest.php
@@ -0,0 +1,81 @@
+<?php
+
+namespace Drupal\Tests\system\Functional\Update;
+
+use Drupal\Core\Database\IntegrityConstraintViolationException;
+use Drupal\FunctionalTests\Update\UpdatePathTestBase;
+
+/**
+ * Tests system_update_10101() upgrade path.
+ *
+ * @group system
+ * @group legacy
+ */
+class BatchBidSerialUpdateTest extends UpdatePathTestBase {
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function setDatabaseDumpFiles() {
+    $this->databaseDumpFiles = [
+      __DIR__ . '/../../../../../system/tests/fixtures/update/drupal-9.4.0.bare.standard.php.gz',
+    ];
+  }
+
+  /**
+   * Tests the change of the {batch} table [bid] field to serial.
+   */
+  public function testUpdate(): void {
+    /** @var \Drupal\Core\Database\Connection $connection */
+    $connection = \Drupal::service('database');
+
+    // Before the update, inserting a record in the {batch} table without
+    // passing a value for [bid] should fail, with the exception of the SQLite
+    // database where a NOT NULL integer field that is the primary key is set
+    // to automatic increment anyway.
+    //
+    // @see https://www.drupal.org/project/drupal/issues/2665216#comment-14885361
+    try {
+      $connection->insert('batch')
+        ->fields([
+          'timestamp' => \Drupal::time()->getRequestTime(),
+          'token' => '',
+          'batch' => NULL,
+        ])
+        ->execute();
+      if ($connection->databaseType() !== 'sqlite') {
+        $this->fail('Insert to {batch} without bid should have failed, but it did not');
+      }
+    }
+    catch (\Exception $e) {
+      $this->assertInstanceOf(IntegrityConstraintViolationException::class, $e);
+    }
+
+    $this->runUpdates();
+
+    // $bid should be higher than one, since the update process would have
+    // executed a batch already. We look at the records inserted to determine
+    // the value of $bid, instead of relying to the value returned by the
+    // INSERT, because in PostgresSql the test connection gets confused by the
+    // ::changeField() executed in the SUT and keeps returning 0 instead of
+    // lastId as result of the insert.
+    $connection->insert('batch')
+      ->fields([
+        'timestamp' => \Drupal::time()->getRequestTime(),
+        'token' => '',
+        'batch' => NULL,
+      ])
+      ->execute();
+    $bid = (int) $connection->query('SELECT MAX([bid]) FROM {batch}')->fetchField();
+    $this->assertGreaterThan(1, $bid);
+    $connection->insert('batch')
+      ->fields([
+        'timestamp' => \Drupal::time()->getRequestTime(),
+        'token' => '',
+        'batch' => NULL,
+      ])
+      ->execute();
+    $this->assertEquals($bid + 1, (int) $connection->query('SELECT MAX([bid]) FROM {batch}')->fetchField());
+  }
+
+}
diff --git a/core/phpstan-baseline.neon b/core/phpstan-baseline.neon
index a956663a84..cca61630b2 100644
--- a/core/phpstan-baseline.neon
+++ b/core/phpstan-baseline.neon
@@ -232,7 +232,7 @@ parameters:
 
 		-
 			message: "#^Call to deprecated constant REQUEST_TIME\\: Deprecated in drupal\\:8\\.3\\.0 and is removed from drupal\\:11\\.0\\.0\\. Use \\\\Drupal\\:\\:time\\(\\)\\-\\>getRequestTime\\(\\); $#"
-			count: 2
+			count: 1
 			path: lib/Drupal/Core/Batch/BatchStorage.php
 
 		-
