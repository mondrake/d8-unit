diff --git a/core/lib/Drupal/Core/Database/StatementWrapper.php b/core/lib/Drupal/Core/Database/StatementWrapper.php
index 8a3bc208c5..27650682bb 100644
--- a/core/lib/Drupal/Core/Database/StatementWrapper.php
+++ b/core/lib/Drupal/Core/Database/StatementWrapper.php
@@ -7,7 +7,7 @@
 /**
  * Implementation of StatementInterface encapsulating PDOStatement.
  */
-class StatementWrapper implements \IteratorAggregate, StatementInterface {
+class StatementWrapper implements \Iterator, StatementInterface {
 
   /**
    * The Drupal database connection object.
@@ -32,6 +32,21 @@ class StatementWrapper implements \IteratorAggregate, StatementInterface {
    */
   protected $rowCountEnabled = FALSE;
 
+  /**
+   * Traces if rows can be fetched from the resultset.
+   */
+  private bool $isResultsetIterable = FALSE;
+
+  /**
+   * The current row, retrieved in the current fetch format.
+   */
+  private mixed $resultsetRow = NULL;
+
+  /**
+   * The key of the current row.
+   */
+  private int $resultsetKey = -1;
+
   /**
    * Constructs a StatementWrapper object.
    *
@@ -93,6 +108,7 @@ public function execute($args = [], $options = []) {
     }
 
     $return = $this->clientStatement->execute($args);
+    $this->markResultsetIterable($return);
 
     if (!empty($logger)) {
       $query_end = microtime(TRUE);
@@ -154,15 +170,15 @@ public function fetchAllKeyed($key_index = 0, $value_index = 1) {
    * {@inheritdoc}
    */
   public function fetchField($index = 0) {
-    // Call \PDOStatement::fetchColumn to fetch the field.
-    return $this->clientStatement->fetchColumn($index);
+    $return = $this->fetch(\PDO::FETCH_NUM);
+dump($return);
+    return $return === FALSE ? FALSE : ($return[$index] ?? NULL);
   }
 
   /**
    * {@inheritdoc}
    */
   public function fetchAssoc() {
-    // Call \PDOStatement::fetch to fetch the row.
     return $this->fetch(\PDO::FETCH_ASSOC);
   }
 
@@ -171,9 +187,20 @@ public function fetchAssoc() {
    */
   public function fetchObject(string $class_name = NULL, array $constructor_arguments = NULL) {
     if ($class_name) {
-      return $this->clientStatement->fetchObject($class_name, $constructor_arguments);
+      $row = $this->clientStatement->fetchObject($class_name, $constructor_arguments);
     }
-    return $this->clientStatement->fetchObject();
+    else {
+      $row = $this->clientStatement->fetchObject();
+    }
+
+    if ($row) {
+      $this->setCurrentResultsetRow($row);
+    }
+    else {
+      $this->markResultsetFetchingComplete();
+    }
+
+    return $row;
   }
 
   /**
@@ -215,21 +242,34 @@ public function setFetchMode($mode, $a1 = NULL, $a2 = []) {
   public function fetch($mode = NULL, $cursor_orientation = NULL, $cursor_offset = NULL) {
     // Call \PDOStatement::fetchAll to fetch all rows.
     // \PDOStatement is picky about the number of arguments in some cases so we
-    // need to be pass the exact number of arguments we where given.
+    // need to pass the exact number of arguments we were given.
     switch (func_num_args()) {
       case 0:
-        return $this->clientStatement->fetch();
+        $row = $this->clientStatement->fetch();
+        break;
 
       case 1:
-        return $this->clientStatement->fetch($mode);
+        $row = $this->clientStatement->fetch($mode);
+        break;
 
       case 2:
-        return $this->clientStatement->fetch($mode, $cursor_orientation);
+        $row = $this->clientStatement->fetch($mode, $cursor_orientation);
+        break;
 
       case 3:
       default:
-        return $this->clientStatement->fetch($mode, $cursor_orientation, $cursor_offset);
+        $row = $this->clientStatement->fetch($mode, $cursor_orientation, $cursor_offset);
+        break;
+    }
+
+    if ($row) {
+      $this->setCurrentResultsetRow($row);
+    }
+    else {
+      $this->markResultsetFetchingComplete();
     }
+
+    return $row;
   }
 
   /**
@@ -241,26 +281,115 @@ public function fetchAll($mode = NULL, $column_index = NULL, $constructor_argume
     // need to be pass the exact number of arguments we where given.
     switch (func_num_args()) {
       case 0:
-        return $this->clientStatement->fetchAll();
+        $return = $this->clientStatement->fetchAll();
+        break;
 
       case 1:
-        return $this->clientStatement->fetchAll($mode);
+        $return = $this->clientStatement->fetchAll($mode);
+        break;
 
       case 2:
-        return $this->clientStatement->fetchAll($mode, $column_index);
+        $return = $this->clientStatement->fetchAll($mode, $column_index);
+        break;
 
       case 3:
       default:
-        return $this->clientStatement->fetchAll($mode, $column_index, $constructor_arguments);
+        $return = $this->clientStatement->fetchAll($mode, $column_index, $constructor_arguments);
     }
+
+    $this->markResultsetFetchingComplete();
+
+    return $return;
   }
 
   /**
-   * {@inheritdoc}
+   * @deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. There is
+   *   no replacement.
+   *
+   * @see https://www.drupal.org/node/3265938
    */
   #[\ReturnTypeWillChange]
   public function getIterator() {
+    @trigger_error(__METHOD__ . '() is deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. There is no replacement. See https://www.drupal.org/node/3265938', E_USER_DEPRECATED);
     return new \ArrayIterator($this->fetchAll());
   }
 
+  /**
+   * Informs the iterator whether rows can be fetched from the resultset.
+   *
+   * @param bool $valid
+   *   The result of the execution of the client statement.
+   */
+  protected function markResultsetIterable(bool $valid): void {
+    $this->isResultsetIterable = $valid;
+    $this->resultsetRow = NULL;
+    $this->resultsetKey = -1;
+  }
+
+  /**
+   * Sets the current resultset row for the iterator, and increments the key.
+   *
+   * @param mixed $row
+   *   The last row fetched from the client statement.
+   */
+  protected function setCurrentResultsetRow(mixed $row): void {
+    $this->resultsetRow = $row;
+    $this->resultsetKey++;
+  }
+
+  /**
+   * Informs the iterator that no more rows can be fetched from the resultset.
+   */
+  protected function markResultsetFetchingComplete(): void {
+    $this->markResultsetIterable(FALSE);
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function current(): mixed {
+    return $this->resultsetRow;
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function key(): mixed {
+    return $this->resultsetKey;
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function rewind(): void {
+    // Nothing to do: our DatabaseStatement can't be rewound.
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function next(): void {
+    $this->fetch();
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function valid(): bool {
+    if ($this->isResultsetIterable && $this->resultsetKey === -1) {
+      $this->fetch();
+    }
+    return $this->isResultsetIterable;
+  }
+
 }
diff --git a/core/modules/mysql/tests/src/Kernel/mysql/StatementTest.php b/core/modules/mysql/tests/src/Kernel/mysql/StatementTest.php
new file mode 100644
index 0000000000..187c26b6e4
--- /dev/null
+++ b/core/modules/mysql/tests/src/Kernel/mysql/StatementTest.php
@@ -0,0 +1,25 @@
+<?php
+
+namespace Drupal\Tests\mysql\Kernel\mysql;
+
+use Drupal\KernelTests\Core\Database\DriverSpecificDatabaseTestBase;
+
+/**
+ * Tests for the Statement object.
+ *
+ * @group Database
+ */
+class StatementTest extends DriverSpecificDatabaseTestBase {
+
+  /**
+   * Tests deprecated ::getIterator.
+   *
+   * @group legacy
+   */
+  public function testGetIterator(): void {
+    $this->expectDeprecation('%s::getIterator() is deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. There is no replacement. See https://www.drupal.org/node/3265938');
+    $statement = $this->connection->prepareStatement('SELECT * FROM {test}', []);
+    $this->assertInstanceOf(\ArrayIterator::class, $statement->getIterator());
+  }
+
+}
diff --git a/core/modules/mysql/tests/src/Unit/ConnectionTest.php b/core/modules/mysql/tests/src/Unit/ConnectionTest.php
index 878d7672ad..5ebe43b626 100644
--- a/core/modules/mysql/tests/src/Unit/ConnectionTest.php
+++ b/core/modules/mysql/tests/src/Unit/ConnectionTest.php
@@ -77,9 +77,9 @@ public function __construct(\PDO $connection) {
    */
   public function testVersionAndIsMariaDb(bool $expected_is_mariadb, string $server_version, string $expected_version): void {
     $this->pdoStatement
-      ->fetchColumn(Argument::any())
+      ->fetch(Argument::any())
       ->shouldBeCalled()
-      ->willReturn($server_version);
+      ->willReturn([$server_version]);
 
     $connection = $this->createConnection();
 
diff --git a/core/modules/pgsql/tests/src/Kernel/pgsql/StatementTest.php b/core/modules/pgsql/tests/src/Kernel/pgsql/StatementTest.php
new file mode 100644
index 0000000000..8d59d500a1
--- /dev/null
+++ b/core/modules/pgsql/tests/src/Kernel/pgsql/StatementTest.php
@@ -0,0 +1,25 @@
+<?php
+
+namespace Drupal\Tests\pgsql\Kernel\pgsql;
+
+use Drupal\KernelTests\Core\Database\DriverSpecificDatabaseTestBase;
+
+/**
+ * Tests for the Statement object.
+ *
+ * @group Database
+ */
+class StatementTest extends DriverSpecificDatabaseTestBase {
+
+  /**
+   * Tests deprecated ::getIterator.
+   *
+   * @group legacy
+   */
+  public function testGetIterator(): void {
+    $this->expectDeprecation('%s::getIterator() is deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. There is no replacement. See https://www.drupal.org/node/3265938');
+    $statement = $this->connection->prepareStatement('SELECT * FROM {test}', []);
+    $this->assertInstanceOf(\ArrayIterator::class, $statement->getIterator());
+  }
+
+}
