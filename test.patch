diff --git a/core/includes/install.core.inc b/core/includes/install.core.inc
index 15ec5704b3..12a6814bdf 100644
--- a/core/includes/install.core.inc
+++ b/core/includes/install.core.inc
@@ -532,7 +532,9 @@ function install_begin_request($class_loader, &$install_state) {
   $task = install_verify_completed_task();
 
   // Ensure that the active configuration is empty before installation starts.
+dump([__FUNCTION__, '*** 1', $install_state['config_verified'], $task]);
   if ($install_state['config_verified'] && empty($task)) {
+dump([__FUNCTION__, '*** 2', $kernel->getConfigStorage()->listAll()]);
     if (count($kernel->getConfigStorage()->listAll())) {
       $task = NULL;
       throw new AlreadyInstalledException($container->get('string_translation'));
diff --git a/core/lib/Drupal/Core/Batch/BatchStorage.php b/core/lib/Drupal/Core/Batch/BatchStorage.php
index a7733535ba..12f2fc2871 100644
--- a/core/lib/Drupal/Core/Batch/BatchStorage.php
+++ b/core/lib/Drupal/Core/Batch/BatchStorage.php
@@ -6,10 +6,17 @@
 use Drupal\Core\Access\CsrfTokenGenerator;
 use Drupal\Core\Database\Connection;
 use Drupal\Core\Database\DatabaseException;
+use Drupal\Core\Database\SchemaDefinition\Column;
+use Drupal\Core\Database\SchemaDefinition\ConvertDefinitionTrait;
+use Drupal\Core\Database\SchemaDefinition\Index;
+use Drupal\Core\Database\SchemaDefinition\PrimaryKey;
+use Drupal\Core\Database\SchemaDefinition\Table;
 use Symfony\Component\HttpFoundation\Session\SessionInterface;
 
 class BatchStorage implements BatchStorageInterface {
 
+  use ConvertDefinitionTrait;
+
   /**
    * The table name.
    */
@@ -195,6 +202,9 @@ protected function ensureTableExists() {
     try {
       $database_schema = $this->connection->schema();
       $schema_definition = $this->schemaDefinition();
+      if (!$this->connection->supportsSchemaDefinition()) {
+        $schema_definition = $this->convertTableToArrayDefinition($schema_definition);
+      }
       $database_schema->createTable(static::TABLE_NAME, $schema_definition);
     }
     // If another process has already created the batch table, attempting to
@@ -232,38 +242,46 @@ protected function catchException(\Exception $e) {
    * @internal
    */
   public function schemaDefinition() {
-    return [
-      'description' => 'Stores details about batches (processes that run in multiple HTTP requests).',
-      'fields' => [
-        'bid' => [
-          'description' => 'Primary Key: Unique batch ID.',
-          'type' => 'serial',
-          'unsigned' => TRUE,
-          'not null' => TRUE,
-        ],
-        'token' => [
-          'description' => "A string token generated against the current user's session id and the batch id, used to ensure that only the user who submitted the batch can effectively access it.",
-          'type' => 'varchar_ascii',
-          'length' => 64,
-          'not null' => TRUE,
-        ],
-        'timestamp' => [
-          'description' => 'A Unix timestamp indicating when this batch was submitted for processing. Stale batches are purged at cron time.',
-          'type' => 'int',
-          'not null' => TRUE,
-        ],
-        'batch' => [
-          'description' => 'A serialized array containing the processing data for the batch.',
-          'type' => 'blob',
-          'not null' => FALSE,
-          'size' => 'big',
-        ],
+    return new Table(
+      name: static::TABLE_NAME,
+      description: 'Stores details about batches (processes that run in multiple HTTP requests).',
+      columns: [
+        new Column(
+          name: 'bid',
+          description: 'Primary Key: Unique batch ID.',
+          type: 'serial',
+          unsigned: TRUE,
+          notNull: TRUE,
+        ),
+        new Column(
+          name: 'token',
+          description: "A string token generated against the current user's session id and the batch id, used to ensure that only the user who submitted the batch can effectively access it.",
+          type: 'varchar_ascii',
+          length: 64,
+          notNull: TRUE,
+        ),
+        new Column(
+          name: 'timestamp',
+          description: 'A Unix timestamp indicating when this batch was submitted for processing. Stale batches are purged at cron time.',
+          type: 'int',
+          notNull: TRUE,
+        ),
+        new Column(
+          name: 'batch',
+          description: 'A serialized array containing the processing data for the batch.',
+          type: 'blob',
+          notNull: FALSE,
+          size: 'big',
+        ),
       ],
-      'primary key' => ['bid'],
-      'indexes' => [
-        'token' => ['token'],
+      primaryKey: new PrimaryKey(['bid']),
+      indexes: [
+        new Index(
+          name: 'token',
+          columns: ['token'],
+        ),
       ],
-    ];
+    );
   }
 
 }
diff --git a/core/lib/Drupal/Core/Database/Connection.php b/core/lib/Drupal/Core/Database/Connection.php
index cdaf0d19dd..498c6d829a 100644
--- a/core/lib/Drupal/Core/Database/Connection.php
+++ b/core/lib/Drupal/Core/Database/Connection.php
@@ -1767,6 +1767,19 @@ public function supportsTransactionalDDL() {
     return $this->transactionalDDLSupport;
   }
 
+  /**
+   * Determines if this driver can handle SchemaDefinition objects.
+   *
+   * @return bool
+   *   TRUE if this driver can handle SchemaDefinition objects directly, FALSE
+   *   if they have to be converted to the legacy array-based specifications.
+   *
+   * @internal
+   */
+  public function supportsSchemaDefinition(): bool {
+    return FALSE;
+  }
+
   /**
    * Returns the name of the database engine accessed by this driver.
    *
diff --git a/core/lib/Drupal/Core/Database/Exception/SchemaDefinitionException.php b/core/lib/Drupal/Core/Database/Exception/SchemaDefinitionException.php
new file mode 100644
index 0000000000..fc0b178ac6
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/Exception/SchemaDefinitionException.php
@@ -0,0 +1,12 @@
+<?php
+
+namespace Drupal\Core\Database\Exception;
+
+use Drupal\Core\Database\DatabaseException;
+use Drupal\Core\Database\SchemaException;
+
+/**
+ * Exception thrown by the Schema Definition API.
+ */
+class SchemaDefinitionException extends SchemaException implements DatabaseException {
+}
diff --git a/core/lib/Drupal/Core/Database/SchemaDefinition/Column.php b/core/lib/Drupal/Core/Database/SchemaDefinition/Column.php
new file mode 100644
index 0000000000..5dea84a4ae
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/SchemaDefinition/Column.php
@@ -0,0 +1,93 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Core\Database\SchemaDefinition;
+
+/**
+ * Describes a database table's column.
+ */
+final class Column implements SchemaDefinitionInterface {
+
+  /**
+   * Constructor.
+   *
+   * @param string $name
+   *   The column name.
+   * @param Property|string $type
+   *   (Optional) The generic datatype: 'char', 'varchar', 'text', 'blob',
+   *   'int', 'float', 'numeric', or 'serial'. Most types just map to the
+   *   according database engine specific data types. This argument is
+   *   mandatory unless $dbSpecificType is specified.
+   *   Use 'serial' for auto incrementing fields. This will expand to
+   *   'INT auto_increment' on MySQL.
+   *   A special 'varchar_ascii' type is also available for limiting machine
+   *   name field to US ASCII characters.
+   * @param Property|string $description
+   *   (Optional) A string in non-markup plain text describing this field and
+   *   its purpose. References to other tables should be enclosed in curly
+   *   brackets. For example, the users_data table 'uid' field description
+   *   might contain "The {users}.uid this record affects."
+   * @param Property|bool $serialize
+   *   (Optional) A boolean indicating whether the field will be stored as a
+   *   serialized string.
+   * @param Property|string $size
+   *   (Optional) The data size: 'tiny', 'small', 'medium', 'normal', 'big'.
+   *   This is a hint about the largest value the field will store and
+   *   determines which of the database engine specific data types will be
+   *   used (e.g. on MySQL, TINYINT vs. INT vs. BIGINT). 'normal', the default,
+   *   selects the base type (e.g. on MySQL, INT, VARCHAR, BLOB, etc.). Not all
+   *   sizes are available for all data types. See
+   *   DatabaseSchema::getFieldTypeMap() for possible combinations.
+   * @param Property|bool $notNull
+   *   (Optional)  If true, no NULL values will be allowed in this database
+   *   column. Defaults to false.
+   * @param Property|string|int|null $default
+   *   (Optional) The field's default value. The PHP type of the value
+   *   matters: '', '0', and 0 are all different. If you specify '0' as the
+   *   default value for a type 'int' field it will not work because '0' is a
+   *   string containing the character "zero", not an integer.
+   * @param Property|int $length
+   *   (Optional) The maximal length of a type 'char', 'varchar' or 'text'
+   *   field. Ignored for other field types.
+   * @param Property|bool $unsigned
+   *   (Optional) A boolean indicating whether a type 'int', 'float' and
+   *   'numeric' only is signed or unsigned. Defaults to FALSE. Ignored for
+   *    other field types.
+   * @param Property|int $precision
+   *   (Optional) Mandatory for type 'numeric' fields, indicates the precision
+   *   (total number of significant digits). Ignored for other field types.
+   * @param Property|int $scale
+   *   (Optional) Mandatory for type 'numeric' fields, indicates the scale
+   *   (decimal digits right of the decimal point). Ignored for other field
+   *   types.
+   * @param Property|bool $binary
+   *   (Optional) A boolean indicating that MySQL should force 'char',
+   *   'varchar' or 'text' fields to use case-sensitive binary collation. This
+   *   has no effect on other database types for which case sensitivity is
+   *   already the default behavior.
+   * @param Property|array<string,string> $dbSpecificType
+   *   (Optional) If you need to use a column type not included in the
+   *   officially supported list of types above, you can specify a type for
+   *   each database backend. Specify this as an associative array having the
+   *   database type ('mysql', 'sqlite', 'pgsql', 'oracle', etc.) as the key,
+   *   and the database specific type as the value.
+   */
+  public function __construct(
+    public readonly string $name,
+    public readonly Property|string $type = Property::Undefined,
+    public readonly Property|string $description = Property::Undefined,
+    public readonly Property|bool $serialize = Property::Undefined,
+    public readonly Property|string $size = Property::Undefined,
+    public readonly Property|bool $notNull = Property::Undefined,
+    public readonly Property|string|int|NULL $default = Property::Undefined,
+    public readonly Property|int $length = Property::Undefined,
+    public readonly Property|bool $unsigned = Property::Undefined,
+    public readonly Property|int $precision = Property::Undefined,
+    public readonly Property|int $scale = Property::Undefined,
+    public readonly Property|bool $binary = Property::Undefined,
+    public readonly Property|array $dbSpecificType = Property::Undefined,
+  ) {
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Database/SchemaDefinition/ConvertDefinitionTrait.php b/core/lib/Drupal/Core/Database/SchemaDefinition/ConvertDefinitionTrait.php
new file mode 100644
index 0000000000..776f4d6391
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/SchemaDefinition/ConvertDefinitionTrait.php
@@ -0,0 +1,185 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Core\Database\SchemaDefinition;
+
+/**
+ * A helper trait to convert SchemaDefinition objects to legacy array.
+ *
+ * @internal
+ */
+trait ConvertDefinitionTrait {
+
+  /**
+   * Converts a Table object.
+   *
+   * @internal
+   */
+  final protected static function convertTableToArrayDefinition(Table $table): array {
+    $spec = [];
+    if ($table->description !== Property::Undefined) {
+      $spec['description'] = $table->description;
+    }
+    if ($table->columns !== Property::Undefined) {
+      $spec['fields'] = self::convertColumnsToArrayDefinition($table->columns);
+    }
+    if ($table->primaryKey !== Property::Undefined) {
+      $spec['primary key'] = self::convertPrimaryKeyToArrayDefinition($table->primaryKey);
+    }
+    if ($table->uniqueKeys !== Property::Undefined) {
+      $spec['unique keys'] = self::convertUniqueKeysToArrayDefinition($table->uniqueKeys);
+    }
+    if ($table->indexes !== Property::Undefined) {
+      $spec['indexes'] = self::convertIndexesToArrayDefinition($table->indexes);
+    }
+    if ($table->foreignKeys !== Property::Undefined) {
+      $spec['foreign keys'] = self::convertForeignKeysToArrayDefinition($table->foreignKeys);
+    }
+    return $spec;
+  }
+
+  /**
+   * Converts an array of Column objects.
+   *
+   * @internal
+   */
+  final protected static function convertColumnsToArrayDefinition(array $columns): array {
+    $spec = [];
+    foreach ($columns as $column) {
+      $spec[$column->name] = self::convertColumnToArrayDefinition($column);
+    }
+    return $spec;
+  }
+
+  /**
+   * Converts a Column object.
+   *
+   * @internal
+   */
+  final protected static function convertColumnToArrayDefinition(Column $column): array {
+    $spec = [];
+    if ($column->type !== Property::Undefined) {
+      $spec['type'] = $column->type;
+    }
+    if ($column->description !== Property::Undefined) {
+      $spec['description'] = $column->description;
+    }
+    if ($column->serialize !== Property::Undefined) {
+      $spec['serialize'] = $column->serialize;
+    }
+    if ($column->size !== Property::Undefined) {
+      $spec['size'] = $column->size;
+    }
+    if ($column->notNull !== Property::Undefined) {
+      $spec['not null'] = $column->notNull;
+    }
+    if ($column->default !== Property::Undefined) {
+      $spec['default'] = $column->default;
+    }
+    if ($column->length !== Property::Undefined) {
+      $spec['length'] = $column->length;
+    }
+    if ($column->unsigned !== Property::Undefined) {
+      $spec['unsigned'] = $column->unsigned;
+    }
+    if ($column->precision !== Property::Undefined) {
+      $spec['precision'] = $column->precision;
+    }
+    if ($column->scale !== Property::Undefined) {
+      $spec['scale'] = $column->scale;
+    }
+    if ($column->binary !== Property::Undefined) {
+      $spec['binary'] = $column->binary;
+    }
+    if ($column->dbSpecificType !== Property::Undefined) {
+      foreach ($column->dbSpecificType as $db => $dbType) {
+        $spec[$db . '_type'] = $dbType;
+      }
+    }
+    return $spec;
+  }
+
+  /**
+   * Converts an array of KeyColumn objects.
+   *
+   * @internal
+   */
+  final protected static function convertKeyColumnsToArrayDefinition(array $columns): array {
+    $spec = [];
+    foreach ($columns as $column) {
+      $spec[] = self::convertKeyColumnToArrayDefinition($column);
+    }
+    return $spec;
+  }
+
+  /**
+   * Converts a KeyColumn object.
+   *
+   * @internal
+   */
+  final protected static function convertKeyColumnToArrayDefinition(KeyColumn $column): string|array {
+    if ($column->length !== NULL) {
+      return [$column->name, $column->length];
+    }
+    return $column->name;
+  }
+
+  /**
+   * Converts a PrimaryKey object.
+   *
+   * @internal
+   */
+  final protected static function convertPrimaryKeyToArrayDefinition(PrimaryKey $primaryKey): array {
+    return self::convertKeyColumnsToArrayDefinition($primaryKey->columns);
+  }
+
+  /**
+   * Converts an array of UniqueKey objects.
+   *
+   * @internal
+   */
+  final protected static function convertUniqueKeysToArrayDefinition(array $uniqueKeys): array {
+    $spec = [];
+    foreach ($uniqueKeys as $uniqueKey) {
+      $spec[$uniqueKey->name] = self::convertKeyColumnsToArrayDefinition($uniqueKey->columns);
+    }
+    return $spec;
+  }
+
+  /**
+   * Converts an array of Index objects.
+   *
+   * @internal
+   */
+  final protected static function convertIndexesToArrayDefinition(array $indexes): array {
+    $spec = [];
+    foreach ($indexes as $index) {
+      $spec[$index->name] = self::convertKeyColumnsToArrayDefinition($index->columns);
+    }
+    return $spec;
+  }
+
+  /**
+   * Converts an array of ForeignKey objects.
+   *
+   * @internal
+   */
+  final protected static function convertForeignKeysToArrayDefinition(array $foreignKeys): array {
+    $spec = [];
+    foreach ($foreignKeys as $foreignKey) {
+      $cols = self::convertKeyColumnsToArrayDefinition($foreignKey->columns);
+      $foreignCols = self::convertKeyColumnsToArrayDefinition($foreignKey->foreignColumns);
+      $match = [];
+      for ($i = 0; $i < count($cols); $i++) {
+        $match[$cols[$i]] = $foreignCols[$i];
+      }
+      $spec[$foreignKey->name] = [
+        'table' => $foreignKey->foreignTable,
+        'columns' => $match,
+      ];
+    }
+    return $spec;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Database/SchemaDefinition/ForeignKey.php b/core/lib/Drupal/Core/Database/SchemaDefinition/ForeignKey.php
new file mode 100644
index 0000000000..4c9541fbeb
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/SchemaDefinition/ForeignKey.php
@@ -0,0 +1,47 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Core\Database\SchemaDefinition;
+
+/**
+ * Describes a database foreign key.
+ */
+final class ForeignKey extends KeyBase {
+
+  /**
+   * The foreign key columns.
+   *
+   * @var KeyColumn[]
+   *   The list of KeyColumn objects of the foreign table.
+   */
+  public readonly array $foreignColumns;
+
+  /**
+   * Constructor.
+   *
+   * @param string $name
+   *   The foreign key name.
+   * @param string $foreignTable
+   *   The foreign (referenced) table name.
+   * @param list<KeyColumn|string|array{0:string, 1:int}> $columns
+   *   A mix of key column specifiers, being KeyColumn objects, strings naming
+   *   columns, or arrays of two elements, column name and length, specifying a
+   *   prefix of the named column.
+   * @param list<KeyColumn|string|array{0:string, 1:int}> $foreignColumns
+   *   A mix of key column specifiers of the foreign (referenced) table, being
+   *   KeyColumn objects, strings naming columns, or arrays of two elements,
+   *   column name and length, specifying a prefix of the named column.
+   */
+  public function __construct(
+    public readonly string $name,
+    public readonly string $foreignTable,
+    array $columns,
+    array $foreignColumns,
+  ) {
+    parent::__construct($columns);
+    $this->foreignColumns = $this->buildColumns($foreignColumns);
+    assert(count($this->columns) === count($this->foreignColumns), "Mismatching count of columns for the {$this->name} foreign key.");
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Database/SchemaDefinition/Index.php b/core/lib/Drupal/Core/Database/SchemaDefinition/Index.php
new file mode 100644
index 0000000000..e5292b5f60
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/SchemaDefinition/Index.php
@@ -0,0 +1,29 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Core\Database\SchemaDefinition;
+
+/**
+ * Describes a database index.
+ */
+final class Index extends KeyBase {
+
+  /**
+   * Constructor.
+   *
+   * @param string $name
+   *   The index name.
+   * @param list<KeyColumn|string|array{0:string, 1:int}> $columns
+   *   A mix of key column specifiers, being KeyColumn objects, strings naming
+   *   columns, or arrays of two elements, column name and length, specifying a
+   *   prefix of the named column.
+   */
+  public function __construct(
+    public readonly string $name,
+    array $columns,
+  ) {
+    parent::__construct($columns);
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Database/SchemaDefinition/KeyBase.php b/core/lib/Drupal/Core/Database/SchemaDefinition/KeyBase.php
new file mode 100644
index 0000000000..b135d4ed37
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/SchemaDefinition/KeyBase.php
@@ -0,0 +1,59 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Core\Database\SchemaDefinition;
+
+/**
+ * Base class for table keys (primary, unique, index).
+ */
+abstract class KeyBase implements SchemaDefinitionInterface {
+
+  /**
+   * The key columns.
+   *
+   * @var KeyColumn[]
+   *   The list of KeyColumn objects.
+   */
+  public readonly array $columns;
+
+  /**
+   * Constructor.
+   *
+   * @param list<KeyColumn|string|array{0:string, 1:int}> $columns
+   *   A mix of key column specifiers, being KeyColumn objects, strings naming
+   *   columns, or arrays of two elements, column name and length, specifying a
+   *   prefix of the named column.
+   */
+  public function __construct(array $columns) {
+    $this->columns = $this->buildColumns($columns);
+  }
+
+  /**
+   * Builds an array of KeyColumn objects from a mixed list of columns.
+   *
+   * @param list<KeyColumn|string|array{0:string, 1:int}> $rawColumns
+   *   A mix of key column specifiers, being KeyColumn objects, strings naming
+   *   columns, or arrays of two elements, column name and length, specifying a
+   *   prefix of the named column.
+   *
+   * @return KeyColumn[]
+   *   The normalized list of KeyColumn objects.
+   */
+  protected function buildColumns(array $rawColumns): array {
+    $columns = [];
+    foreach ($rawColumns as $rawColumn) {
+      if ($rawColumn instanceof KeyColumn) {
+        $columns[] = $rawColumn;
+      }
+      elseif (is_array($rawColumn)) {
+        $columns[] = new KeyColumn($rawColumn[0], $rawColumn[1]);
+      }
+      else {
+        $columns[] = new KeyColumn($rawColumn);
+      }
+    }
+    return $columns;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Database/SchemaDefinition/KeyColumn.php b/core/lib/Drupal/Core/Database/SchemaDefinition/KeyColumn.php
new file mode 100644
index 0000000000..d54b7e3f1f
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/SchemaDefinition/KeyColumn.php
@@ -0,0 +1,26 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Core\Database\SchemaDefinition;
+
+/**
+ * Describes a column of a database index or key.
+ */
+final class KeyColumn implements SchemaDefinitionInterface {
+
+  /**
+   * Constructor.
+   *
+   * @param string $name
+   *   The column name.
+   * @param int|null $length
+   *   (Optional) if set, specifies a prefix of the named column.
+   */
+  public function __construct(
+    public readonly string $name,
+    public readonly ?int $length = NULL,
+  ) {
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Database/SchemaDefinition/PrimaryKey.php b/core/lib/Drupal/Core/Database/SchemaDefinition/PrimaryKey.php
new file mode 100644
index 0000000000..a176fad02f
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/SchemaDefinition/PrimaryKey.php
@@ -0,0 +1,24 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Core\Database\SchemaDefinition;
+
+/**
+ * Describes a table's primary key.
+ */
+final class PrimaryKey extends KeyBase {
+
+  /**
+   * Constructor.
+   *
+   * @param list<KeyColumn|string|array{0:string, 1:int}> $columns
+   *   A mix of key column specifiers, being KeyColumn objects, strings naming
+   *   columns, or arrays of two elements, column name and length, specifying a
+   *   prefix of the named column.
+   */
+  public function __construct(array $columns) {
+    parent::__construct($columns);
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Database/SchemaDefinition/Property.php b/core/lib/Drupal/Core/Database/SchemaDefinition/Property.php
new file mode 100644
index 0000000000..6bee3da7d9
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/SchemaDefinition/Property.php
@@ -0,0 +1,14 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Core\Database\SchemaDefinition;
+
+/**
+ * Enumeration of property special cases for SchemaDefinition.
+ */
+enum Property {
+
+  case Undefined;
+
+}
diff --git a/core/lib/Drupal/Core/Database/SchemaDefinition/SchemaDefinitionInterface.php b/core/lib/Drupal/Core/Database/SchemaDefinition/SchemaDefinitionInterface.php
new file mode 100644
index 0000000000..2d3489f872
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/SchemaDefinition/SchemaDefinitionInterface.php
@@ -0,0 +1,11 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Core\Database\SchemaDefinition;
+
+/**
+ * Interface for objects describing database elements.
+ */
+interface SchemaDefinitionInterface {
+}
diff --git a/core/lib/Drupal/Core/Database/SchemaDefinition/Table.php b/core/lib/Drupal/Core/Database/SchemaDefinition/Table.php
new file mode 100644
index 0000000000..e31fd72ebd
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/SchemaDefinition/Table.php
@@ -0,0 +1,48 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Core\Database\SchemaDefinition;
+
+/**
+ * Describes a database table.
+ */
+final class Table implements SchemaDefinitionInterface {
+
+  /**
+   * Constructor.
+   *
+   * @param string $name
+   *   The table name.
+   * @param Property|Column[] $columns
+   *   (Optional) An array that describes the table's database columns. This is
+   *   normally mandatory. Some methods in the Schema API - for example
+   *   Schema::addField() - require partial table definition, so this is
+   *   optional to support it.
+   * @param Property|string $description
+   *   (Optional) A string in non-markup plain text describing this table and
+   *   its purpose. References to other tables should be enclosed in curly
+   *   brackets.
+   * @param Property|PrimaryKey $primaryKey
+   *   (Optional) The primary key of the table.
+   * @param Property|UniqueKey[] $uniqueKeys
+   *   (Optional) An array of unique keys for the table.
+   * @param Property|Index[] $indexes
+   *   (Optional) An array of indexes for the table.
+   * @param Property|ForeignKey[] $foreignKeys
+   *   (Optional) An array of foreign keys for the table. This argument is for
+   *   documentation purposes only; foreign keys are not created in the
+   *   database, nor are they enforced by Drupal.
+   */
+  public function __construct(
+    public readonly string $name,
+    public readonly Property|array $columns = Property::Undefined,
+    public readonly Property|string $description = Property::Undefined,
+    public readonly Property|PrimaryKey $primaryKey = Property::Undefined,
+    public readonly Property|array $uniqueKeys = Property::Undefined,
+    public readonly Property|array $indexes = Property::Undefined,
+    public readonly Property|array $foreignKeys = Property::Undefined,
+  ) {
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Database/SchemaDefinition/UniqueKey.php b/core/lib/Drupal/Core/Database/SchemaDefinition/UniqueKey.php
new file mode 100644
index 0000000000..7bb8e49142
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/SchemaDefinition/UniqueKey.php
@@ -0,0 +1,29 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Core\Database\SchemaDefinition;
+
+/**
+ * Describes a database unique key.
+ */
+final class UniqueKey extends KeyBase {
+
+  /**
+   * Constructor.
+   *
+   * @param string $name
+   *   The unique key name.
+   * @param list<KeyColumn|string|array{0:string, 1:int}> $columns
+   *   A mix of key column specifiers, being KeyColumn objects, strings naming
+   *   columns, or arrays of two elements, column name and length, specifying a
+   *   prefix of the named column.
+   */
+  public function __construct(
+    public readonly string $name,
+    array $columns,
+  ) {
+    parent::__construct($columns);
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Extension/ModuleInstaller.php b/core/lib/Drupal/Core/Extension/ModuleInstaller.php
index 289ecffe41..54223c37ae 100644
--- a/core/lib/Drupal/Core/Extension/ModuleInstaller.php
+++ b/core/lib/Drupal/Core/Extension/ModuleInstaller.php
@@ -5,6 +5,9 @@
 use Drupal\Core\Cache\Cache;
 use Drupal\Core\Cache\CacheBackendInterface;
 use Drupal\Core\Database\Connection;
+use Drupal\Core\Database\Exception\SchemaDefinitionException;
+use Drupal\Core\Database\SchemaDefinition\ConvertDefinitionTrait;
+use Drupal\Core\Database\SchemaDefinition\Table;
 use Drupal\Core\DrupalKernelInterface;
 use Drupal\Core\Entity\EntityStorageException;
 use Drupal\Core\Entity\FieldableEntityInterface;
@@ -28,6 +31,8 @@
  */
 class ModuleInstaller implements ModuleInstallerInterface {
 
+  use ConvertDefinitionTrait;
+
   /**
    * The module handler.
    *
@@ -658,6 +663,17 @@ protected function installSchema(string $module): void {
     $tables = $this->moduleHandler->invoke($module, 'schema') ?? [];
     $schema = $this->connection->schema();
     foreach ($tables as $name => $table) {
+      if ($table instanceof Table) {
+        if (is_int($name)) {
+          $name = $table->name;
+        }
+        if ($name !== $table->name) {
+          throw new SchemaDefinitionException("The '{$name}' key returned by the {$module}_schema() function must be equal to the Table::\$name property; found '{$table->name}'");
+        }
+        if (!$this->connection->supportsSchemaDefinition()) {
+          $table = $this->convertTableToArrayDefinition($table);
+        }
+      }
       $schema->createTable($name, $table);
     }
   }
@@ -673,9 +689,17 @@ protected function installSchema(string $module): void {
   protected function uninstallSchema(string $module): void {
     $tables = $this->moduleHandler->invoke($module, 'schema') ?? [];
     $schema = $this->connection->schema();
-    foreach (array_keys($tables) as $table) {
-      if ($schema->tableExists($table)) {
-        $schema->dropTable($table);
+    foreach ($tables as $name => $table) {
+      if ($table instanceof Table) {
+        if (is_int($name)) {
+          $name = $table->name;
+        }
+        if ($name !== $table->name) {
+          throw new SchemaDefinitionException("The '{$name}' key returned by the {$module}_schema() function must be equal to the Table::\$name property; found '{$table->name}'");
+        }
+      }
+      if ($schema->tableExists($name)) {
+        $schema->dropTable($name);
       }
     }
   }
diff --git a/core/lib/Drupal/Core/Installer/Exception/AlreadyInstalledException.php b/core/lib/Drupal/Core/Installer/Exception/AlreadyInstalledException.php
index 02d2995fd5..359c41e6da 100644
--- a/core/lib/Drupal/Core/Installer/Exception/AlreadyInstalledException.php
+++ b/core/lib/Drupal/Core/Installer/Exception/AlreadyInstalledException.php
@@ -17,7 +17,7 @@ class AlreadyInstalledException extends InstallerException {
    */
   public function __construct(TranslationInterface $string_translation) {
     $this->stringTranslation = $string_translation;
-
+dump(\Drupal\Core\Utility\Error::formatBacktrace(debug_backtrace()));
     $title = $this->t('Drupal already installed');
     $replacements = [
       ':base-url' => $GLOBALS['base_url'],
diff --git a/core/modules/system/system.install b/core/modules/system/system.install
index 079fa6cbf7..0bb8cea662 100644
--- a/core/modules/system/system.install
+++ b/core/modules/system/system.install
@@ -13,6 +13,11 @@
 use Drupal\Component\Utility\Unicode;
 use Drupal\Core\Cache\Cache;
 use Drupal\Core\Database\Database;
+use Drupal\Core\Database\SchemaDefinition\Column;
+use Drupal\Core\Database\SchemaDefinition\ForeignKey;
+use Drupal\Core\Database\SchemaDefinition\Index;
+use Drupal\Core\Database\SchemaDefinition\PrimaryKey;
+use Drupal\Core\Database\SchemaDefinition\Table;
 use Drupal\Core\DrupalKernel;
 use Drupal\Core\Extension\ExtensionLifecycle;
 use Drupal\Core\Entity\EntityTypeInterface;
@@ -1616,69 +1621,83 @@ function system_schema() {
   // @deprecated The sequences table has been deprecated in drupal:10.2.0 and is
   // removed from drupal:12.0.0. See https://www.drupal.org/node/3220378.
   // @todo: Remove sequences table in Drupal 12. See https://www.drupal.org/i/3335756
-  $schema['sequences'] = [
-    'description' => 'Stores IDs.',
-    'fields' => [
-      'value' => [
-        'description' => 'The value of the sequence.',
-        'type' => 'serial',
-        'unsigned' => TRUE,
-        'not null' => TRUE,
-      ],
-    ],
-    'primary key' => ['value'],
-  ];
-
-  $schema['sessions'] = [
-    'description' => "Drupal's session handlers read and write into the sessions table. Each record represents a user session, either anonymous or authenticated.",
-    'fields' => [
-      'uid' => [
-        'description' => 'The {users}.uid corresponding to a session, or 0 for anonymous user.',
-        'type' => 'int',
-        'unsigned' => TRUE,
-        'not null' => TRUE,
-      ],
-      'sid' => [
-        'description' => "A session ID (hashed). The value is generated by Drupal's session handlers.",
-        'type' => 'varchar_ascii',
-        'length' => 128,
-        'not null' => TRUE,
-      ],
-      'hostname' => [
-        'description' => 'The IP address that last used this session ID (sid).',
-        'type' => 'varchar_ascii',
-        'length' => 128,
-        'not null' => TRUE,
-        'default' => '',
-      ],
-      'timestamp' => [
-        'description' => 'The Unix timestamp when this session last requested a page. Old records are purged by PHP automatically.',
-        'type' => 'int',
-        'not null' => TRUE,
-        'default' => 0,
-        'size' => 'big',
-      ],
-      'session' => [
-        'description' => 'The serialized contents of the user\'s session, an array of name/value pairs that persists across page requests by this session ID. Drupal loads the user\'s session from here at the start of each request and saves it at the end.',
-        'type' => 'blob',
-        'not null' => FALSE,
-        'size' => 'big',
-      ],
+  $schema[] = new Table(
+    name: 'sequences',
+    description: 'Stores IDs.',
+    columns: [
+      new Column(
+        name: 'value',
+        description: 'The value of the sequence.',
+        type: 'serial',
+        unsigned: TRUE,
+        notNull: TRUE,
+      ),
     ],
-    'primary key' => [
-      'sid',
+    primaryKey: new PrimaryKey(['value']),
+  );
+
+  $schema[] = new Table(
+    name: 'sessions',
+    description: "Drupal's session handlers read and write into the sessions table. Each record represents a user session, either anonymous or authenticated.",
+    columns: [
+      new Column(
+        name: 'uid',
+        description: 'The {users}.uid corresponding to a session, or 0 for anonymous user.',
+        type: 'int',
+        unsigned: TRUE,
+        notNull: TRUE,
+      ),
+      new Column(
+        name: 'sid',
+        description: "A session ID (hashed). The value is generated by Drupal's session handlers.",
+        type: 'varchar_ascii',
+        length: 128,
+        notNull: TRUE,
+      ),
+      new Column(
+        name: 'hostname',
+        description: 'The IP address that last used this session ID (sid).',
+        type: 'varchar_ascii',
+        length: 128,
+        notNull: TRUE,
+        default: '',
+      ),
+      new Column(
+        name: 'timestamp',
+        description: 'The Unix timestamp when this session last requested a page. Old records are purged by PHP automatically.',
+        type: 'int',
+        notNull: TRUE,
+        default: 0,
+        size: 'big',
+      ),
+      new Column(
+        name: 'session',
+        description: 'The serialized contents of the user\'s session, an array of name/value pairs that persists across page requests by this session ID. Drupal loads the user\'s session from here at the start of each request and saves it at the end.',
+        type: 'blob',
+        notNull: FALSE,
+        size: 'big',
+      ),
     ],
-    'indexes' => [
-      'timestamp' => ['timestamp'],
-      'uid' => ['uid'],
+    primaryKey: new PrimaryKey(['sid']),
+    indexes: [
+      new Index(
+        name: 'timestamp',
+        columns: ['timestamp'],
+      ),
+      new Index(
+        name: 'uid',
+        columns: ['uid'],
+      ),
     ],
-    'foreign keys' => [
-      'session_user' => [
-        'table' => 'users',
-        'columns' => ['uid' => 'uid'],
-      ],
+    foreignKeys: [
+      new ForeignKey(
+        name: 'session_user',
+        foreignTable: 'users',
+        columns: ['uid'],
+        foreignColumns: ['uid'],
+      ),
     ],
-  ];
+  );
 
   return $schema;
 }
diff --git a/core/tests/Drupal/TestTools/Extension/SchemaInspector.php b/core/tests/Drupal/TestTools/Extension/SchemaInspector.php
index 134ad27e08..9332679698 100644
--- a/core/tests/Drupal/TestTools/Extension/SchemaInspector.php
+++ b/core/tests/Drupal/TestTools/Extension/SchemaInspector.php
@@ -2,6 +2,9 @@
 
 namespace Drupal\TestTools\Extension;
 
+use Drupal\Core\Database\Exception\SchemaDefinitionException;
+use Drupal\Core\Database\SchemaDefinition\ConvertDefinitionTrait;
+use Drupal\Core\Database\SchemaDefinition\Table;
 use Drupal\Core\Extension\ModuleHandlerInterface;
 
 /**
@@ -9,6 +12,8 @@
  */
 class SchemaInspector {
 
+  use ConvertDefinitionTrait;
+
   /**
    * Returns the module's schema specification.
    *
@@ -28,7 +33,23 @@ class SchemaInspector {
    */
   public static function getTablesSpecification(ModuleHandlerInterface $handler, string $module): array {
     if ($handler->loadInclude($module, 'install')) {
-      return $handler->invoke($module, 'schema') ?? [];
+      $tables = $handler->invoke($module, 'schema') ?? [];
+      $temp = [];
+      foreach ($tables as $name => $table) {
+        if ($table instanceof Table) {
+          if (is_int($name)) {
+            $name = $table->name;
+          }
+          if ($name !== $table->name) {
+            throw new SchemaDefinitionException("The '{$name}' key returned by the {$module}_schema() function must be equal to the Table::\$name property; found '{$table->name}'");
+          }
+          if (!\Drupal::database()->supportsSchemaDefinition()) {
+            $table = self::convertTableToArrayDefinition($table);
+          }
+        }
+        $temp[$name] = $table;
+      }
+      return $temp;
     }
     return [];
   }
diff --git a/core/tests/Drupal/Tests/Core/Database/ConvertDefinitionTraitTest.php b/core/tests/Drupal/Tests/Core/Database/ConvertDefinitionTraitTest.php
new file mode 100644
index 0000000000..f5ca2b8d5d
--- /dev/null
+++ b/core/tests/Drupal/Tests/Core/Database/ConvertDefinitionTraitTest.php
@@ -0,0 +1,167 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Drupal\Tests\Core\Database;
+
+use Drupal\Core\Database\SchemaDefinition\Column;
+use Drupal\Core\Database\SchemaDefinition\ConvertDefinitionTrait;
+use Drupal\Core\Database\SchemaDefinition\ForeignKey;
+use Drupal\Core\Database\SchemaDefinition\Index;
+use Drupal\Core\Database\SchemaDefinition\KeyColumn;
+use Drupal\Core\Database\SchemaDefinition\PrimaryKey;
+use Drupal\Core\Database\SchemaDefinition\Table;
+use Drupal\Core\Database\SchemaDefinition\UniqueKey;
+use Drupal\Tests\UnitTestCase;
+
+/**
+ * Tests the ConvertDefinitionTrait.
+ *
+ * @group Database
+ */
+class ConvertDefinitionTraitTest extends UnitTestCase {
+
+  use ConvertDefinitionTrait;
+
+  /**
+   * Tests the ConvertDefinitionTrait.
+   */
+  public function testConvertDefinitionTrait(): void {
+    $arraySpecification = [
+      'description' => 'Basic test table for the database unit tests.',
+      'fields' => [
+        'id' => [
+          'type' => 'serial',
+          'unsigned' => TRUE,
+          'not null' => TRUE,
+        ],
+        'name' => [
+          'description' => "A person's name",
+          'type' => 'varchar_ascii',
+          'length' => 255,
+          'not null' => TRUE,
+          'default' => '',
+          'binary' => TRUE,
+        ],
+        'age' => [
+          'description' => "The person's age",
+          'type' => 'int',
+          'unsigned' => TRUE,
+          'not null' => TRUE,
+          'default' => 0,
+        ],
+        'job' => [
+          'description' => "The person's job",
+          'type' => 'varchar',
+          'length' => 255,
+          'not null' => TRUE,
+          'default' => 'Undefined',
+        ],
+        'db_timestamp' => [
+          'description' => "The database timestamp",
+          'mysql_type' => 'timestamp',
+          'pgsql_type' => 'timestamp',
+          'sqlite_type' => 'datetime',
+          'not null' => FALSE,
+          'default' => NULL,
+        ],
+      ],
+      'primary key' => ['id'],
+      'unique keys' => [
+        'name' => ['name'],
+      ],
+      'indexes' => [
+        'ages' => ['age'],
+        'age_job_prefix' => ['age', ['job', 50]],
+        'age_name_prefix' => ['age', ['name', 20]],
+      ],
+      'foreign keys' => [
+        'user_id' => [
+          'table' => 'test_users',
+          'columns' => ['id' => 'id'],
+        ],
+      ],
+    ];
+
+    $schemaDefinition = new Table(
+      name: 'test',
+      description: 'Basic test table for the database unit tests.',
+      columns: [
+        new Column(
+          name: 'id',
+          type: 'serial',
+          unsigned: TRUE,
+          notNull: TRUE,
+        ),
+        new Column(
+          name: 'name',
+          description: "A person's name",
+          type: 'varchar_ascii',
+          length: 255,
+          notNull: TRUE,
+          default: '',
+          binary: TRUE,
+        ),
+        new Column(
+          name: 'age',
+          description: "The person's age",
+          type: 'int',
+          unsigned: TRUE,
+          notNull: TRUE,
+          default: 0,
+        ),
+        new Column(
+          name: 'job',
+          description: "The person's job",
+          type: 'varchar',
+          length: 255,
+          notNull: TRUE,
+          default: 'Undefined',
+        ),
+        new Column(
+          name: 'db_timestamp',
+          description: "The database timestamp",
+          dbSpecificType: [
+            'mysql' => 'timestamp',
+            'pgsql' => 'timestamp',
+            'sqlite' => 'datetime',
+          ],
+          notNull: FALSE,
+          default: NULL,
+        ),
+      ],
+      primaryKey: new PrimaryKey(['id']),
+      uniqueKeys: [
+        new UniqueKey(
+          name: 'name',
+          columns: ['name'],
+        ),
+      ],
+      indexes: [
+        new Index(
+          name: 'ages',
+          columns: ['age'],
+        ),
+        new Index(
+          name: 'age_job_prefix',
+          columns: ['age', ['job', 50]],
+        ),
+        new Index(
+          name: 'age_name_prefix',
+          columns: ['age', new KeyColumn(name: 'name', length: 20)],
+        ),
+      ],
+      foreignKeys: [
+        new ForeignKey(
+          name: 'user_id',
+          foreignTable: 'test_users',
+          columns: ['id'],
+          foreignColumns: ['id'],
+        ),
+      ],
+    );
+
+    $this->assertEquals($arraySpecification, self::convertTableToArrayDefinition($schemaDefinition));
+  }
+
+}
