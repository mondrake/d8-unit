diff --git a/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php b/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php
index 07e727b6a0..46d1a3948c 100644
--- a/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php
+++ b/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php
@@ -23,6 +23,20 @@
  */
 abstract class TransactionManagerBase implements TransactionManagerInterface {
 
+  /**
+   * The id of the root Transaction object.
+   *
+   * We need to keep track of the very first 'root' transaction object created,
+   * because under some circumstances we might end up processing more than one
+   * of them during the transaction stack lifecycle. For example, a root
+   * transaction is opened, then a DDL statement is executed in a database that
+   * does not support transactional DDL, and another root opened before the
+   * original one is closed. By having the first one tracked, we can ensure
+   * that post transaction callbacks are processed only upon its destruction
+   * and not before.
+   */
+  private ?string $rootId = NULL;
+
   /**
    * The stack of Drupal transactions currently active.
    *
@@ -234,11 +248,19 @@ public function push(string $name = ''): Transaction {
       throw new TransactionNameNonUniqueException("A transaction named {$name} is already in use. Active stack: " . $this->dumpStackItemsAsString());
     }
 
+    // Define an unique id for the transaction.
+    $id = uniqid('', TRUE);
+
     // Do the client-level processing.
     if ($this->stackDepth() === 0) {
       $this->beginClientTransaction();
       $type = StackItemType::Root;
       $this->setConnectionTransactionState(ClientConnectionTransactionState::Active);
+      // Only set ::rootId if there's not one set already, which may happen in
+      // case of broken transactions.
+      if ($this->rootId === NULL) {
+        $this->rootId = $id;
+      }
     }
     else {
       // If we're already in a Drupal transaction then we want to create a
@@ -248,9 +270,6 @@ public function push(string $name = ''): Transaction {
       $type = StackItemType::Savepoint;
     }
 
-    // Define an unique id for the transaction.
-    $id = uniqid('', TRUE);
-
     // Add an item on the stack, increasing its depth.
     $this->addStackItem($id, new StackItem($name, $type));
 
@@ -262,6 +281,17 @@ public function push(string $name = ''): Transaction {
    * {@inheritdoc}
    */
   public function unpile(string $name, string $id): void {
+    // If $id is not in the stack, but is in the voided items, and is the root
+    // transaction, then we can process the post transaction callbacks. We are
+    // here because the transaction is not active anymore (a rollback, or a DDL
+    // statement executed breaking the transaction).
+    if (!isset($this->stack()[$id]) && isset($this->voidedItems[$id]) && $this->rootId === $id) {
+      $this->processPostTransactionCallbacks();
+      $this->rootId = NULL;
+      unset($this->voidedItems[$id]);
+      return;
+    }
+
     // If the $id does not correspond to the one in the stack for that $name,
     // we are facing an orphaned Transaction object (for example in case of a
     // DDL statement breaking an active transaction). That should be listed in
@@ -289,6 +319,10 @@ public function unpile(string $name, string $id): void {
         // If this was the root Drupal transaction, we can commit the client
         // transaction.
         $this->processRootCommit();
+        if ($this->rootId === $id) {
+          $this->processPostTransactionCallbacks();
+          $this->rootId = NULL;
+        }
       }
       else {
         // The stack got corrupted.
@@ -403,7 +437,6 @@ protected function getConnectionTransactionState(): ClientConnectionTransactionS
    * Processes the root transaction rollback.
    */
   protected function processRootRollback(): void {
-    $this->processPostTransactionCallbacks();
     $this->rollbackClientTransaction();
   }
 
@@ -415,7 +448,6 @@ protected function processRootRollback(): void {
    */
   protected function processRootCommit(): void {
     $clientCommit = $this->commitClientTransaction();
-    $this->processPostTransactionCallbacks();
     if (!$clientCommit) {
       throw new TransactionCommitFailedException();
     }
@@ -517,7 +549,6 @@ public function voidClientTransaction(): void {
       $this->voidStackItem((string) $i);
     }
     $this->setConnectionTransactionState(ClientConnectionTransactionState::Voided);
-    $this->processPostTransactionCallbacks();
   }
 
 }
diff --git a/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php b/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
index c39412bcda..b63f553183 100644
--- a/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
+++ b/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
@@ -779,18 +779,43 @@ public function testRootTransactionEndCallbackCalledOnCommit(): void {
   /**
    * Tests post-transaction callback executes after transaction rollback.
    */
-  public function testRootTransactionEndCallbackCalledOnRollback(): void {
+  public function testRootTransactionEndCallbackCalledAfterRollbackAndDestruction(): void {
     $transaction = $this->createRootTransaction('', FALSE);
     $this->connection->transactionManager()->addPostTransactionCallback([$this, 'rootTransactionCallback']);
     $this->insertRow('row');
     $this->assertNull($this->postTransactionCallbackAction);
     $transaction->rollBack();
+    // Rollback is not itself sufficient to get callbacks processed.
+    $this->assertNull($this->postTransactionCallbackAction);
+    unset($transaction);
+    // Callbacks were processed when destructing the transaction.
     $this->assertSame('rtcRollback', $this->postTransactionCallbackAction);
+    $this->assertRowAbsent('row');
+    // The post-transaction callback should have inserted a 'rtcRollback' row.
+    $this->assertRowPresent('rtcRollback');
+  }
+
+  /**
+   * Tests post-transaction callback executes after a DDL statement.
+   */
+  public function testRootTransactionEndCallbackCalledAfterDdlAndDestruction(): void {
+    $transaction = $this->createRootTransaction('', FALSE);
+    $this->connection->transactionManager()->addPostTransactionCallback([$this, 'rootTransactionCallback']);
+    $this->insertRow('row');
+dump($this->connection->query('SELECT * FROM {test}')->fetchAll());
+    $this->assertNull($this->postTransactionCallbackAction);
+    // Truncate is a DDL statement.
+    $this->connection->truncate('test');
+    // DDL is not sufficient itself to get callbacks processed.
+    $this->assertNull($this->postTransactionCallbackAction);
+dump($this->connection->query('SELECT * FROM {test}')->fetchAll());
     unset($transaction);
+dump($this->connection->query('SELECT * FROM {test}')->fetchAll());
+    // Callbacks were processed when destructing the transaction.
+    $this->assertSame('rtcCommit', $this->postTransactionCallbackAction);
     $this->assertRowAbsent('row');
-    // The row insert should be missing since the client rollback occurs after
-    // the processing of the callbacks.
-    $this->assertRowAbsent('rtcRollback');
+    // The post-transaction callback should have inserted a 'rtcRollback' row.
+    $this->assertRowPresent('rtcCommit');
   }
 
   /**
