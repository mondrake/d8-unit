diff --git a/core/lib/Drupal/Core/Database/Connection.php b/core/lib/Drupal/Core/Database/Connection.php
index 11fa3a6835..24e602907a 100644
--- a/core/lib/Drupal/Core/Database/Connection.php
+++ b/core/lib/Drupal/Core/Database/Connection.php
@@ -4,6 +4,8 @@
 
 use Drupal\Component\Assertion\Inspector;
 use Drupal\Core\Database\Event\DatabaseEvent;
+use Drupal\Core\Database\Event\StatementExecutionEndEvent;
+use Drupal\Core\Database\Event\StatementExecutionStartEvent;
 use Drupal\Core\Database\Exception\EventException;
 use Drupal\Core\Database\Query\Condition;
 use Drupal\Core\Database\Query\Delete;
@@ -665,6 +667,83 @@ public function query($query, array $args = [], $options = []) {
     return $result ? $statement : NULL;
   }
 
+  /**
+   * Executes a data definition language (DDL) statement.
+   *
+   * This method allows to void an active transaction when the driver does
+   * not support transactional DDL.
+   *
+   * @param string $sql
+   *   The DDL statement to execute. This is a SQL string that may contain
+   *   placeholders.
+   * @param array $arguments
+   *   (Optional) The associative array of arguments for the prepared
+   *   statement.
+   * @param array $options
+   *   (Optional) An associative array of options to control how the query is
+   *   run. The given options will be merged with self::defaultOptions().
+   */
+  public function executeDdlStatement(string $sql, array $arguments = [], array $options = []): void {
+    if (count($arguments) > 0) {
+      $this->query($sql, $arguments, $options);
+    }
+    else {
+      $this->executeSql($sql, $options);
+    }
+
+    // DDL statements when in a transaction force a commit in some databases.
+    // Void the transaction in that case.
+    if (!$this->transactionalDDLSupport && $this->transactionManager()->inTransaction()) {
+      $this->transactionManager()->voidClientTransaction();
+    }
+  }
+
+  /**
+   * Executes an SQL statement, directly through the client connection.
+   *
+   * This method does not allow placeholders. It assumes the client connection
+   * is \PDO. Non-PDO based drivers need to override this method.
+   *
+   * @param string $sql
+   *   The SQL statement to execute.
+   * @param array $options
+   *   (Optional) An associative array of options. The given options will be
+   *    merged with self::defaultOptions().
+   */
+  protected function executeSql(string $sql, array $options = []): void {
+    $sql = $this->preprocessStatement($sql, $options);
+    try {
+      if ($this->isEventEnabled(StatementExecutionStartEvent::class)) {
+        $startEvent = new StatementExecutionStartEvent(
+          spl_object_id($this),
+          $this->getKey(),
+          $this->getTarget(),
+          $sql,
+          [],
+          $this->findCallerFromDebugBacktrace()
+        );
+        $this->dispatchEvent($startEvent);
+      }
+
+      $this->getClientConnection()->exec($sql);
+
+      if (isset($startEvent) && $this->isEventEnabled(StatementExecutionEndEvent::class)) {
+        $this->dispatchEvent(new StatementExecutionEndEvent(
+          $startEvent->statementObjectId,
+          $startEvent->key,
+          $startEvent->target,
+          $startEvent->queryString,
+          $startEvent->args,
+          $startEvent->caller,
+          $startEvent->time
+        ));
+      }
+    }
+    catch (\Exception $e) {
+      $this->exceptionHandler()->handleExecuteSqlException($e, $sql, $options);
+    }
+  }
+
   /**
    * Expands out shorthand placeholders.
    *
diff --git a/core/lib/Drupal/Core/Database/ExceptionHandler.php b/core/lib/Drupal/Core/Database/ExceptionHandler.php
index 5dfd41f41c..8acb2f0588 100644
--- a/core/lib/Drupal/Core/Database/ExceptionHandler.php
+++ b/core/lib/Drupal/Core/Database/ExceptionHandler.php
@@ -55,18 +55,52 @@ public function handleStatementException(\Exception $exception, string $sql, arr
    */
   public function handleExecutionException(\Exception $exception, StatementInterface $statement, array $arguments = [], array $options = []): void {
     if ($exception instanceof \PDOException) {
-      // Wrap the exception in another exception, because PHP does not allow
-      // overriding Exception::getMessage(). Its message is the extra database
-      // debug information.
-      $message = $exception->getMessage() . ": " . $statement->getQueryString() . "; " . print_r($arguments, TRUE);
-      // Match all SQLSTATE 23xxx errors.
-      if (substr($exception->getCode(), -6, -3) == '23') {
-        throw new IntegrityConstraintViolationException($message, $exception->getCode(), $exception);
-      }
-      throw new DatabaseExceptionWrapper($message, 0, $exception);
+      $this->throwExecutionException($exception, $exception->getMessage() . ": " . $statement->getQueryString() . "; " . print_r($arguments, TRUE));
     }
+    throw $exception;
+  }
 
+  /**
+   * Handles exceptions thrown during direct execution of an SQL statement.
+   *
+   * @param \Exception $exception
+   *   The exception to be handled.
+   * @param string $sql
+   *   The SQL statement executed.
+   * @param array $options
+   *   An associative array of options to control how the database operation is
+   *   run.
+   *
+   * @throws \Drupal\Core\Database\DatabaseExceptionWrapper
+   * @throws \Drupal\Core\Database\IntegrityConstraintViolationException
+   */
+  public function handleExecuteSqlException(\Exception $exception, string $sql, array $options = []): void {
+    if ($exception instanceof \PDOException) {
+      $this->throwExecutionException($exception, $exception->getMessage() . ": " . $sql);
+    }
     throw $exception;
   }
 
+  /**
+   * Re-throws the appropriate exception.
+   *
+   * @param \Exception $exception
+   *   The exception to be handled.
+   * @param string $message
+   *   The message to be included in the exception.
+   *
+   * @throws \Drupal\Core\Database\DatabaseExceptionWrapper
+   * @throws \Drupal\Core\Database\IntegrityConstraintViolationException
+   */
+  protected function throwExecutionException(\Exception $exception, string $message): void {
+    // Wrap the exception in another exception, because PHP does not allow
+    // overriding Exception::getMessage(). Its message is the extra database
+    // debug information.
+    // Match all SQLSTATE 23xxx errors.
+    if (substr($exception->getCode(), -6, -3) == '23') {
+      throw new IntegrityConstraintViolationException($message, $exception->getCode(), $exception);
+    }
+    throw new DatabaseExceptionWrapper($message, 0, $exception);
+  }
+
 }
diff --git a/core/lib/Drupal/Core/Database/Query/Truncate.php b/core/lib/Drupal/Core/Database/Query/Truncate.php
index 45f1c8447a..e99dd28be8 100644
--- a/core/lib/Drupal/Core/Database/Query/Truncate.php
+++ b/core/lib/Drupal/Core/Database/Query/Truncate.php
@@ -44,13 +44,23 @@ public function __construct(Connection $connection, $table, array $options = [])
    * @see https://learnsql.com/blog/difference-between-truncate-delete-and-drop-table-in-sql
    */
   public function execute() {
-    $stmt = $this->connection->prepareStatement((string) $this, $this->queryOptions, TRUE);
-    try {
-      $stmt->execute([], $this->queryOptions);
-      return $stmt->rowCount();
+    // In most cases, TRUNCATE is not a transaction safe statement as it is a
+    // DDL statement which results in an implicit COMMIT. When we are in a
+    // transaction, fallback to the slower, but transactional, DELETE.
+    // PostgreSQL also locks the entire table for a TRUNCATE strongly reducing
+    // the concurrency with other transactions.
+    if ($this->connection->inTransaction()) {
+      $stmt = $this->connection->prepareStatement((string) $this, $this->queryOptions, TRUE);
+      try {
+        $stmt->execute([], $this->queryOptions);
+        return $stmt->rowCount();
+      }
+      catch (\Exception $e) {
+        $this->connection->exceptionHandler()->handleExecutionException($e, $stmt, [], $this->queryOptions);
+      }
     }
-    catch (\Exception $e) {
-      $this->connection->exceptionHandler()->handleExecutionException($e, $stmt, [], $this->queryOptions);
+    else {
+      $this->connection->executeDdlStatement((string) $this, [], $this->queryOptions);
     }
 
     return NULL;
@@ -66,11 +76,6 @@ public function __toString() {
     // Create a sanitized comment string to prepend to the query.
     $comments = $this->connection->makeComment($this->comments);
 
-    // In most cases, TRUNCATE is not a transaction safe statement as it is a
-    // DDL statement which results in an implicit COMMIT. When we are in a
-    // transaction, fallback to the slower, but transactional, DELETE.
-    // PostgreSQL also locks the entire table for a TRUNCATE strongly reducing
-    // the concurrency with other transactions.
     if ($this->connection->inTransaction()) {
       return $comments . 'DELETE FROM {' . $this->connection->escapeTable($this->table) . '}';
     }
diff --git a/core/lib/Drupal/Core/Database/Schema.php b/core/lib/Drupal/Core/Database/Schema.php
index 9530c8fbf8..a508c4d676 100644
--- a/core/lib/Drupal/Core/Database/Schema.php
+++ b/core/lib/Drupal/Core/Database/Schema.php
@@ -616,7 +616,7 @@ public function createTable($name, $table) {
     }
     $statements = $this->createTableSql($name, $table);
     foreach ($statements as $statement) {
-      $this->connection->query($statement);
+      $this->connection->executeDdlStatement($statement);
     }
   }
 
diff --git a/core/lib/Drupal/Core/Database/Transaction.php b/core/lib/Drupal/Core/Database/Transaction.php
index 617013d7b5..83c2440036 100644
--- a/core/lib/Drupal/Core/Database/Transaction.php
+++ b/core/lib/Drupal/Core/Database/Transaction.php
@@ -35,7 +35,7 @@ public function __construct(
   }
 
   public function __destruct() {
-    $this->connection->transactionManager()->unpile($this->name, $this->id);
+    $this->connection->transactionManager()->purge($this->name, $this->id);
   }
 
   /**
@@ -46,17 +46,30 @@ public function name() {
   }
 
   /**
-   * Rolls back the current transaction.
-   *
-   * This is just a wrapper method to rollback whatever transaction stack we are
-   * currently in, which is managed by the connection object itself. Note that
-   * logging needs to happen after a transaction has been rolled back or the log
-   * messages will be rolled back too.
+   * Rolls back the transaction.
    *
-   * @see \Drupal\Core\Database\Connection::rollBack()
+   * Depending on the state of the transaction stack, this leads to a ROLLBACK
+   * operation (if this transaction is a root one), or to a ROLLBACK TO
+   * SAVEPOINT + a RELEASE SAVEPOINT operations (if this transaction is a
+   * savepoint one).
    */
   public function rollBack() {
     $this->connection->transactionManager()->rollback($this->name, $this->id);
   }
 
+  /**
+   * Commits the transaction.
+   *
+   * Depending on the state of the transaction stack, this leads to a COMMIT
+   * operation (if this transaction is a root one), or to a RELEASE SAVEPOINT
+   * operation (if this transaction is a savepoint one).
+   */
+  public function commit(): void {
+    if (!$this->connection->transactionManager()) {
+      @trigger_error('Calling ' . __METHOD__ . '() with no TransactionManager available is deprecated in drupal:10.3.0 and is removed from drupal:11.0.0. Ensure the database driver implements a TransactionManager. See https://www.drupal.org/node/7654321', E_USER_DEPRECATED);
+      return;
+    }
+    $this->connection->transactionManager()->unpile($this->name, $this->id);
+  }
+
 }
diff --git a/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php b/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php
index 07e727b6a0..e5693f699e 100644
--- a/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php
+++ b/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php
@@ -181,7 +181,9 @@ protected function removeStackItem(string $id): void {
   protected function voidStackItem(string $id): void {
     // The item should be removed from $stack and added to $voidedItems for
     // later processing.
-    $this->voidedItems[$id] = $this->stack[$id];
+    if (isset($this->stack[$id])) {
+      $this->voidedItems[$id] = $this->stack[$id];
+    }
     $this->removeStackItem($id);
   }
 
@@ -259,9 +261,24 @@ public function push(string $name = ''): Transaction {
   }
 
   /**
-   * {@inheritdoc}
+   * Purges a Drupal transaction from the manager.
+   *
+   * This is only called by a Transaction object's ::__destruct() method and
+   * should only be called internally by a database driver.
+   *
+   * @param string $name
+   *   The name of the transaction.
+   * @param string $id
+   *   The id of the transaction.
+   *
+   * @throws \Drupal\Core\Database\TransactionOutOfOrderException
+   *   If a Drupal Transaction with the specified name does not exist.
+   * @throws \Drupal\Core\Database\TransactionCommitFailedException
+   *   If the commit of the root transaction failed.
+   *
+   * @internal
    */
-  public function unpile(string $name, string $id): void {
+  public function purge(string $name, string $id): void {
     // If the $id does not correspond to the one in the stack for that $name,
     // we are facing an orphaned Transaction object (for example in case of a
     // DDL statement breaking an active transaction). That should be listed in
@@ -271,6 +288,49 @@ public function unpile(string $name, string $id): void {
       return;
     }
 
+    // Commit the transaction.
+    $this->commit($name, $id);
+
+    // Remove the transaction from the stack.
+    $this->removeStackItem($id);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function unpile(string $name, string $id): void {
+    // If there is no $id to commit, or if $id does not correspond to the one
+    // in the stack for that $name, the commit is out of order.
+    if (!isset($this->stack()[$id]) || $this->stack()[$id]->name !== $name) {
+      throw new TransactionOutOfOrderException("Error attempting commit of {$id}\\{$name}. Active stack: " . $this->dumpStackItemsAsString());
+    }
+
+    // Commit the transaction.
+    $this->commit($name, $id);
+
+    // Void the transaction stack item.
+    $this->voidStackItem($id);
+  }
+
+  /**
+   * Commits a Drupal transaction.
+   *
+   * @param string $name
+   *   The name of the transaction.
+   * @param string $id
+   *   The id of the transaction.
+   *
+   * @throws \Drupal\Core\Database\TransactionOutOfOrderException
+   *   If a Drupal Transaction with the specified name does not exist.
+   * @throws \Drupal\Core\Database\TransactionCommitFailedException
+   *   If the commit of the root transaction failed.
+   */
+  protected function commit(string $name, string $id): void {
+    if ($this->getConnectionTransactionState() !== ClientConnectionTransactionState::Active) {
+      // The stack got corrupted.
+      throw new TransactionOutOfOrderException("Transaction {$id}\\{$name} is out of order. Active stack: " . $this->dumpStackItemsAsString());
+    }
+
     // If we are not releasing the last savepoint but an earlier one, or
     // committing a root transaction while savepoints are active, all
     // subsequent savepoints will be released as well. The stack must be
@@ -279,29 +339,21 @@ public function unpile(string $name, string $id): void {
       $this->voidStackItem((string) $i);
     }
 
-    if ($this->getConnectionTransactionState() === ClientConnectionTransactionState::Active) {
-      if ($this->stackDepth() > 1 && $this->stack()[$id]->type === StackItemType::Savepoint) {
-        // Release the client transaction savepoint in case the Drupal
-        // transaction is not a root one.
-        $this->releaseClientSavepoint($name);
-      }
-      elseif ($this->stackDepth() === 1 && $this->stack()[$id]->type === StackItemType::Root) {
-        // If this was the root Drupal transaction, we can commit the client
-        // transaction.
-        $this->processRootCommit();
-      }
-      else {
-        // The stack got corrupted.
-        throw new TransactionOutOfOrderException("Transaction {$id}/{$name} is out of order. Active stack: " . $this->dumpStackItemsAsString());
-      }
-
-      // Remove the transaction from the stack.
-      $this->removeStackItem($id);
+    if ($this->stackDepth() > 1 && $this->stack()[$id]->type === StackItemType::Savepoint) {
+      // Release the client transaction savepoint in case the Drupal
+      // transaction is not a root one.
+      $this->releaseClientSavepoint($name);
+      return;
+    }
+    elseif ($this->stackDepth() === 1 && $this->stack()[$id]->type === StackItemType::Root) {
+      // If this was the root Drupal transaction, we can commit the client
+      // transaction.
+      $this->processRootCommit();
       return;
     }
 
     // The stack got corrupted.
-    throw new TransactionOutOfOrderException("Transaction {$id}/{$name} is out of order. Active stack: " . $this->dumpStackItemsAsString());
+    throw new TransactionOutOfOrderException("Transaction {$id}\\{$name} is out of order. Active stack: " . $this->dumpStackItemsAsString());
   }
 
   /**
diff --git a/core/lib/Drupal/Core/Database/Transaction/TransactionManagerInterface.php b/core/lib/Drupal/Core/Database/Transaction/TransactionManagerInterface.php
index 5fccb620bb..32ea6860a6 100644
--- a/core/lib/Drupal/Core/Database/Transaction/TransactionManagerInterface.php
+++ b/core/lib/Drupal/Core/Database/Transaction/TransactionManagerInterface.php
@@ -53,8 +53,8 @@ public function push(string $name = ''): Transaction;
    * Removes a Drupal transaction from the stack.
    *
    * The unpiled item does not necessarily need to be the last on the stack.
-   * This method should only be called by a Transaction object going out of
-   * scope.
+   * This method should only be called by a Transaction object's ::commit()
+   * method.
    *
    * This method should only be called internally by a database driver.
    *
diff --git a/core/lib/Drupal/Core/Test/SimpletestTestRunResultsStorage.php b/core/lib/Drupal/Core/Test/SimpletestTestRunResultsStorage.php
index 9d07e8273a..4e651d9222 100644
--- a/core/lib/Drupal/Core/Test/SimpletestTestRunResultsStorage.php
+++ b/core/lib/Drupal/Core/Test/SimpletestTestRunResultsStorage.php
@@ -95,13 +95,14 @@ public function insertLogEntry(TestRun $test_run, array $entry): bool {
    * {@inheritdoc}
    */
   public function removeResults(TestRun $test_run): int {
-    $this->connection->startTransaction('delete_test_run');
+    $transaction = $this->connection->startTransaction('delete_test_run');
     $this->connection->delete('simpletest')
       ->condition('test_id', $test_run->id())
       ->execute();
     $count = $this->connection->delete('simpletest_test_id')
       ->condition('test_id', $test_run->id())
       ->execute();
+    $transaction->commit();
     return $count;
   }
 
@@ -169,9 +170,10 @@ public function validateTestingResultsEnvironment(): bool {
    */
   public function cleanUp(): int {
     // Clear test results.
-    $this->connection->startTransaction('delete_simpletest');
+    $transaction = $this->connection->startTransaction('delete_simpletest');
     $this->connection->delete('simpletest')->execute();
     $count = $this->connection->delete('simpletest_test_id')->execute();
+    $transaction->commit();
     return $count;
   }
 
diff --git a/core/modules/mysql/src/Driver/Database/mysql/ExceptionHandler.php b/core/modules/mysql/src/Driver/Database/mysql/ExceptionHandler.php
index 7926175e0d..d06a35ce16 100644
--- a/core/modules/mysql/src/Driver/Database/mysql/ExceptionHandler.php
+++ b/core/modules/mysql/src/Driver/Database/mysql/ExceptionHandler.php
@@ -8,7 +8,6 @@
 use Drupal\Core\Database\Exception\SchemaTableColumnSizeTooLargeException;
 use Drupal\Core\Database\Exception\SchemaTableKeyTooLargeException;
 use Drupal\Core\Database\IntegrityConstraintViolationException;
-use Drupal\Core\Database\StatementInterface;
 
 /**
  * MySql database exception handler class.
@@ -18,45 +17,39 @@ class ExceptionHandler extends BaseExceptionHandler {
   /**
    * {@inheritdoc}
    */
-  public function handleExecutionException(\Exception $exception, StatementInterface $statement, array $arguments = [], array $options = []): void {
-    if ($exception instanceof \PDOException) {
-      // Wrap the exception in another exception, because PHP does not allow
-      // overriding Exception::getMessage(). Its message is the extra database
-      // debug information.
-      $code = is_int($exception->getCode()) ? $exception->getCode() : 0;
-
-      // If a max_allowed_packet error occurs the message length is truncated.
-      // This should prevent the error from recurring if the exception is logged
-      // to the database using dblog or the like.
-      if (($exception->errorInfo[1] ?? NULL) === 1153) {
-        $message = Unicode::truncateBytes($exception->getMessage(), Connection::MIN_MAX_ALLOWED_PACKET);
-        throw new DatabaseExceptionWrapper($message, $code, $exception);
-      }
-
-      $message = $exception->getMessage() . ": " . $statement->getQueryString() . "; " . print_r($arguments, TRUE);
-
-      // SQLSTATE 23xxx errors indicate an integrity constraint violation. Also,
-      // in case of attempted INSERT of a record with an undefined column and no
-      // default value indicated in schema, MySql returns a 1364 error code.
-      if (
-        substr($exception->getCode(), -6, -3) == '23' ||
-        ($exception->errorInfo[1] ?? NULL) === 1364
-      ) {
-        throw new IntegrityConstraintViolationException($message, $code, $exception);
-      }
-
-      if ($exception->getCode() === '42000') {
-        match ($exception->errorInfo[1]) {
-          1071 => throw new SchemaTableKeyTooLargeException($message, $code, $exception),
-          1074 => throw new SchemaTableColumnSizeTooLargeException($message, $code, $exception),
-          default => throw new DatabaseExceptionWrapper($message, 0, $exception),
-        };
-      }
-
-      throw new DatabaseExceptionWrapper($message, 0, $exception);
+  protected function throwExecutionException(\Exception $exception, string $message): void {
+    // Wrap the exception in another exception, because PHP does not allow
+    // overriding Exception::getMessage(). Its message is the extra database
+    // debug information.
+    $code = is_int($exception->getCode()) ? $exception->getCode() : 0;
+
+    // If a max_allowed_packet error occurs the message length is truncated.
+    // This should prevent the error from recurring if the exception is logged
+    // to the database using dblog or the like.
+    if (($exception->errorInfo[1] ?? NULL) === 1153) {
+      $message = Unicode::truncateBytes($exception->getMessage(), Connection::MIN_MAX_ALLOWED_PACKET);
+      throw new DatabaseExceptionWrapper($message, $code, $exception);
     }
 
-    throw $exception;
+    // SQLSTATE 23xxx errors indicate an integrity constraint violation. Also,
+    // in case of attempted INSERT of a record with an undefined column and no
+    // default value indicated in schema, MySql returns a 1364 error code.
+    if (
+      substr($exception->getCode(), -6, -3) == '23' ||
+      ($exception->errorInfo[1] ?? NULL) === 1364
+    ) {
+      throw new IntegrityConstraintViolationException($message, $code, $exception);
+    }
+
+    if ($exception->getCode() === '42000') {
+      match ($exception->errorInfo[1]) {
+        1071 => throw new SchemaTableKeyTooLargeException($message, $code, $exception),
+        1074 => throw new SchemaTableColumnSizeTooLargeException($message, $code, $exception),
+        default => throw new DatabaseExceptionWrapper($message, 0, $exception),
+      };
+    }
+
+    throw new DatabaseExceptionWrapper($message, 0, $exception);
   }
 
 }
diff --git a/core/modules/mysql/src/Driver/Database/mysql/Schema.php b/core/modules/mysql/src/Driver/Database/mysql/Schema.php
index 6fdcad7047..8f9b3980bf 100644
--- a/core/modules/mysql/src/Driver/Database/mysql/Schema.php
+++ b/core/modules/mysql/src/Driver/Database/mysql/Schema.php
@@ -380,7 +380,7 @@ public function renameTable($table, $new_name) {
     }
 
     $info = $this->getPrefixInfo($new_name);
-    $this->connection->query('ALTER TABLE {' . $table . '} RENAME TO [' . $info['table'] . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} RENAME TO [' . $info['table'] . ']');
   }
 
   /**
@@ -391,7 +391,7 @@ public function dropTable($table) {
       return FALSE;
     }
 
-    $this->connection->query('DROP TABLE {' . $table . '}');
+    $this->connection->executeDdlStatement('DROP TABLE {' . $table . '}');
     return TRUE;
   }
 
@@ -430,14 +430,14 @@ public function addField($table, $field, $spec, $keys_new = []) {
       $query .= ', ADD ' . implode(', ADD ', $keys_sql);
     }
     try {
-      $this->connection->query($query);
+      $this->connection->executeDdlStatement($query);
     }
     catch (DatabaseExceptionWrapper $e) {
       // MySQL error number 4111 (ER_DROP_PK_COLUMN_TO_DROP_GIPK) indicates that
       // when dropping and adding a primary key, the generated invisible primary
       // key (GIPK) column must also be dropped.
       if (isset($e->getPrevious()->errorInfo[1]) && $e->getPrevious()->errorInfo[1] === 4111 && isset($keys_new['primary key']) && $this->indexExists($table, 'PRIMARY') && $this->findPrimaryKeyColumns($table) === ['my_row_id']) {
-        $this->connection->query($query . ', DROP COLUMN [my_row_id]');
+        $this->connection->executeDdlStatement($query . ', DROP COLUMN [my_row_id]');
       }
       else {
         throw $e;
@@ -488,7 +488,7 @@ public function dropField($table, $field) {
       $this->dropPrimaryKey($table);
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP [' . $field . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP [' . $field . ']');
     return TRUE;
   }
 
@@ -513,7 +513,7 @@ public function addPrimaryKey($table, $fields) {
       throw new SchemaObjectExistsException("Cannot add primary key to table '$table': primary key already exists.");
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD PRIMARY KEY (' . $this->createKeySql($fields) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD PRIMARY KEY (' . $this->createKeySql($fields) . ')');
   }
 
   /**
@@ -524,7 +524,7 @@ public function dropPrimaryKey($table) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP PRIMARY KEY');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP PRIMARY KEY');
     return TRUE;
   }
 
@@ -550,7 +550,7 @@ public function addUniqueKey($table, $name, $fields) {
       throw new SchemaObjectExistsException("Cannot add unique key '$name' to table '$table': unique key already exists.");
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD UNIQUE KEY [' . $name . '] (' . $this->createKeySql($fields) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD UNIQUE KEY [' . $name . '] (' . $this->createKeySql($fields) . ')');
   }
 
   /**
@@ -561,7 +561,7 @@ public function dropUniqueKey($table, $name) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP KEY [' . $name . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP KEY [' . $name . ']');
     return TRUE;
   }
 
@@ -579,7 +579,7 @@ public function addIndex($table, $name, $fields, array $spec) {
     $spec['indexes'][$name] = $fields;
     $indexes = $this->getNormalizedIndexes($spec);
 
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD INDEX [' . $name . '] (' . $this->createKeySql($indexes[$name]) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD INDEX [' . $name . '] (' . $this->createKeySql($indexes[$name]) . ')');
   }
 
   /**
@@ -590,7 +590,7 @@ public function dropIndex($table, $name) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP INDEX [' . $name . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP INDEX [' . $name . ']');
     return TRUE;
   }
 
@@ -642,11 +642,11 @@ public function changeField($table, $field, $field_new, $spec, $keys_new = []) {
     if ($keys_sql = $this->createKeysSql($keys_new)) {
       $sql .= ', ADD ' . implode(', ADD ', $keys_sql);
     }
-    $this->connection->query($sql);
+    $this->connection->executeDdlStatement($sql);
 
     if ($spec['type'] === 'serial') {
       $max = $this->connection->query('SELECT MAX(`' . $field_new . '`) FROM {' . $table . '}')->fetchField();
-      $this->connection->query("ALTER TABLE {" . $table . "} AUTO_INCREMENT = " . ($max + 1));
+      $this->connection->executeDdlStatement("ALTER TABLE {" . $table . "} AUTO_INCREMENT = " . ($max + 1));
     }
   }
 
diff --git a/core/modules/pgsql/src/Driver/Database/pgsql/Schema.php b/core/modules/pgsql/src/Driver/Database/pgsql/Schema.php
index e55a6ffa40..4e7fdc72d7 100644
--- a/core/modules/pgsql/src/Driver/Database/pgsql/Schema.php
+++ b/core/modules/pgsql/src/Driver/Database/pgsql/Schema.php
@@ -589,7 +589,7 @@ public function renameTable($table, $new_name) {
       // The renaming of an index will fail when the there exists an table with
       // the same name as the renamed index.
       if (!$this->tableExists($this->ensureIdentifiersLength($new_name, $index_name, $index_type), FALSE)) {
-        $this->connection->query('ALTER INDEX "' . $this->defaultSchema . '"."' . $index->indexname . '" RENAME TO ' . $this->ensureIdentifiersLength($new_name, $index_name, $index_type));
+        $this->connection->executeDdlStatement('ALTER INDEX "' . $this->defaultSchema . '"."' . $index->indexname . '" RENAME TO ' . $this->ensureIdentifiersLength($new_name, $index_name, $index_type));
       }
     }
 
@@ -612,11 +612,11 @@ public function renameTable($table, $new_name) {
         // subsequent table renames.
         $new_sequence = $this->ensureIdentifiersLength($new_name, $field, 'seq', '_');
 
-        $this->connection->query('ALTER SEQUENCE ' . $old_sequence . ' RENAME TO ' . $new_sequence);
+        $this->connection->executeDdlStatement('ALTER SEQUENCE ' . $old_sequence . ' RENAME TO ' . $new_sequence);
       }
     }
     // Now rename the table.
-    $this->connection->query('ALTER TABLE {' . $table . '} RENAME TO ' . $prefixInfo['table']);
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} RENAME TO ' . $prefixInfo['table']);
     $this->resetTableInformation($table);
   }
 
@@ -628,7 +628,7 @@ public function dropTable($table) {
       return FALSE;
     }
 
-    $this->connection->query('DROP TABLE {' . $table . '}');
+    $this->connection->executeDdlStatement('DROP TABLE {' . $table . '}');
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -657,7 +657,7 @@ public function addField($table, $field, $spec, $new_keys = []) {
     }
     $query = 'ALTER TABLE {' . $table . '} ADD COLUMN ';
     $query .= $this->createFieldSql($field, $this->processField($spec));
-    $this->connection->query($query);
+    $this->connection->executeDdlStatement($query);
     if (isset($spec['initial_from_field'])) {
       if (isset($spec['initial'])) {
         $expression = 'COALESCE(' . $spec['initial_from_field'] . ', :default_initial_value)';
@@ -677,7 +677,7 @@ public function addField($table, $field, $spec, $new_keys = []) {
         ->execute();
     }
     if ($fix_null) {
-      $this->connection->query("ALTER TABLE {" . $table . "} ALTER $field SET NOT NULL");
+      $this->connection->executeDdlStatement("ALTER TABLE {" . $table . "} ALTER $field SET NOT NULL");
     }
     if (isset($new_keys)) {
       // Make sure to drop the existing primary key before adding a new one.
@@ -690,7 +690,7 @@ public function addField($table, $field, $spec, $new_keys = []) {
     }
     // Add column comment.
     if (!empty($spec['description'])) {
-      $this->connection->query('COMMENT ON COLUMN {' . $table . '}.' . $field . ' IS ' . $this->prepareComment($spec['description']));
+      $this->connection->executeDdlStatement('COMMENT ON COLUMN {' . $table . '}.' . $field . ' IS ' . $this->prepareComment($spec['description']));
     }
     $this->resetTableInformation($table);
   }
@@ -703,7 +703,7 @@ public function dropField($table, $field) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP COLUMN "' . $field . '"');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP COLUMN "' . $field . '"');
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -777,7 +777,7 @@ public function addPrimaryKey($table, $fields) {
       throw new SchemaObjectExistsException("Cannot add primary key to table '$table': primary key already exists.");
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD CONSTRAINT ' . $this->ensureIdentifiersLength($table, '', 'pkey') . ' PRIMARY KEY (' . $this->createPrimaryKeySql($fields) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD CONSTRAINT ' . $this->ensureIdentifiersLength($table, '', 'pkey') . ' PRIMARY KEY (' . $this->createPrimaryKeySql($fields) . ')');
     $this->resetTableInformation($table);
   }
 
@@ -789,7 +789,7 @@ public function dropPrimaryKey($table) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP CONSTRAINT ' . $this->ensureIdentifiersLength($table, '', 'pkey'));
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP CONSTRAINT ' . $this->ensureIdentifiersLength($table, '', 'pkey'));
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -818,7 +818,7 @@ public function addUniqueKey($table, $name, $fields) {
     // Use the createPrimaryKeySql(), which already discards any prefix lengths
     // passed as part of the key column specifiers. (Postgres doesn't support
     // setting a prefix length for PRIMARY or UNIQUE indices.)
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD CONSTRAINT ' . $this->ensureIdentifiersLength($table, $name, 'key') . ' UNIQUE (' . $this->createPrimaryKeySql($fields) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD CONSTRAINT ' . $this->ensureIdentifiersLength($table, $name, 'key') . ' UNIQUE (' . $this->createPrimaryKeySql($fields) . ')');
     $this->resetTableInformation($table);
   }
 
@@ -830,7 +830,7 @@ public function dropUniqueKey($table, $name) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP CONSTRAINT ' . $this->ensureIdentifiersLength($table, $name, 'key'));
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP CONSTRAINT ' . $this->ensureIdentifiersLength($table, $name, 'key'));
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -846,7 +846,7 @@ public function addIndex($table, $name, $fields, array $spec) {
       throw new SchemaObjectExistsException("Cannot add index '$name' to table '$table': index already exists.");
     }
 
-    $this->connection->query($this->_createIndexSql($table, $name, $fields));
+    $this->connection->executeDdlStatement($this->_createIndexSql($table, $name, $fields));
     $this->resetTableInformation($table);
   }
 
@@ -858,7 +858,7 @@ public function dropIndex($table, $name) {
       return FALSE;
     }
 
-    $this->connection->query('DROP INDEX ' . $this->defaultSchema . '.' . $this->ensureIdentifiersLength($table, $name, 'idx'));
+    $this->connection->executeDdlStatement('DROP INDEX ' . $this->defaultSchema . '.' . $this->ensureIdentifiersLength($table, $name, 'idx'));
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -937,15 +937,15 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
     if (!empty($seq_name)) {
       // We need to add CASCADE otherwise we cannot alter the sequence because
       // the table depends on it.
-      $this->connection->query('DROP SEQUENCE IF EXISTS ' . $seq_name . ' CASCADE');
+      $this->connection->executeDdlStatement('DROP SEQUENCE IF EXISTS ' . $seq_name . ' CASCADE');
     }
 
     foreach ($field_info as $check) {
-      $this->connection->query('ALTER TABLE {' . $table . '} DROP CONSTRAINT [' . $check . ']');
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP CONSTRAINT [' . $check . ']');
     }
 
     // Remove old default.
-    $this->connection->query('ALTER TABLE {' . $table . '} ALTER COLUMN [' . $field . '] DROP DEFAULT');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER COLUMN [' . $field . '] DROP DEFAULT');
 
     // Convert field type.
     // Usually, we do this via a simple typecast 'USING fieldname::type'. But
@@ -955,10 +955,10 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
     $is_bytea = !empty($table_information->blob_fields[$field]);
     if ($spec['pgsql_type'] != 'bytea') {
       if ($is_bytea) {
-        $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING convert_from([' . $field . ']' . ", 'UTF8')");
+        $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING convert_from([' . $field . ']' . ", 'UTF8')");
       }
       else {
-        $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING [' . $field . ']::' . $field_def);
+        $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING [' . $field . ']::' . $field_def);
       }
     }
     else {
@@ -967,7 +967,7 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
         // Convert to a bytea type by using the SQL replace() function to
         // convert any single backslashes in the field content to double
         // backslashes ('\' to '\\').
-        $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING decode(replace("' . $field . '"' . ", E'\\\\', E'\\\\\\\\'), 'escape');");
+        $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING decode(replace("' . $field . '"' . ", E'\\\\', E'\\\\\\\\'), 'escape');");
       }
     }
 
@@ -978,7 +978,7 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
       else {
         $null_action = 'DROP NOT NULL';
       }
-      $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] ' . $null_action);
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] ' . $null_action);
     }
 
     if (in_array($spec['pgsql_type'], ['serial', 'bigserial'])) {
@@ -986,31 +986,31 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
       // not when altering. Because of that, the sequence needs to be created
       // and initialized by hand.
       $seq = $this->connection->makeSequenceName($table, $field_new);
-      $this->connection->query("CREATE SEQUENCE " . $seq . " OWNED BY {" . $table . "}.[" . $field_new . ']');
+      $this->connection->executeDdlStatement("CREATE SEQUENCE " . $seq . " OWNED BY {" . $table . "}.[" . $field_new . ']');
       // Set sequence to maximal field value to not conflict with existing
       // entries.
       $this->connection->query("SELECT setval('" . $seq . "', MAX([" . $field . "])) FROM {" . $table . "}");
-      $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] SET DEFAULT nextval(' . $this->connection->quote($seq) . ')');
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] SET DEFAULT nextval(' . $this->connection->quote($seq) . ')');
     }
 
     // Rename the column if necessary.
     if ($field != $field_new) {
-      $this->connection->query('ALTER TABLE {' . $table . '} RENAME [' . $field . '] TO [' . $field_new . ']');
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} RENAME [' . $field . '] TO [' . $field_new . ']');
     }
 
     // Add unsigned check if necessary.
     if (!empty($spec['unsigned'])) {
-      $this->connection->query('ALTER TABLE {' . $table . '} ADD CHECK ([' . $field_new . '] >= 0)');
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD CHECK ([' . $field_new . '] >= 0)');
     }
 
     // Add default if necessary.
     if (isset($spec['default'])) {
-      $this->connection->query('ALTER TABLE {' . $table . '} ALTER COLUMN [' . $field_new . '] SET DEFAULT ' . $this->escapeDefaultValue($spec['default']));
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER COLUMN [' . $field_new . '] SET DEFAULT ' . $this->escapeDefaultValue($spec['default']));
     }
 
     // Change description if necessary.
     if (!empty($spec['description'])) {
-      $this->connection->query('COMMENT ON COLUMN {' . $table . '}.[' . $field_new . '] IS ' . $this->prepareComment($spec['description']));
+      $this->connection->executeDdlStatement('COMMENT ON COLUMN {' . $table . '}.[' . $field_new . '] IS ' . $this->prepareComment($spec['description']));
     }
 
     if (isset($new_keys)) {
diff --git a/core/modules/sqlite/src/Driver/Database/sqlite/Schema.php b/core/modules/sqlite/src/Driver/Database/sqlite/Schema.php
index 64bdffa8c8..4531e34cc7 100644
--- a/core/modules/sqlite/src/Driver/Database/sqlite/Schema.php
+++ b/core/modules/sqlite/src/Driver/Database/sqlite/Schema.php
@@ -272,7 +272,7 @@ public function renameTable($table, $new_name) {
     // the table with curly braces in case the db_prefix contains a reference
     // to a database outside of our existing database.
     $info = $this->getPrefixInfo($new_name);
-    $this->connection->query('ALTER TABLE {' . $table . '} RENAME TO [' . $info['table'] . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} RENAME TO [' . $info['table'] . ']');
 
     // Drop the indexes, there is no RENAME INDEX command in SQLite.
     if (!empty($schema['unique keys'])) {
@@ -289,7 +289,7 @@ public function renameTable($table, $new_name) {
     // Recreate the indexes.
     $statements = $this->createIndexSql($new_name, $schema);
     foreach ($statements as $statement) {
-      $this->connection->query($statement);
+      $this->connection->executeDdlStatement($statement);
     }
   }
 
@@ -301,7 +301,7 @@ public function dropTable($table) {
       return FALSE;
     }
     $this->connection->tableDropped = TRUE;
-    $this->connection->query('DROP TABLE {' . $table . '}');
+    $this->connection->executeDdlStatement('DROP TABLE {' . $table . '}');
     return TRUE;
   }
 
@@ -326,7 +326,7 @@ public function addField($table, $field, $specification, $keys_new = []) {
       // When we don't have to create new keys and we are not creating a
       // NOT NULL column without a default value, we can use the quicker version.
       $query = 'ALTER TABLE {' . $table . '} ADD ' . $this->createFieldSql($field, $this->processField($specification));
-      $this->connection->query($query);
+      $this->connection->executeDdlStatement($query);
 
       // Apply the initial value if set.
       if (isset($specification['initial_from_field'])) {
@@ -683,7 +683,7 @@ public function addIndex($table, $name, $fields, array $spec) {
     $schema['indexes'][$name] = $fields;
     $statements = $this->createIndexSql($table, $schema);
     foreach ($statements as $statement) {
-      $this->connection->query($statement);
+      $this->connection->executeDdlStatement($statement);
     }
   }
 
@@ -706,7 +706,7 @@ public function dropIndex($table, $name) {
 
     $info = $this->getPrefixInfo($table);
 
-    $this->connection->query('DROP INDEX [' . $info['schema'] . '].[' . $info['table'] . '_' . $name . ']');
+    $this->connection->executeDdlStatement('DROP INDEX [' . $info['schema'] . '].[' . $info['table'] . '_' . $name . ']');
     return TRUE;
   }
 
@@ -724,7 +724,7 @@ public function addUniqueKey($table, $name, $fields) {
     $schema['unique keys'][$name] = $fields;
     $statements = $this->createIndexSql($table, $schema);
     foreach ($statements as $statement) {
-      $this->connection->query($statement);
+      $this->connection->executeDdlStatement($statement);
     }
   }
 
@@ -738,7 +738,7 @@ public function dropUniqueKey($table, $name) {
 
     $info = $this->getPrefixInfo($table);
 
-    $this->connection->query('DROP INDEX [' . $info['schema'] . '].[' . $info['table'] . '_' . $name . ']');
+    $this->connection->executeDdlStatement('DROP INDEX [' . $info['schema'] . '].[' . $info['table'] . '_' . $name . ']');
     return TRUE;
   }
 
diff --git a/core/tests/Drupal/KernelTests/Core/Cache/EndOfTransactionQueriesTest.php b/core/tests/Drupal/KernelTests/Core/Cache/EndOfTransactionQueriesTest.php
index a50b2827f5..2874b559dc 100644
--- a/core/tests/Drupal/KernelTests/Core/Cache/EndOfTransactionQueriesTest.php
+++ b/core/tests/Drupal/KernelTests/Core/Cache/EndOfTransactionQueriesTest.php
@@ -71,21 +71,21 @@ public function testEntitySave(): void {
     Database::startLog('testEntitySave');
     $entity->save();
 
+    // Entity save should have deferred cache invalidation to after transaction
+    // completion for the "entity_test_list", "entity_test_list:entity_test",
+    // "4xx-response" and "user_list" tags. Since cache invalidation is a MERGE
+    // database operation, and in core drivers each MERGE is split in two
+    // consecutive SELECT and INSERT|UPDATE operations, we expect 8 logged
+    // database queries to be related to the {cachetags} table, near the end of
+    // the log stack, and no INSERT or UPDATE operation afterwards.
     $executed_statements = [];
     foreach (Database::getLog('testEntitySave') as $log) {
-      // Exclude transaction related statements from the log.
-      if (
-        str_starts_with($log['query'], 'ROLLBACK TO SAVEPOINT ') ||
-        str_starts_with($log['query'], 'RELEASE SAVEPOINT ') ||
-        str_starts_with($log['query'], 'SAVEPOINT ')
-      ) {
-        continue;
-      }
       $executed_statements[] = $log['query'];
     }
-    $last_statement_index = max(array_keys($executed_statements));
-    $cachetag_statements = array_keys($this->getStatementsForTable($executed_statements, 'cachetags'));
-    $this->assertSame($last_statement_index - count($cachetag_statements) + 1, min($cachetag_statements), 'All of the last queries in the transaction are for the "cachetags" table.');
+    $cachetag_statements = $this->getStatementsForTable($executed_statements, 'cachetags');
+    $this->assertCount(8, $cachetag_statements);
+    $tail_statements = array_slice($executed_statements, array_key_last($cachetag_statements) + 1);
+    $this->assertNoDmlStatement($tail_statements);
 
     // Verify that a nested entity save occurred.
     $this->assertSame('john doe', User::load(1)->getAccountName());
@@ -182,4 +182,21 @@ protected static function isStatementRelatedToTable(string $statement, string $t
     return preg_match($pattern, $statement) === 1 ? TRUE : FALSE;
   }
 
+  /**
+   * Asserts that an array of SQL statements is not DML instructions.
+   *
+   * INSERT and UPDATE are DML (Data Manipulation Language) statements.
+   *
+   * @param string[] $statements
+   *   The query statements.
+   */
+  protected static function assertNoDmlStatement(array $statements): void {
+    $pattern = '/.*(INSERT|UPDATE|DELETE|MERGE)/';
+    foreach ($statements as $statement) {
+      if (preg_match($pattern, $statement) === 0) {
+        self::fail("Unexpected DML statement: {$statement}");
+      }
+    }
+  }
+
 }
diff --git a/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php b/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
index 7edbc7a9b1..49d7338643 100644
--- a/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
+++ b/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
@@ -10,7 +10,6 @@
 use Drupal\Core\Database\Transaction\TransactionManagerBase;
 use Drupal\Core\Database\TransactionNameNonUniqueException;
 use Drupal\Core\Database\TransactionOutOfOrderException;
-use PHPUnit\Framework\Error\Warning;
 
 /**
  * Tests the transaction abstraction system.
@@ -248,6 +247,9 @@ public function testRollbackRootWithActiveSavepoint(): void {
 
   /**
    * Tests savepoint transaction rollback.
+   *
+   * @todo change this test to legacy once commit-on-destruct is deprecated.
+   *   Replaced by ::testRollbackSavepointExplicitCommit().
    */
   public function testRollbackSavepoint(): void {
     $transaction = $this->createRootTransaction();
@@ -273,6 +275,93 @@ public function testRollbackSavepoint(): void {
     $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
   }
 
+  /**
+   * Tests savepoint transaction commit after rollback.
+   *
+   * @todo change this test to legacy once commit-on-destruct is deprecated.
+   *   Replaced by ::testCommitAfterRollbackSameSavepointExplicitCommit().
+   */
+  public function testCommitAfterRollbackSameSavepoint(): void {
+    $transaction = $this->createRootTransaction();
+    $savepoint = $this->createFirstSavepointTransaction();
+
+    // Rollback savepoint. It should get released too. Corresponds to 'ROLLBACK
+    // TO savepoint_1' plus 'RELEASE savepoint_1' on the database.
+    $savepoint->rollBack();
+    $this->assertRowPresent('David');
+    $this->assertRowAbsent('Roger');
+    $this->assertTrue($this->connection->inTransaction());
+    $this->assertSame(1, $this->connection->transactionManager()->stackDepth());
+
+    // Insert a row.
+    $this->insertRow('Syd');
+
+    // Try committing savepoint. Should fail since it was released already.
+    try {
+      $savepoint->commit();
+      $this->fail('Expected TransactionOutOfOrderException was not thrown');
+    }
+    catch (\Exception $e) {
+      $this->assertInstanceOf(TransactionOutOfOrderException::class, $e);
+      $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\savepoint_1\\. Active stack: .*\\\\drupal_transaction/", $e->getMessage());
+    }
+    $this->assertRowPresent('David');
+    $this->assertRowAbsent('Roger');
+    $this->assertRowPresent('Syd');
+    $this->assertTrue($this->connection->inTransaction());
+    $this->assertSame(1, $this->connection->transactionManager()->stackDepth());
+
+    // Commit root. Corresponds to 'COMMIT' on the database.
+    unset($transaction);
+    $this->assertRowPresent('David');
+    $this->assertRowAbsent('Roger');
+    $this->assertRowPresent('Syd');
+    $this->assertFalse($this->connection->inTransaction());
+    $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
+  }
+
+  /**
+   * Tests savepoint transaction rollback after commit.
+   */
+  public function testRollbackAfterCommitSameSavepoint(): void {
+    $transaction = $this->createRootTransaction();
+    $savepoint = $this->createFirstSavepointTransaction();
+
+    // Commit savepoint. It should get released too. Corresponds to 'RELEASE
+    // savepoint_1' on the database.
+    $savepoint->commit();
+    $this->assertRowPresent('David');
+    $this->assertRowPresent('Roger');
+    $this->assertTrue($this->connection->inTransaction());
+    $this->assertSame(1, $this->connection->transactionManager()->stackDepth());
+
+    // Insert a row.
+    $this->insertRow('Syd');
+
+    // Try rolling back savepoint. Should fail since it was released already.
+    try {
+      $savepoint->rollback();
+      $this->fail('Expected TransactionOutOfOrderException was not thrown');
+    }
+    catch (\Exception $e) {
+      $this->assertInstanceOf(TransactionOutOfOrderException::class, $e);
+      $this->assertMatchesRegularExpression("/^Error attempting rollback of .*\\\\savepoint_1\\. Active stack: .*\\\\drupal_transaction/", $e->getMessage());
+    }
+    $this->assertRowPresent('David');
+    $this->assertRowPresent('Roger');
+    $this->assertRowPresent('Syd');
+    $this->assertTrue($this->connection->inTransaction());
+    $this->assertSame(1, $this->connection->transactionManager()->stackDepth());
+
+    // Commit root. Corresponds to 'COMMIT' on the database.
+    $transaction->commit();
+    $this->assertRowPresent('David');
+    $this->assertRowPresent('Roger');
+    $this->assertRowPresent('Syd');
+    $this->assertFalse($this->connection->inTransaction());
+    $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
+  }
+
   /**
    * Tests savepoint transaction duplicated rollback.
    */
@@ -332,6 +421,52 @@ public function testRollbackSavepointWithLaterSavepoint(): void {
     $savepoint1->rollBack();
   }
 
+  /**
+   * Tests commit after DDL.
+   */
+  public function testCommitAfterDdl(): void {
+    $transaction = $this->createRootTransaction();
+    $savepoint = $this->createFirstSavepointTransaction();
+
+    $this->executeDDLStatement();
+
+    // For database servers that do not support transactional DDL, the entire
+    // client transaction was auto-committed.
+    $this->assertRowPresent('David');
+    $this->assertRowPresent('Roger');
+    if ($this->connection->supportsTransactionalDDL()) {
+      $this->assertTrue($this->connection->inTransaction());
+      $this->assertSame(2, $this->connection->transactionManager()->stackDepth());
+    }
+    else {
+      $this->assertFalse($this->connection->inTransaction());
+    }
+
+    // For database servers that do not support transactional DDL, we can not
+    // commit something that was auto-committed already.
+    if ($this->connection->supportsTransactionalDDL()) {
+      $savepoint->commit();
+    }
+    $this->assertRowPresent('David');
+    $this->assertRowPresent('Roger');
+    if ($this->connection->supportsTransactionalDDL()) {
+      $this->assertTrue($this->connection->inTransaction());
+      $this->assertSame(1, $this->connection->transactionManager()->stackDepth());
+    }
+    else {
+      $this->assertFalse($this->connection->inTransaction());
+    }
+
+    // For database servers that do not support transactional DDL, we can not
+    // commit something that was auto-committed already.
+    if ($this->connection->supportsTransactionalDDL()) {
+      $transaction->commit();
+    }
+    $this->assertRowPresent('David');
+    $this->assertRowPresent('Roger');
+    $this->assertFalse($this->connection->inTransaction());
+  }
+
   /**
    * Tests a committed transaction.
    *
@@ -356,14 +491,16 @@ public function testCommittedTransaction(): void {
 
   /**
    * Tests the compatibility of transactions with DDL statements.
+   *
+   * @todo change this test to legacy once commit-on-destruct is deprecated.
+   *   Replaced by ::testTransactionWithDdlStatementExplicitCommit().
    */
   public function testTransactionWithDdlStatement(): void {
     // First, test that a commit works normally, even with DDL statements.
-    $transaction = $this->createRootTransaction('', FALSE);
-    $this->insertRow('row');
+    $transaction = $this->createRootTransaction();
     $this->executeDDLStatement();
     unset($transaction);
-    $this->assertRowPresent('row');
+    $this->assertRowPresent('David');
 
     // Even in different order.
     $this->cleanUp();
@@ -375,8 +512,8 @@ public function testTransactionWithDdlStatement(): void {
 
     // Even with stacking.
     $this->cleanUp();
-    $transaction = $this->createRootTransaction('', FALSE);
-    $transaction2 = $this->createFirstSavepointTransaction('', FALSE);
+    $transaction = $this->createRootTransaction();
+    $transaction2 = $this->createFirstSavepointTransaction();
     $this->executeDDLStatement();
     unset($transaction2);
     $transaction3 = $this->connection->startTransaction();
@@ -387,8 +524,8 @@ public function testTransactionWithDdlStatement(): void {
 
     // A transaction after a DDL statement should still work the same.
     $this->cleanUp();
-    $transaction = $this->createRootTransaction('', FALSE);
-    $transaction2 = $this->createFirstSavepointTransaction('', FALSE);
+    $transaction = $this->createRootTransaction();
+    $transaction2 = $this->createFirstSavepointTransaction();
     $this->executeDDLStatement();
     unset($transaction2);
     $transaction3 = $this->connection->startTransaction();
@@ -403,17 +540,16 @@ public function testTransactionWithDdlStatement(): void {
       // For database servers that support transactional DDL, a rollback
       // of a transaction including DDL statements should be possible.
       $this->cleanUp();
-      $transaction = $this->createRootTransaction('', FALSE);
-      $this->insertRow('row');
+      $transaction = $this->createRootTransaction();
       $this->executeDDLStatement();
       $transaction->rollBack();
       unset($transaction);
-      $this->assertRowAbsent('row');
+      $this->assertRowAbsent('David');
 
       // Including with stacking.
       $this->cleanUp();
-      $transaction = $this->createRootTransaction('', FALSE);
-      $transaction2 = $this->createFirstSavepointTransaction('', FALSE);
+      $transaction = $this->createRootTransaction();
+      $transaction2 = $this->createFirstSavepointTransaction();
       $this->executeDDLStatement();
       unset($transaction2);
       $transaction3 = $this->connection->startTransaction();
@@ -427,21 +563,28 @@ public function testTransactionWithDdlStatement(): void {
       // For database servers that do not support transactional DDL,
       // the DDL statement should commit the transaction stack.
       $this->cleanUp();
-      $transaction = $this->createRootTransaction('', FALSE);
-      $this->insertRow('row');
+      $transaction = $this->createRootTransaction();
+      $reflectionMethod = new \ReflectionMethod(get_class($this->connection->transactionManager()), 'getConnectionTransactionState');
+      $this->assertSame(1, $this->connection->transactionManager()->stackDepth());
+      $this->assertEquals(ClientConnectionTransactionState::Active, $reflectionMethod->invoke($this->connection->transactionManager()));
+
       $this->executeDDLStatement();
 
+      $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
+      $this->assertEquals(ClientConnectionTransactionState::Voided, $reflectionMethod->invoke($this->connection->transactionManager()));
+      $this->assertRowPresent('David');
+
+      // Try to rollback the root transaction. Since the DDL already committed
+      // it, it should fail.
       try {
-        // Rollback the outer transaction.
         $transaction->rollBack();
-        // @see \Drupal\mysql\Driver\Database\mysql\TransactionManager::rollbackClientTransaction()
-        $this->fail('Rolling back a transaction containing DDL should produce a warning.');
+        $this->fail('A TransactionOutOfOrderException was expected, but it was not thrown.');
       }
-      catch (Warning $warning) {
-        $this->assertSame('Rollback attempted when there is no active transaction. This can cause data integrity issues.', $warning->getMessage());
+      catch (TransactionOutOfOrderException $e) {
+        $this->assertMatchesRegularExpression("/^Error attempting rollback of .*\\\\drupal_transaction\\. Active stack: .* empty /", $e->getMessage());
+        unset($transaction);
+        $this->assertRowPresent('David');
       }
-      unset($transaction);
-      $this->assertRowPresent('row');
     }
   }
 
@@ -515,6 +658,9 @@ public function assertRowAbsent(string $name, string $message = NULL): void {
 
   /**
    * Tests transaction stacking, commit, and rollback.
+   *
+   * @todo change this test to legacy once commit-on-destruct is deprecated.
+   *   Replaced by ::testTransactionStackingExplicitCommit().
    */
   public function testTransactionStacking(): void {
     // Standard case: pop the inner transaction before the outer transaction.
@@ -552,6 +698,9 @@ public function testTransactionStacking(): void {
 
   /**
    * Tests that transactions can continue to be used if a query fails.
+   *
+   * @todo change this test to legacy once commit-on-destruct is deprecated.
+   *   Replaced by ::testQueryFailureInTransactionExplicitCommit().
    */
   public function testQueryFailureInTransaction(): void {
     $transaction = $this->createRootTransaction('test_transaction', FALSE);
@@ -670,6 +819,9 @@ public function testQueryFailureInTransaction(): void {
 
   /**
    * Tests releasing a savepoint before last is safe.
+   *
+   * @todo change this test to legacy once commit-on-destruct is deprecated.
+   *   Replaced by ::testReleaseIntermediateSavepointExplicitCommit().
    */
   public function testReleaseIntermediateSavepoint(): void {
     $transaction = $this->createRootTransaction();
@@ -708,6 +860,9 @@ public function testReleaseIntermediateSavepoint(): void {
 
   /**
    * Tests committing a transaction while savepoints are active.
+   *
+   * @todo change this test to legacy once commit-on-destruct is deprecated.
+   *   Replaced by ::testCommitWithActiveSavepointExplicitCommit().
    */
   public function testCommitWithActiveSavepoint(): void {
     $transaction = $this->createRootTransaction();
@@ -762,6 +917,9 @@ public function testRootTransactionEndCallbackAddedWithoutTransaction(): void {
 
   /**
    * Tests post-transaction callback executes after transaction commit.
+   *
+   * @todo change this test to legacy once commit-on-destruct is deprecated.
+   *   Replaced by ::testRootTransactionEndCallbackCalledOnCommitExplicitCommit().
    */
   public function testRootTransactionEndCallbackCalledOnCommit(): void {
     $transaction = $this->createRootTransaction('', FALSE);
@@ -776,6 +934,9 @@ public function testRootTransactionEndCallbackCalledOnCommit(): void {
 
   /**
    * Tests post-transaction callback executes after transaction rollback.
+   *
+   * @todo change this test to legacy once commit-on-destruct is deprecated.
+   *   Replaced by ::testRootTransactionEndCallbackCalledOnRollbackExplicitCommit().
    */
   public function testRootTransactionEndCallbackCalledOnRollback(): void {
     $transaction = $this->createRootTransaction('', FALSE);
@@ -836,4 +997,566 @@ public function testTransactionManagerFailureOnPendingStackItems(): void {
     Database::closeConnection('test_fail');
   }
 
+  /**
+   * Tests savepoint transaction rollback.
+   */
+  public function testRollbackSavepointExplicitCommit(): void {
+    $transaction = $this->createRootTransaction();
+    $savepoint = $this->createFirstSavepointTransaction();
+
+    // Rollback savepoint. It should get released too. Corresponds to 'ROLLBACK
+    // TO savepoint_1' plus 'RELEASE savepoint_1' on the database.
+    $savepoint->rollBack();
+    $this->assertRowPresent('David');
+    $this->assertRowAbsent('Roger');
+    $this->assertTrue($this->connection->inTransaction());
+    $this->assertSame(1, $this->connection->transactionManager()->stackDepth());
+
+    // Insert a row.
+    $this->insertRow('Syd');
+
+    // Commit root. Corresponds to 'COMMIT' on the database.
+    $transaction->commit();
+    $this->assertRowPresent('David');
+    $this->assertRowAbsent('Roger');
+    $this->assertRowPresent('Syd');
+    $this->assertFalse($this->connection->inTransaction());
+    $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
+  }
+
+  /**
+   * Tests savepoint transaction commit after rollback.
+   */
+  public function testCommitAfterRollbackSameSavepointExplicitCommit(): void {
+    $transaction = $this->createRootTransaction();
+    $savepoint = $this->createFirstSavepointTransaction();
+
+    // Rollback savepoint. It should get released too. Corresponds to 'ROLLBACK
+    // TO savepoint_1' plus 'RELEASE savepoint_1' on the database.
+    $savepoint->rollBack();
+    $this->assertRowPresent('David');
+    $this->assertRowAbsent('Roger');
+    $this->assertTrue($this->connection->inTransaction());
+    $this->assertSame(1, $this->connection->transactionManager()->stackDepth());
+
+    // Insert a row.
+    $this->insertRow('Syd');
+
+    // Try committing savepoint. Should fail since it was released already.
+    try {
+      $savepoint->commit();
+      $this->fail('Expected TransactionOutOfOrderException was not thrown');
+    }
+    catch (\Exception $e) {
+      $this->assertInstanceOf(TransactionOutOfOrderException::class, $e);
+      $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\savepoint_1\\. Active stack: .*\\\\drupal_transaction/", $e->getMessage());
+    }
+    $this->assertRowPresent('David');
+    $this->assertRowAbsent('Roger');
+    $this->assertRowPresent('Syd');
+    $this->assertTrue($this->connection->inTransaction());
+    $this->assertSame(1, $this->connection->transactionManager()->stackDepth());
+
+    // Commit root. Corresponds to 'COMMIT' on the database.
+    $transaction->commit();
+    $this->assertRowPresent('David');
+    $this->assertRowAbsent('Roger');
+    $this->assertRowPresent('Syd');
+    $this->assertFalse($this->connection->inTransaction());
+    $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
+  }
+
+  /**
+   * Tests transactions mixed with DDL statements.
+   */
+  public function testTransactionWithDdlStatementExplicitCommit(): void {
+    // A DDL statement auto-commits the transaction in database that do not
+    // support transactional DDL.
+    $transaction = $this->createRootTransaction();
+    $this->executeDDLStatement();
+    if ($this->connection->supportsTransactionalDDL()) {
+      $transaction->commit();
+    }
+    else {
+      try {
+        $transaction->commit();
+        $this->fail('Expected TransactionOutOfOrderException was not thrown');
+      }
+      catch (\Exception $e) {
+        $this->assertInstanceOf(TransactionOutOfOrderException::class, $e);
+        $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\drupal_transaction\\. Active stack: .* empty /", $e->getMessage());
+      }
+    }
+    $this->assertFalse($this->connection->inTransaction());
+    $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
+    $this->assertRowPresent('David');
+
+    // INSERT after the DDL.
+    $this->cleanUp();
+    $transaction = $this->createRootTransaction('', FALSE);
+    $this->executeDDLStatement();
+    $this->insertRow('row');
+    if ($this->connection->supportsTransactionalDDL()) {
+      $transaction->commit();
+    }
+    else {
+      try {
+        $transaction->commit();
+        $this->fail('Expected TransactionOutOfOrderException was not thrown');
+      }
+      catch (\Exception $e) {
+        $this->assertInstanceOf(TransactionOutOfOrderException::class, $e);
+        $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\drupal_transaction\\. Active stack: .* empty /", $e->getMessage());
+      }
+    }
+    $this->assertFalse($this->connection->inTransaction());
+    $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
+    $this->assertRowPresent('row');
+
+    // Execute DDL when savepoint active, commit, open a new transaction,
+    // commit it, commit initial transaction.
+    $this->cleanUp();
+    $transaction = $this->createRootTransaction();
+    $transaction2 = $this->createFirstSavepointTransaction();
+    $this->executeDDLStatement();
+    if ($this->connection->supportsTransactionalDDL()) {
+      $transaction2->commit();
+      $this->assertTrue($this->connection->inTransaction());
+      $this->assertSame(1, $this->connection->transactionManager()->stackDepth());
+    }
+    else {
+      try {
+        $transaction2->commit();
+        $this->fail('Expected TransactionOutOfOrderException was not thrown');
+      }
+      catch (\Exception $e) {
+        $this->assertInstanceOf(TransactionOutOfOrderException::class, $e);
+        $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\savepoint_1\\. Active stack: .* empty /", $e->getMessage());
+      }
+      $this->assertFalse($this->connection->inTransaction());
+      $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
+    }
+    $transaction3 = $this->connection->startTransaction();
+    $transaction3->commit();
+    if ($this->connection->supportsTransactionalDDL()) {
+      $transaction->commit();
+      $this->assertFalse($this->connection->inTransaction());
+      $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
+    }
+    else {
+      try {
+        $transaction->commit();
+        $this->fail('Expected TransactionOutOfOrderException was not thrown');
+      }
+      catch (\Exception $e) {
+        $this->assertInstanceOf(TransactionOutOfOrderException::class, $e);
+        $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\drupal_transaction\\. Active stack: .* empty /", $e->getMessage());
+      }
+    }
+    $this->assertRowPresent('David');
+
+    // A transaction after a DDL statement should still work the same.
+    $this->cleanUp();
+    $transaction = $this->createRootTransaction();
+    $transaction2 = $this->createFirstSavepointTransaction();
+    $this->executeDDLStatement();
+    if ($this->connection->supportsTransactionalDDL()) {
+      $transaction2->commit();
+      $this->assertTrue($this->connection->inTransaction());
+      $this->assertSame(1, $this->connection->transactionManager()->stackDepth());
+    }
+    else {
+      try {
+        $transaction2->commit();
+        $this->fail('Expected TransactionOutOfOrderException was not thrown');
+      }
+      catch (\Exception $e) {
+        $this->assertInstanceOf(TransactionOutOfOrderException::class, $e);
+        $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\savepoint_1\\. Active stack: .* empty /", $e->getMessage());
+      }
+      $this->assertFalse($this->connection->inTransaction());
+      $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
+    }
+    $transaction3 = $this->connection->startTransaction();
+    $this->insertRow('row');
+    $transaction3->rollBack();
+    // Cannot commit a transaction just rolled back.
+    try {
+      $transaction3->commit();
+      $this->fail('Expected TransactionOutOfOrderException was not thrown');
+    }
+    catch (\Exception $e) {
+      $this->assertInstanceOf(TransactionOutOfOrderException::class, $e);
+      if ($this->connection->supportsTransactionalDDL()) {
+        $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\savepoint_1\\. Active stack: .*\\\\drupal_transaction/", $e->getMessage());
+      }
+      else {
+        $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\drupal_transaction\\. Active stack: .* empty /", $e->getMessage());
+      }
+    }
+    // Can only commit initial transaction if transactional DDL is supported,
+    // it would have been already auto-committed otherwise.
+    if ($this->connection->supportsTransactionalDDL()) {
+      $transaction->commit();
+    }
+    $this->assertRowAbsent('row');
+
+    // The behavior of a rollback depends on the type of database server.
+    if ($this->connection->supportsTransactionalDDL()) {
+      // For database servers that support transactional DDL, a rollback
+      // of a transaction including DDL statements should be possible.
+      $this->cleanUp();
+      $transaction = $this->createRootTransaction();
+      $this->executeDDLStatement();
+      $transaction->rollBack();
+      // Cannot commit a transaction just rolled back.
+      try {
+        $transaction->commit();
+        $this->fail('A TransactionOutOfOrderException was expected, but it was not thrown.');
+      }
+      catch (TransactionOutOfOrderException $e) {
+        $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\drupal_transaction\\. Active stack: .* empty /", $e->getMessage());
+      }
+      $this->assertRowAbsent('David');
+
+      // Including with stacking.
+      $this->cleanUp();
+      $transaction = $this->createRootTransaction();
+      $transaction2 = $this->createFirstSavepointTransaction();
+      $this->executeDDLStatement();
+      $transaction2->commit();
+      $transaction3 = $this->connection->startTransaction();
+      $this->insertRow('row');
+      $transaction3->commit();
+      $transaction->rollBack();
+      // Cannot commit a transaction just rolled back.
+      try {
+        $transaction->commit();
+        $this->fail('A TransactionOutOfOrderException was expected, but it was not thrown.');
+      }
+      catch (TransactionOutOfOrderException $e) {
+        $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\drupal_transaction\\. Active stack: .* empty /", $e->getMessage());
+      }
+      $this->assertRowAbsent('row');
+    }
+    else {
+      // For database servers that do not support transactional DDL,
+      // the DDL statement should commit the transaction stack.
+      $this->cleanUp();
+      $transaction = $this->createRootTransaction();
+      $reflectionMethod = new \ReflectionMethod(get_class($this->connection->transactionManager()), 'getConnectionTransactionState');
+      $this->assertSame(1, $this->connection->transactionManager()->stackDepth());
+      $this->assertEquals(ClientConnectionTransactionState::Active, $reflectionMethod->invoke($this->connection->transactionManager()));
+
+      $this->executeDDLStatement();
+
+      $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
+      $this->assertEquals(ClientConnectionTransactionState::Voided, $reflectionMethod->invoke($this->connection->transactionManager()));
+      $this->assertRowPresent('David');
+
+      // Try to rollback the root transaction. Since the DDL already committed
+      // it, it should fail.
+      try {
+        $transaction->rollBack();
+        $this->fail('A TransactionOutOfOrderException was expected, but it was not thrown.');
+      }
+      catch (TransactionOutOfOrderException $e) {
+        $this->assertMatchesRegularExpression("/^Error attempting rollback of .*\\\\drupal_transaction\\. Active stack: .* empty /", $e->getMessage());
+        $this->assertRowPresent('David');
+      }
+      // Same for a commit.
+      try {
+        $transaction->commit();
+        $this->fail('A TransactionOutOfOrderException was expected, but it was not thrown.');
+      }
+      catch (TransactionOutOfOrderException $e) {
+        $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\drupal_transaction\\. Active stack: .* empty /", $e->getMessage());
+        $this->assertRowPresent('David');
+      }
+      // There should be no problem to let the Transaction object go out of
+      // scope.
+      unset($transaction);
+    }
+  }
+
+  /**
+   * Tests transaction stacking, commit, and rollback.
+   */
+  public function testTransactionStackingExplicitCommit(): void {
+    // Standard case: pop the inner transaction before the outer transaction.
+    $transaction = $this->createRootTransaction('', FALSE);
+    $this->insertRow('outer');
+    $transaction2 = $this->createFirstSavepointTransaction('', FALSE);
+    $this->insertRow('inner');
+    // Pop the inner transaction.
+    $transaction2->commit();
+    $this->assertTrue($this->connection->inTransaction(), 'Still in a transaction after popping the inner transaction');
+    // Pop the outer transaction.
+    $transaction->commit();
+    $this->assertFalse($this->connection->inTransaction(), 'Transaction closed after popping the outer transaction');
+    $this->assertRowPresent('outer');
+    $this->assertRowPresent('inner');
+
+    // Rollback the inner transaction.
+    $this->cleanUp();
+    $transaction = $this->createRootTransaction('', FALSE);
+    $this->insertRow('outer');
+    $transaction2 = $this->createFirstSavepointTransaction('', FALSE);
+    $this->insertRow('inner');
+    // Now rollback the inner transaction.
+    $transaction2->rollBack();
+    // Try committing the transaction. Should fail since it was rolled back
+    // already.
+    try {
+      $transaction2->commit();
+      $this->fail('Expected TransactionOutOfOrderException was not thrown');
+    }
+    catch (\Exception $e) {
+      $this->assertInstanceOf(TransactionOutOfOrderException::class, $e);
+      $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\savepoint_1\\. Active stack: .*\\\\drupal_transaction/", $e->getMessage());
+    }
+    $this->assertTrue($this->connection->inTransaction(), 'Still in a transaction after popping the outer transaction');
+    // Pop the outer transaction, it should commit.
+    $this->insertRow('outer-after-inner-rollback');
+    $transaction->commit();
+    $this->assertFalse($this->connection->inTransaction(), 'Transaction closed after popping the inner transaction');
+    $this->assertRowPresent('outer');
+    $this->assertRowAbsent('inner');
+    $this->assertRowPresent('outer-after-inner-rollback');
+  }
+
+  /**
+   * Tests that transactions can continue to be used if a query fails.
+   */
+  public function testQueryFailureInTransactionExplicitCommit(): void {
+    $transaction = $this->createRootTransaction('test_transaction', FALSE);
+    $this->connection->schema()->dropTable('test');
+
+    // Test a failed query using the query() method.
+    try {
+      $this->connection->query('SELECT [age] FROM {test} WHERE [name] = :name', [':name' => 'David'])->fetchField();
+      $this->fail('Using the query method should have failed.');
+    }
+    catch (\Exception $e) {
+      // Just continue testing.
+    }
+
+    // Test a failed select query.
+    try {
+      $this->connection->select('test')
+        ->fields('test', ['name'])
+        ->execute();
+
+      $this->fail('Select query should have failed.');
+    }
+    catch (\Exception $e) {
+      // Just continue testing.
+    }
+
+    // Test a failed insert query.
+    try {
+      $this->connection->insert('test')
+        ->fields([
+          'name' => 'David',
+          'age' => '24',
+        ])
+        ->execute();
+
+      $this->fail('Insert query should have failed.');
+    }
+    catch (\Exception $e) {
+      // Just continue testing.
+    }
+
+    // Test a failed update query.
+    try {
+      $this->connection->update('test')
+        ->fields(['name' => 'Tiffany'])
+        ->condition('id', 1)
+        ->execute();
+
+      $this->fail('Update query should have failed.');
+    }
+    catch (\Exception $e) {
+      // Just continue testing.
+    }
+
+    // Test a failed delete query.
+    try {
+      $this->connection->delete('test')
+        ->condition('id', 1)
+        ->execute();
+
+      $this->fail('Delete query should have failed.');
+    }
+    catch (\Exception $e) {
+      // Just continue testing.
+    }
+
+    // Test a failed merge query.
+    try {
+      $this->connection->merge('test')
+        ->key('job', 'Presenter')
+        ->fields([
+          'age' => '31',
+          'name' => 'Tiffany',
+        ])
+        ->execute();
+
+      $this->fail('Merge query should have failed.');
+    }
+    catch (\Exception $e) {
+      // Just continue testing.
+    }
+
+    // Test a failed upsert query.
+    try {
+      $this->connection->upsert('test')
+        ->key('job')
+        ->fields(['job', 'age', 'name'])
+        ->values([
+          'job' => 'Presenter',
+          'age' => 31,
+          'name' => 'Tiffany',
+        ])
+        ->execute();
+
+      $this->fail('Upsert query should have failed.');
+    }
+    catch (\Exception $e) {
+      // Just continue testing.
+    }
+
+    // Create the missing schema and insert a row.
+    $this->installSchema('database_test', ['test']);
+    $this->connection->insert('test')
+      ->fields([
+        'name' => 'David',
+        'age' => '24',
+      ])
+      ->execute();
+
+    // Commit the transaction, but only if transactional DDL is supported.
+    // Otherwise, it would already have auto-committed.
+    if ($this->connection->supportsTransactionalDDL()) {
+      $transaction->commit();
+    }
+
+    $saved_age = $this->connection->query('SELECT [age] FROM {test} WHERE [name] = :name', [':name' => 'David'])->fetchField();
+    $this->assertEquals('24', $saved_age);
+  }
+
+  /**
+   * Tests releasing a savepoint before last is safe.
+   */
+  public function testReleaseIntermediateSavepointExplicitCommit(): void {
+    $transaction = $this->createRootTransaction();
+    $savepoint1 = $this->createFirstSavepointTransaction('', FALSE);
+
+    // Starts a savepoint transaction. Corresponds to 'SAVEPOINT savepoint_2'
+    // on the database.
+    $savepoint2 = $this->connection->startTransaction();
+    $this->assertSame(3, $this->connection->transactionManager()->stackDepth());
+    // Starts a savepoint transaction. Corresponds to 'SAVEPOINT savepoint_3'
+    // on the database.
+    $savepoint3 = $this->connection->startTransaction();
+    $this->assertSame(4, $this->connection->transactionManager()->stackDepth());
+    // Starts a savepoint transaction. Corresponds to 'SAVEPOINT savepoint_4'
+    // on the database.
+    $savepoint4 = $this->connection->startTransaction();
+    $this->assertSame(5, $this->connection->transactionManager()->stackDepth());
+
+    $this->insertRow('row');
+
+    // Commit a savepoint transaction. Corresponds to 'RELEASE SAVEPOINT
+    // savepoint_2' on the database.
+    $savepoint2->commit();
+    // Since we have committed an intermediate savepoint Transaction object,
+    // the savepoints created later have been dropped by the database already.
+    $this->assertSame(2, $this->connection->transactionManager()->stackDepth());
+    $this->assertRowPresent('row');
+
+    // Commit the remaining Transaction objects. The client transaction is
+    // eventually committed.
+    $savepoint1->commit();
+    $transaction->commit();
+    $this->assertFalse($this->connection->inTransaction());
+    $this->assertRowPresent('row');
+  }
+
+  /**
+   * Tests committing a transaction while savepoints are active.
+   */
+  public function testCommitWithActiveSavepointExplicitCommit(): void {
+    $transaction = $this->createRootTransaction();
+    $savepoint1 = $this->createFirstSavepointTransaction('', FALSE);
+
+    // Starts a savepoint transaction. Corresponds to 'SAVEPOINT savepoint_2'
+    // on the database.
+    $savepoint2 = $this->connection->startTransaction();
+    $this->assertSame(3, $this->connection->transactionManager()->stackDepth());
+
+    $this->insertRow('row');
+
+    // Commit the root transaction. Corresponds to 'COMMIT' on the database.
+    $transaction->commit();
+    // Since we have committed the outer (root) Transaction object, the inner
+    // (savepoint) ones have been dropped by the database already, and we are
+    // no longer in an active transaction state.
+    $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
+    $this->assertFalse($this->connection->inTransaction());
+    $this->assertRowPresent('row');
+    // Commit the inner (savepoint) Transaction object, it should fail given
+    // the main transaction was committed already.
+    try {
+      $savepoint2->commit();
+      $this->fail('Expected TransactionOutOfOrderException was not thrown');
+    }
+    catch (\Exception $e) {
+      $this->assertInstanceOf(TransactionOutOfOrderException::class, $e);
+      $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\savepoint_2\\. Active stack: .* empty /", $e->getMessage());
+    }
+    $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
+    $this->assertFalse($this->connection->inTransaction());
+    $this->assertRowPresent('row');
+  }
+
+  /**
+   * Tests post-transaction callback executes after transaction commit.
+   */
+  public function testRootTransactionEndCallbackCalledOnCommitExplicitCommit(): void {
+    $transaction = $this->createRootTransaction('', FALSE);
+    $this->connection->transactionManager()->addPostTransactionCallback([$this, 'rootTransactionCallback']);
+    $this->insertRow('row');
+    $this->assertNull($this->postTransactionCallbackAction);
+    $transaction->commit();
+    $this->assertSame('rtcCommit', $this->postTransactionCallbackAction);
+    $this->assertRowPresent('row');
+    $this->assertRowPresent('rtcCommit');
+  }
+
+  /**
+   * Tests post-transaction callback executes after transaction rollback.
+   */
+  public function testRootTransactionEndCallbackCalledOnRollbackExplicitCommit(): void {
+    $transaction = $this->createRootTransaction();
+    $this->connection->transactionManager()->addPostTransactionCallback([$this, 'rootTransactionCallback']);
+    $this->assertNull($this->postTransactionCallbackAction);
+    $transaction->rollBack();
+    $this->assertSame('rtcRollback', $this->postTransactionCallbackAction);
+    // Try committing transaction. Should fail since it was rolled back already.
+    try {
+      $transaction->commit();
+      $this->fail('Expected TransactionOutOfOrderException was not thrown');
+    }
+    catch (\Exception $e) {
+      $this->assertInstanceOf(TransactionOutOfOrderException::class, $e);
+      $this->assertMatchesRegularExpression("/^Error attempting commit of .*\\\\drupal_transaction\\. Active stack: .* empty /", $e->getMessage());
+    }
+    $this->assertRowAbsent('David');
+    // The row insert should be missing since the client rollback occurs after
+    // the processing of the callbacks.
+    $this->assertRowAbsent('rtcRollback');
+  }
+
 }
