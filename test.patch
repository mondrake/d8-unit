diff --git a/core/lib/Drupal/Core/Database/StatementInterface.php b/core/lib/Drupal/Core/Database/StatementInterface.php
index 09a6b94f50..b4adf3742d 100644
--- a/core/lib/Drupal/Core/Database/StatementInterface.php
+++ b/core/lib/Drupal/Core/Database/StatementInterface.php
@@ -7,12 +7,12 @@
 /**
  * Represents a prepared statement.
  *
- * Child implementations should either extend StatementWrapper:
+ * Child implementations should either extend StatementWrapperIterator:
  * @code
- * class Drupal\mymodule\Driver\Database\mydriver\Statement extends Drupal\Core\Database\StatementWrapper {}
+ * class Drupal\mymodule\Driver\Database\mydriver\Statement extends Drupal\Core\Database\StatementWrapperIterator {}
  * @endcode
  * or define their own class. If defining their own class, they will also have
- * to implement either the Iterator or IteratorAggregate interface before
+ * to implement either the \Iterator or \IteratorAggregate interface before
  * Drupal\Core\Database\StatementInterface:
  * @code
  * class Drupal\mymodule\Driver\Database\mydriver\Statement implements Iterator, Drupal\Core\Database\StatementInterface {}
diff --git a/core/lib/Drupal/Core/Database/StatementPrefetch.php b/core/lib/Drupal/Core/Database/StatementPrefetch.php
index 7edbf7b26b..5ec6db68da 100644
--- a/core/lib/Drupal/Core/Database/StatementPrefetch.php
+++ b/core/lib/Drupal/Core/Database/StatementPrefetch.php
@@ -5,9 +5,9 @@
 /**
  * An implementation of StatementInterface that prefetches all data.
  *
- * This class behaves very similar to a StatementWrapper of a \PDOStatement
- * but as it always fetches every row it is possible to manipulate those
- * results.
+ * This class behaves very similar to a StatementWrapperIterator of a
+ * \PDOStatement but as it always fetches every row it is possible to
+ * manipulate those results.
  */
 class StatementPrefetch implements \Iterator, StatementInterface {
 
diff --git a/core/lib/Drupal/Core/Database/StatementWrapper.php b/core/lib/Drupal/Core/Database/StatementWrapper.php
index 4381fd1af6..f85b347423 100644
--- a/core/lib/Drupal/Core/Database/StatementWrapper.php
+++ b/core/lib/Drupal/Core/Database/StatementWrapper.php
@@ -4,8 +4,15 @@
 
 // cSpell:ignore maxlen driverdata INOUT
 
+@trigger_error('\Drupal\Core\Database\StatementWrapper is deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. Use \Drupal\Core\Database\StatementWrapperIterator instead. See https://www.drupal.org/node/3265938', E_USER_DEPRECATED);
+
 /**
  * Implementation of StatementInterface encapsulating PDOStatement.
+ *
+ * @deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. Use
+ *   \Drupal\Core\Database\StatementWrapperIterator instead.
+ *
+ * @see https://www.drupal.org/node/3265938
  */
 class StatementWrapper implements \IteratorAggregate, StatementInterface {
 
diff --git a/core/lib/Drupal/Core/Database/StatementWrapperIterator.php b/core/lib/Drupal/Core/Database/StatementWrapperIterator.php
new file mode 100644
index 0000000000..caa6c7c725
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/StatementWrapperIterator.php
@@ -0,0 +1,394 @@
+<?php
+
+namespace Drupal\Core\Database;
+
+// cSpell:ignore maxlen driverdata INOUT
+
+/**
+ * StatementInterface iterator implementation.
+ *
+ * This class is meant to be generic enough for any type of database clients,
+ * even if all Drupal core database drivers currently use PDO clients. We
+ * implement \Iterator instead of \IteratorAggregate to allow iteration to be
+ * kept in sync with the underlying database resultset cursor. PDO is not able
+ * to execute a database operation while a cursor is open on the result of an
+ * earlier select query, so Drupal by default uses buffered queries setting
+ * \PDO::MYSQL_ATTR_USE_BUFFERED_QUERY to TRUE on the connection. This forces
+ * the query to return all the results in a buffer local to the client library,
+ * potentially leading to memory issues in case of large datasets being
+ * returned by a query. Other database clients, however, could allow
+ * multithread queries, or developers could disable buffered queries in PDO:
+ * in that case, this class prevents the resultset to be entirely fetched in
+ * PHP memory (that an \IteratorAggregate implementation would force) and
+ * therefore optimize memory usage while iterating the resultset.
+ */
+class StatementWrapperIterator implements \Iterator, StatementInterface {
+
+  /**
+   * The client database Statement object.
+   *
+   * For a \PDO client connection, this will be a \PDOStatement object.
+   */
+  protected object $clientStatement;
+
+  /**
+   * Traces if rows can be fetched from the resultset.
+   */
+  private bool $isResultsetIterable = FALSE;
+
+  /**
+   * The current row, retrieved in the current fetch format.
+   */
+  private mixed $resultsetRow = NULL;
+
+  /**
+   * The key of the current row.
+   *
+   * This keeps the index of rows fetched from the underlying statement. It is
+   * set to -1 when no rows have been fetched yet.
+   */
+  private int $resultsetKey = -1;
+
+  /**
+   * Constructs a StatementWrapperIterator object.
+   *
+   * @param \Drupal\Core\Database\Connection $connection
+   *   Drupal database connection object.
+   * @param object $clientConnection
+   *   Client database connection object, for example \PDO.
+   * @param string $query
+   *   The SQL query string.
+   * @param array $options
+   *   Array of query options.
+   * @param bool $rowCountEnabled
+   *   (optional) Enables counting the rows matched. Defaults to FALSE.
+   */
+  public function __construct(
+    protected readonly Connection $connection,
+    object $clientConnection,
+    string $query,
+    array $options,
+    protected readonly bool $rowCountEnabled = FALSE,
+  ) {
+    $this->clientStatement = $clientConnection->prepare($query, $options);
+    $this->setFetchMode(\PDO::FETCH_OBJ);
+  }
+
+  /**
+   * Returns the client-level database statement object.
+   *
+   * This method should normally be used only within database driver code.
+   *
+   * @return object
+   *   The client-level database statement, for example \PDOStatement.
+   */
+  public function getClientStatement(): object {
+    return $this->clientStatement;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getConnectionTarget(): string {
+    return $this->connection->getTarget();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function execute($args = [], $options = []) {
+    if (isset($options['fetch'])) {
+      if (is_string($options['fetch'])) {
+        // \PDO::FETCH_PROPS_LATE tells __construct() to run before properties
+        // are added to the object.
+        $this->setFetchMode(\PDO::FETCH_CLASS | \PDO::FETCH_PROPS_LATE, $options['fetch']);
+      }
+      else {
+        $this->setFetchMode($options['fetch']);
+      }
+    }
+
+    $logger = $this->connection->getLogger();
+    if (!empty($logger)) {
+      $queryStart = microtime(TRUE);
+    }
+
+    $return = $this->clientStatement->execute($args);
+    $this->markResultsetIterable($return);
+
+    if (!empty($logger)) {
+      $queryEnd = microtime(TRUE);
+      $logger->log($this, $args, $queryEnd - $queryStart, $queryStart);
+    }
+
+    return $return;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getQueryString() {
+    return $this->clientStatement->queryString;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchCol($index = 0) {
+    return $this->fetchAll(\PDO::FETCH_COLUMN, $index);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchAllAssoc($key, $fetch = NULL) {
+    $return = [];
+    if (isset($fetch)) {
+      if (is_string($fetch)) {
+        $this->setFetchMode(\PDO::FETCH_CLASS, $fetch);
+      }
+      else {
+        $this->setFetchMode($fetch);
+      }
+    }
+
+    foreach ($this as $record) {
+      $recordKey = is_object($record) ? $record->$key : $record[$key];
+      $return[$recordKey] = $record;
+    }
+
+    return $return;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchAllKeyed($keyIndex = 0, $valueIndex = 1) {
+    $return = [];
+    $this->setFetchMode(\PDO::FETCH_NUM);
+    foreach ($this as $record) {
+      $return[$record[$keyIndex]] = $record[$valueIndex];
+    }
+    return $return;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchField($index = 0) {
+    // We use ::fetch(\PDO::FETCH_NUM) here instead of calling fetchColumn()
+    // on the client statement to avoid calling a PDO-specific method.
+    $fields = $this->fetch(\PDO::FETCH_NUM);
+    return $fields === FALSE ? FALSE : ($fields[$index] ?? NULL);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchAssoc() {
+    return $this->fetch(\PDO::FETCH_ASSOC);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchObject(string $className = NULL, array $constructorArguments = NULL) {
+    if ($className) {
+      $row = $this->clientStatement->fetchObject($className, $constructorArguments);
+    }
+    else {
+      $row = $this->clientStatement->fetchObject();
+    }
+
+    if ($row) {
+      $this->setCurrentResultsetRow($row);
+    }
+    else {
+      $this->markResultsetFetchingComplete();
+    }
+
+    return $row;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function rowCount() {
+    // SELECT query should not use the method.
+    if ($this->rowCountEnabled) {
+      return $this->clientStatement->rowCount();
+    }
+    else {
+      throw new RowCountException();
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setFetchMode($mode, $a1 = NULL, $a2 = []) {
+    // Call \PDOStatement::setFetchMode to set fetch mode.
+    // \PDOStatement is picky about the number of arguments in some cases so we
+    // need to be pass the exact number of arguments we where given.
+    switch (func_num_args()) {
+      case 1:
+        return $this->clientStatement->setFetchMode($mode);
+
+      case 2:
+        return $this->clientStatement->setFetchMode($mode, $a1);
+
+      case 3:
+      default:
+        return $this->clientStatement->setFetchMode($mode, $a1, $a2);
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetch($mode = NULL, $cursorOrientation = NULL, $cursorOffset = NULL) {
+    // Call \PDOStatement::fetchAll to fetch all rows.
+    // \PDOStatement is picky about the number of arguments in some cases so we
+    // need to pass the exact number of arguments we were given.
+    switch (func_num_args()) {
+      case 0:
+        $row = $this->clientStatement->fetch();
+        break;
+
+      case 1:
+        $row = $this->clientStatement->fetch($mode);
+        break;
+
+      case 2:
+        $row = $this->clientStatement->fetch($mode, $cursorOrientation);
+        break;
+
+      case 3:
+      default:
+        $row = $this->clientStatement->fetch($mode, $cursorOrientation, $cursorOffset);
+        break;
+    }
+
+    if ($row) {
+      $this->setCurrentResultsetRow($row);
+    }
+    else {
+      $this->markResultsetFetchingComplete();
+    }
+
+    return $row;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function fetchAll($mode = NULL, $columnIndex = NULL, $constructorArguments = NULL) {
+    // Call \PDOStatement::fetchAll to fetch all rows.
+    // \PDOStatement is picky about the number of arguments in some cases so we
+    // need to be pass the exact number of arguments we where given.
+    switch (func_num_args()) {
+      case 0:
+        $return = $this->clientStatement->fetchAll();
+        break;
+
+      case 1:
+        $return = $this->clientStatement->fetchAll($mode);
+        break;
+
+      case 2:
+        $return = $this->clientStatement->fetchAll($mode, $columnIndex);
+        break;
+
+      case 3:
+      default:
+        $return = $this->clientStatement->fetchAll($mode, $columnIndex, $constructorArguments);
+    }
+
+    $this->markResultsetFetchingComplete();
+
+    return $return;
+  }
+
+  /**
+   * Informs the iterator whether rows can be fetched from the resultset.
+   *
+   * @param bool $valid
+   *   The result of the execution of the client statement.
+   */
+  protected function markResultsetIterable(bool $valid): void {
+    $this->isResultsetIterable = $valid;
+    $this->resultsetRow = NULL;
+    $this->resultsetKey = -1;
+  }
+
+  /**
+   * Sets the current resultset row for the iterator, and increments the key.
+   *
+   * @param mixed $row
+   *   The last row fetched from the client statement.
+   */
+  protected function setCurrentResultsetRow(mixed $row): void {
+    $this->resultsetRow = $row;
+    $this->resultsetKey++;
+  }
+
+  /**
+   * Informs the iterator that no more rows can be fetched from the resultset.
+   */
+  protected function markResultsetFetchingComplete(): void {
+    $this->markResultsetIterable(FALSE);
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function current(): mixed {
+    return $this->resultsetRow;
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function key(): mixed {
+    return $this->resultsetKey;
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function rewind(): void {
+dump([__METHOD, $this->resultsetKey]);
+    // Nothing to do: our DatabaseStatement can't be rewound.
+    if ($this->resultsetKey >= 0) {
+      @trigger_error('Rewinding a StatementInterface object when fetching has started is deprecated in drupal:10.1.0 and will throw an exception from drupal:11.0.0. Refactor your code to avoid rewinding statement objects. See https://www.drupal.org/node/3265938', E_USER_DEPRECATED);
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function next(): void {
+    $this->fetch();
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function valid(): bool {
+    if ($this->isResultsetIterable && $this->resultsetKey === -1) {
+      $this->fetch();
+    }
+    return $this->isResultsetIterable;
+  }
+
+}
diff --git a/core/modules/mysql/src/Driver/Database/mysql/Connection.php b/core/modules/mysql/src/Driver/Database/mysql/Connection.php
index 5062d5ebab..7c9fab2836 100644
--- a/core/modules/mysql/src/Driver/Database/mysql/Connection.php
+++ b/core/modules/mysql/src/Driver/Database/mysql/Connection.php
@@ -4,7 +4,7 @@
 
 use Drupal\Core\Database\DatabaseAccessDeniedException;
 use Drupal\Core\Database\DatabaseExceptionWrapper;
-use Drupal\Core\Database\StatementWrapper;
+use Drupal\Core\Database\StatementWrapperIterator;
 use Drupal\Core\Database\Database;
 use Drupal\Core\Database\DatabaseNotFoundException;
 use Drupal\Core\Database\DatabaseException;
@@ -50,7 +50,7 @@ class Connection extends DatabaseConnection implements SupportsTemporaryTablesIn
   /**
    * {@inheritdoc}
    */
-  protected $statementWrapperClass = StatementWrapper::class;
+  protected $statementWrapperClass = StatementWrapperIterator::class;
 
   /**
    * Flag to indicate if the cleanup function in __destruct() should run.
diff --git a/core/modules/mysql/tests/src/Unit/ConnectionTest.php b/core/modules/mysql/tests/src/Unit/ConnectionTest.php
index 878d7672ad..5ebe43b626 100644
--- a/core/modules/mysql/tests/src/Unit/ConnectionTest.php
+++ b/core/modules/mysql/tests/src/Unit/ConnectionTest.php
@@ -77,9 +77,9 @@ public function __construct(\PDO $connection) {
    */
   public function testVersionAndIsMariaDb(bool $expected_is_mariadb, string $server_version, string $expected_version): void {
     $this->pdoStatement
-      ->fetchColumn(Argument::any())
+      ->fetch(Argument::any())
       ->shouldBeCalled()
-      ->willReturn($server_version);
+      ->willReturn([$server_version]);
 
     $connection = $this->createConnection();
 
diff --git a/core/modules/pgsql/src/Driver/Database/pgsql/Connection.php b/core/modules/pgsql/src/Driver/Database/pgsql/Connection.php
index 8417ed831b..a458b5d4e4 100644
--- a/core/modules/pgsql/src/Driver/Database/pgsql/Connection.php
+++ b/core/modules/pgsql/src/Driver/Database/pgsql/Connection.php
@@ -7,7 +7,7 @@
 use Drupal\Core\Database\DatabaseAccessDeniedException;
 use Drupal\Core\Database\DatabaseNotFoundException;
 use Drupal\Core\Database\StatementInterface;
-use Drupal\Core\Database\StatementWrapper;
+use Drupal\Core\Database\StatementWrapperIterator;
 use Drupal\Core\Database\SupportsTemporaryTablesInterface;
 
 // cSpell:ignore ilike nextval
@@ -43,7 +43,7 @@ class Connection extends DatabaseConnection implements SupportsTemporaryTablesIn
   /**
    * {@inheritdoc}
    */
-  protected $statementWrapperClass = StatementWrapper::class;
+  protected $statementWrapperClass = StatementWrapperIterator::class;
 
   /**
    * A map of condition operators to PostgreSQL operators.
diff --git a/core/tests/Drupal/KernelTests/Core/Database/StatementTest.php b/core/tests/Drupal/KernelTests/Core/Database/StatementTest.php
index eeb2304663..3680ff6e40 100644
--- a/core/tests/Drupal/KernelTests/Core/Database/StatementTest.php
+++ b/core/tests/Drupal/KernelTests/Core/Database/StatementTest.php
@@ -43,4 +43,24 @@ public function testRepeatedInsertStatementReuse() {
     $this->assertSame('31', $this->connection->query('SELECT [age] FROM {test} WHERE [name] = :name', [':name' => 'Curly'])->fetchField());
   }
 
+  /**
+   * Tests deprecation of statement rewinding.
+   *
+   * #group legacy
+   */
+  public function testStatementRewindDeprecation() {
+    $statement = $this->connection->query('SELECT * FROM {test}');
+
+    foreach ($statement as $row) {
+dump($row);
+      $this->assertNotNull($row);
+    }
+
+//    $this->expectDeprecation('\\Drupal\\Core\\Database\\StatementWrapper is deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. Use \\Drupal\\Core\\Database\\StatementWrapperIterator instead. See https://www.drupal.org/node/3265938');
+    foreach ($statement as $row) {
+dump($row);
+      $this->assertNotNull($row);
+    }
+  }
+
 }
diff --git a/core/tests/Drupal/Tests/Core/Database/ConnectionTest.php b/core/tests/Drupal/Tests/Core/Database/ConnectionTest.php
index e46a01d8e7..fc46544d59 100644
--- a/core/tests/Drupal/Tests/Core/Database/ConnectionTest.php
+++ b/core/tests/Drupal/Tests/Core/Database/ConnectionTest.php
@@ -645,4 +645,17 @@ public function provideQueriesToTrim() {
     ];
   }
 
+  /**
+   * Tests deprecation of the StatementWrapper class.
+   *
+   * @group legacy
+   */
+  public function testStatementWrapperDeprecation() {
+    $this->expectDeprecation('\\Drupal\\Core\\Database\\StatementWrapper is deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. Use \\Drupal\\Core\\Database\\StatementWrapperIterator instead. See https://www.drupal.org/node/3265938');
+    $mock_pdo = $this->createMock(StubPDO::class);
+    $connection = new StubConnection($mock_pdo, []);
+    $this->expectError();
+    $connection->prepareStatement('boing', []);
+  }
+
 }
