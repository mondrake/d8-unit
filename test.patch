diff --git a/core/lib/Drupal/Core/Database/StatementWrapper.php b/core/lib/Drupal/Core/Database/StatementWrapper.php
index 8a3bc208c5..d83293e2cc 100644
--- a/core/lib/Drupal/Core/Database/StatementWrapper.php
+++ b/core/lib/Drupal/Core/Database/StatementWrapper.php
@@ -7,7 +7,7 @@
 /**
  * Implementation of StatementInterface encapsulating PDOStatement.
  */
-class StatementWrapper implements \IteratorAggregate, StatementInterface {
+class StatementWrapper implements \Iterator, StatementInterface {
 
   /**
    * The Drupal database connection object.
@@ -32,6 +32,21 @@ class StatementWrapper implements \IteratorAggregate, StatementInterface {
    */
   protected $rowCountEnabled = FALSE;
 
+  /**
+   * Traces if rows can be fetched from the resultset.
+   */
+  private bool $isResultsetIterable = FALSE;
+
+  /**
+   * The current row, retrieved in the current fetch format.
+   */
+  private mixed $resultsetRow = NULL;
+
+  /**
+   * The key of the current row.
+   */
+  private int $resultsetKey = -1;
+
   /**
    * Constructs a StatementWrapper object.
    *
@@ -93,6 +108,7 @@ public function execute($args = [], $options = []) {
     }
 
     $return = $this->clientStatement->execute($args);
+    $this->markResultsetIterable($return);
 
     if (!empty($logger)) {
       $query_end = microtime(TRUE);
@@ -154,15 +170,14 @@ public function fetchAllKeyed($key_index = 0, $value_index = 1) {
    * {@inheritdoc}
    */
   public function fetchField($index = 0) {
-    // Call \PDOStatement::fetchColumn to fetch the field.
-    return $this->clientStatement->fetchColumn($index);
+    $return = $this->fetch(\PDO::FETCH_NUM);
+    return $return === FALSE ? FALSE : ($return[$index] ?? NULL);
   }
 
   /**
    * {@inheritdoc}
    */
   public function fetchAssoc() {
-    // Call \PDOStatement::fetch to fetch the row.
     return $this->fetch(\PDO::FETCH_ASSOC);
   }
 
@@ -171,9 +186,20 @@ public function fetchAssoc() {
    */
   public function fetchObject(string $class_name = NULL, array $constructor_arguments = NULL) {
     if ($class_name) {
-      return $this->clientStatement->fetchObject($class_name, $constructor_arguments);
+      $row = $this->clientStatement->fetchObject($class_name, $constructor_arguments);
     }
-    return $this->clientStatement->fetchObject();
+    else {
+      $row = $this->clientStatement->fetchObject();
+    }
+
+    if ($row) {
+      $this->setCurrentResultsetRow($row);
+    }
+    else {
+      $this->markResultsetFetchingComplete();
+    }
+
+    return $row;
   }
 
   /**
@@ -215,21 +241,34 @@ public function setFetchMode($mode, $a1 = NULL, $a2 = []) {
   public function fetch($mode = NULL, $cursor_orientation = NULL, $cursor_offset = NULL) {
     // Call \PDOStatement::fetchAll to fetch all rows.
     // \PDOStatement is picky about the number of arguments in some cases so we
-    // need to be pass the exact number of arguments we where given.
+    // need to pass the exact number of arguments we were given.
     switch (func_num_args()) {
       case 0:
-        return $this->clientStatement->fetch();
+        $row = $this->clientStatement->fetch();
+        break;
 
       case 1:
-        return $this->clientStatement->fetch($mode);
+        $row = $this->clientStatement->fetch($mode);
+        break;
 
       case 2:
-        return $this->clientStatement->fetch($mode, $cursor_orientation);
+        $row = $this->clientStatement->fetch($mode, $cursor_orientation);
+        break;
 
       case 3:
       default:
-        return $this->clientStatement->fetch($mode, $cursor_orientation, $cursor_offset);
+        $row = $this->clientStatement->fetch($mode, $cursor_orientation, $cursor_offset);
+        break;
+    }
+
+    if ($row) {
+      $this->setCurrentResultsetRow($row);
+    }
+    else {
+      $this->markResultsetFetchingComplete();
     }
+
+    return $row;
   }
 
   /**
@@ -241,26 +280,115 @@ public function fetchAll($mode = NULL, $column_index = NULL, $constructor_argume
     // need to be pass the exact number of arguments we where given.
     switch (func_num_args()) {
       case 0:
-        return $this->clientStatement->fetchAll();
+        $return = $this->clientStatement->fetchAll();
+        break;
 
       case 1:
-        return $this->clientStatement->fetchAll($mode);
+        $return = $this->clientStatement->fetchAll($mode);
+        break;
 
       case 2:
-        return $this->clientStatement->fetchAll($mode, $column_index);
+        $return = $this->clientStatement->fetchAll($mode, $column_index);
+        break;
 
       case 3:
       default:
-        return $this->clientStatement->fetchAll($mode, $column_index, $constructor_arguments);
+        $return = $this->clientStatement->fetchAll($mode, $column_index, $constructor_arguments);
     }
+
+    $this->markResultsetFetchingComplete();
+
+    return $return;
   }
 
   /**
-   * {@inheritdoc}
+   * @deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. There is
+   *   no replacement.
+   *
+   * @see https://www.drupal.org/node/3265938
    */
   #[\ReturnTypeWillChange]
   public function getIterator() {
+    @trigger_error(__METHOD__ . '() is deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. There is no replacement. See https://www.drupal.org/node/3265938', E_USER_DEPRECATED);
     return new \ArrayIterator($this->fetchAll());
   }
 
+  /**
+   * Informs the iterator whether rows can be fetched from the resultset.
+   *
+   * @param bool $valid
+   *   The result of the execution of the client statement.
+   */
+  protected function markResultsetIterable(bool $valid): void {
+    $this->isResultsetIterable = $valid;
+    $this->resultsetRow = NULL;
+    $this->resultsetKey = -1;
+  }
+
+  /**
+   * Sets the current resultset row for the iterator, and increments the key.
+   *
+   * @param mixed $row
+   *   The last row fetched from the client statement.
+   */
+  protected function setCurrentResultsetRow(mixed $row): void {
+    $this->resultsetRow = $row;
+    $this->resultsetKey++;
+  }
+
+  /**
+   * Informs the iterator that no more rows can be fetched from the resultset.
+   */
+  protected function markResultsetFetchingComplete(): void {
+    $this->markResultsetIterable(FALSE);
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function current(): mixed {
+    return $this->resultsetRow;
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function key(): mixed {
+    return $this->resultsetKey;
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function rewind(): void {
+    // Nothing to do: our DatabaseStatement can't be rewound.
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function next(): void {
+    $this->fetch();
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function valid(): bool {
+    if ($this->isResultsetIterable && $this->resultsetKey === -1) {
+      $this->fetch();
+    }
+    return $this->isResultsetIterable;
+  }
+
 }
diff --git a/core/modules/mysql/tests/src/Kernel/mysql/StatementTest.php b/core/modules/mysql/tests/src/Kernel/mysql/StatementTest.php
new file mode 100644
index 0000000000..187c26b6e4
--- /dev/null
+++ b/core/modules/mysql/tests/src/Kernel/mysql/StatementTest.php
@@ -0,0 +1,25 @@
+<?php
+
+namespace Drupal\Tests\mysql\Kernel\mysql;
+
+use Drupal\KernelTests\Core\Database\DriverSpecificDatabaseTestBase;
+
+/**
+ * Tests for the Statement object.
+ *
+ * @group Database
+ */
+class StatementTest extends DriverSpecificDatabaseTestBase {
+
+  /**
+   * Tests deprecated ::getIterator.
+   *
+   * @group legacy
+   */
+  public function testGetIterator(): void {
+    $this->expectDeprecation('%s::getIterator() is deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. There is no replacement. See https://www.drupal.org/node/3265938');
+    $statement = $this->connection->prepareStatement('SELECT * FROM {test}', []);
+    $this->assertInstanceOf(\ArrayIterator::class, $statement->getIterator());
+  }
+
+}
diff --git a/core/modules/mysql/tests/src/Unit/ConnectionTest.php b/core/modules/mysql/tests/src/Unit/ConnectionTest.php
index 878d7672ad..bd7245d8c3 100644
--- a/core/modules/mysql/tests/src/Unit/ConnectionTest.php
+++ b/core/modules/mysql/tests/src/Unit/ConnectionTest.php
@@ -2,9 +2,11 @@
 
 namespace Drupal\Tests\mysql\Unit;
 
+use Drupal\Core\Database\StatementWrapper;
 use Drupal\mysql\Driver\Database\mysql\Connection;
 use Drupal\Tests\UnitTestCase;
 use Prophecy\Argument;
+use Prophecy\Prophecy\ObjectProphecy;
 
 /**
  * Tests MySQL database connections.
@@ -15,11 +17,9 @@
 class ConnectionTest extends UnitTestCase {
 
   /**
-   * A PDO statement prophecy.
-   *
-   * @var \PDOStatement|\Prophecy\Prophecy\ObjectProphecy
+   * A statement prophecy.
    */
-  private $pdoStatement;
+  private StatementWrapper|ObjectProphecy $statement;
 
   /**
    * A PDO object prophecy.
@@ -32,7 +32,7 @@ class ConnectionTest extends UnitTestCase {
    * {@inheritdoc}
    */
   protected function setUp(): void {
-    $this->pdoStatement = $this->prophesize(\PDOStatement::class);
+    $this->statement = $this->prophesize(StatementWrapper::class);
     $this->pdoConnection = $this->prophesize(\PDO::class);
   }
 
@@ -42,12 +42,12 @@ protected function setUp(): void {
    * @return \Drupal\mysql\Driver\Database\mysql\Connection
    */
   private function createConnection(): Connection {
-    $this->pdoStatement
+    $this->statement
       ->setFetchMode(Argument::any())
       ->shouldBeCalled()
       ->willReturn(TRUE);
 
-    $this->pdoStatement
+    $this->statement
       ->execute(Argument::any())
       ->shouldBeCalled()
       ->willReturn(TRUE);
@@ -55,7 +55,7 @@ private function createConnection(): Connection {
     $this->pdoConnection
       ->prepare('SELECT VERSION()', Argument::any())
       ->shouldBeCalled()
-      ->willReturn($this->pdoStatement->reveal());
+      ->willReturn($this->statement->reveal());
 
     /** @var \PDO $pdo_connection */
     $pdo_connection = $this->pdoConnection->reveal();
@@ -76,8 +76,8 @@ public function __construct(\PDO $connection) {
    * @dataProvider providerVersionAndIsMariaDb
    */
   public function testVersionAndIsMariaDb(bool $expected_is_mariadb, string $server_version, string $expected_version): void {
-    $this->pdoStatement
-      ->fetchColumn(Argument::any())
+    $this->statement
+      ->fetchField(Argument::any())
       ->shouldBeCalled()
       ->willReturn($server_version);
 
diff --git a/core/modules/pgsql/tests/src/Kernel/pgsql/StatementTest.php b/core/modules/pgsql/tests/src/Kernel/pgsql/StatementTest.php
new file mode 100644
index 0000000000..8d59d500a1
--- /dev/null
+++ b/core/modules/pgsql/tests/src/Kernel/pgsql/StatementTest.php
@@ -0,0 +1,25 @@
+<?php
+
+namespace Drupal\Tests\pgsql\Kernel\pgsql;
+
+use Drupal\KernelTests\Core\Database\DriverSpecificDatabaseTestBase;
+
+/**
+ * Tests for the Statement object.
+ *
+ * @group Database
+ */
+class StatementTest extends DriverSpecificDatabaseTestBase {
+
+  /**
+   * Tests deprecated ::getIterator.
+   *
+   * @group legacy
+   */
+  public function testGetIterator(): void {
+    $this->expectDeprecation('%s::getIterator() is deprecated in drupal:10.1.0 and is removed from drupal:11.0.0. There is no replacement. See https://www.drupal.org/node/3265938');
+    $statement = $this->connection->prepareStatement('SELECT * FROM {test}', []);
+    $this->assertInstanceOf(\ArrayIterator::class, $statement->getIterator());
+  }
+
+}
