diff --git a/core/lib/Drupal/Core/Database/Connection.php b/core/lib/Drupal/Core/Database/Connection.php
index f19f5c6b96..178288cf27 100644
--- a/core/lib/Drupal/Core/Database/Connection.php
+++ b/core/lib/Drupal/Core/Database/Connection.php
@@ -2,7 +2,6 @@
 
 namespace Drupal\Core\Database;
 
-use Drupal\Component\Assertion\Inspector;
 use Drupal\Core\Database\Query\Condition;
 use Drupal\Core\Database\Query\Delete;
 use Drupal\Core\Database\Query\Insert;
@@ -135,69 +134,9 @@
   protected $schema = NULL;
 
   /**
-   * The prefixes used by this database connection.
-   *
-   * @var array
-   */
-  protected $prefixes = [];
-
-  /**
-   * List of search values for use in prefixTables().
-   *
-   * @var array
-   */
-  protected $prefixSearch = [];
-
-  /**
-   * List of replacement values for use in prefixTables().
-   *
-   * @var array
-   */
-  protected $prefixReplace = [];
-
-  /**
-   * List of un-prefixed table names, keyed by prefixed table names.
-   *
-   * @var array
-   */
-  protected $unprefixedTablesMap = [];
-
-  /**
-   * List of escaped database, table, and field names, keyed by unescaped names.
-   *
-   * @var array
-   *
-   * @deprecated in drupal:9.0.0 and is removed from drupal:10.0.0. This is no
-   *   longer used. Use \Drupal\Core\Database\Connection::$escapedTables or
-   *   \Drupal\Core\Database\Connection::$escapedFields instead.
-   *
-   * @see https://www.drupal.org/node/2986894
-   */
-  protected $escapedNames = [];
-
-  /**
-   * List of escaped table names, keyed by unescaped names.
-   *
-   * @var array
-   */
-  protected $escapedTables = [];
-
-  /**
-   * List of escaped field names, keyed by unescaped names.
-   *
-   * There are cases in which escapeField() is called on an empty string. In
-   * this case it should always return an empty string.
-   *
-   * @var array
-   */
-  protected $escapedFields = ["" => ""];
-
-  /**
-   * List of escaped aliases names, keyed by unescaped aliases.
-   *
-   * @var array
+   * @todo
    */
-  protected $escapedAliases = [];
+  protected $identifierHandler;
 
   /**
    * Post-root (non-nested) transaction commit callbacks.
@@ -207,15 +146,16 @@
   protected $rootTransactionEndCallbacks = [];
 
   /**
-   * The identifier quote characters for the database type.
-   *
-   * An array containing the start and end identifier quote characters for the
-   * database type. The ANSI SQL standard identifier quote character is a double
-   * quotation mark.
+   * Implements the magic __get() method.
    *
-   * @var string[]
+   * @todo Remove the method in Drupal 10.
    */
-  protected $identifierQuotes;
+  public function __get($name) {
+    if (in_array($name, ['escapedNames', 'escapedTables', 'escapedFields', 'escapedAliases', 'identifierQuotes', 'prefixes', 'prefixSearch', 'prefixReplace', 'unprefixedTablesMap'])) {
+      @trigger_error("Connection::\${$name} should not be accessed in drupal:9.x.0 and is removed from drupal:10.0.0. This is no longer used. See https://www.drupal.org/node/1234567", E_USER_DEPRECATED);
+      return [];
+    }
+  }
 
   /**
    * Constructs a Connection object.
@@ -227,16 +167,8 @@
    *   - prefix
    *   - namespace
    *   - Other driver-specific options.
-   *   An 'extra_prefix' option may be present to allow BC for attaching
-   *   per-table prefixes, but it is meant for internal use only.
    */
   public function __construct(\PDO $connection, array $connection_options) {
-    if ($this->identifierQuotes === NULL) {
-      @trigger_error('In drupal:10.0.0 not setting the $identifierQuotes property in the concrete Connection class will result in an RuntimeException. See https://www.drupal.org/node/2986894', E_USER_DEPRECATED);
-      $this->identifierQuotes = ['', ''];
-    }
-
-    assert(count($this->identifierQuotes) === 2 && Inspector::assertAllStrings($this->identifierQuotes), '\Drupal\Core\Database\Connection::$identifierQuotes must contain 2 string values');
 
     // The 'transactions' option is deprecated.
     if (isset($connection_options['transactions'])) {
@@ -244,40 +176,6 @@ public function __construct(\PDO $connection, array $connection_options) {
       unset($connection_options['transactions']);
     }
 
-    // Manage the table prefix.
-    if (isset($connection_options['prefix']) && is_array($connection_options['prefix'])) {
-      if (count($connection_options['prefix']) > 1) {
-        // If there are keys left besides the 'default' one, we are in a
-        // multi-prefix scenario (for per-table prefixing, or migrations).
-        // In that case, we put the non-default keys in a 'extra_prefix' key
-        // to avoid mixing up with the normal 'prefix', which is a string since
-        // Drupal 9.1.0.
-        $prefix = $connection_options['prefix']['default'] ?? '';
-        unset($connection_options['prefix']['default']);
-        if (isset($connection_options['extra_prefix'])) {
-          $connection_options['extra_prefix'] = array_merge($connection_options['extra_prefix'], $connection_options['prefix']);
-        }
-        else {
-          $connection_options['extra_prefix'] = $connection_options['prefix'];
-        }
-      }
-      else {
-        $prefix = $connection_options['prefix']['default'] ?? '';
-      }
-      $connection_options['prefix'] = $prefix;
-    }
-
-    // Initialize and prepare the connection prefix.
-    if (!isset($connection_options['extra_prefix'])) {
-      $prefix = $connection_options['prefix'] ?? '';
-    }
-    else {
-      $default_prefix = $connection_options['prefix'] ?? '';
-      $prefix = $connection_options['extra_prefix'];
-      $prefix['default'] = $default_prefix;
-    }
-    $this->setPrefix($prefix);
-
     // Work out the database driver namespace if none is provided. This normally
     // written to setting.php by installer or set by
     // \Drupal\Core\Database\Database::parseConnectionInfo().
@@ -444,42 +342,7 @@ public function getConnectionOptions() {
    *   Either a single prefix, or an array of prefixes.
    */
   protected function setPrefix($prefix) {
-    if (is_array($prefix)) {
-      $this->prefixes = $prefix + ['default' => ''];
-    }
-    else {
-      $this->prefixes = ['default' => $prefix];
-    }
-
-    [$start_quote, $end_quote] = $this->identifierQuotes;
-    // Set up variables for use in prefixTables(). Replace table-specific
-    // prefixes first.
-    $this->prefixSearch = [];
-    $this->prefixReplace = [];
-    foreach ($this->prefixes as $key => $val) {
-      if ($key != 'default') {
-        $this->prefixSearch[] = '{' . $key . '}';
-        // $val can point to another database like 'database.users'. In this
-        // instance we need to quote the identifiers correctly.
-        $val = str_replace('.', $end_quote . '.' . $start_quote, $val);
-        $this->prefixReplace[] = $start_quote . $val . $key . $end_quote;
-      }
-    }
-    // Then replace remaining tables with the default prefix.
-    $this->prefixSearch[] = '{';
-    // $this->prefixes['default'] can point to another database like
-    // 'other_db.'. In this instance we need to quote the identifiers correctly.
-    // For example, "other_db"."PREFIX_table_name".
-    $this->prefixReplace[] = $start_quote . str_replace('.', $end_quote . '.' . $start_quote, $this->prefixes['default']);
-    $this->prefixSearch[] = '}';
-    $this->prefixReplace[] = $end_quote;
-
-    // Set up a map of prefixed => un-prefixed tables.
-    foreach ($this->prefixes as $table_name => $prefix) {
-      if ($table_name !== 'default') {
-        $this->unprefixedTablesMap[$prefix . $table_name] = $table_name;
-      }
-    }
+    @trigger_error(__METHOD__ . '() is deprecated in drupal:9.x.0 and is removed from drupal:10.0.0. @todo. See https://www.drupal.org/node/1234567', E_USER_DEPRECATED);
   }
 
   /**
@@ -497,7 +360,12 @@ protected function setPrefix($prefix) {
    *   The properly-prefixed string.
    */
   public function prefixTables($sql) {
-    return str_replace($this->prefixSearch, $this->prefixReplace, $sql);
+    $replacements = $tables = [];
+    preg_match_all('/(\{(\S*)\})/', $sql, $tables, PREG_SET_ORDER, 0);
+    foreach ($tables as $table) {
+      $replacements[$table[1]] = $this->identifierHandler->getPlatformTableName($table[2], TRUE, TRUE);
+    }
+    return str_replace(array_keys($replacements), array_values($replacements), $sql);
   }
 
   /**
@@ -521,7 +389,14 @@ public function prefixTables($sql) {
    *   This method should only be called by database API code.
    */
   public function quoteIdentifiers($sql) {
-    return str_replace(['[', ']'], $this->identifierQuotes, $sql);
+    preg_match_all('/(\[(.+?)\])/', $sql, $matches);
+    $identifiers = [];
+    $i = 0;
+    foreach ($matches[1] as $match) {
+      $identifiers[$match] = $this->identifierHandler->getPlatformIdentifierName($matches[2][$i]);
+      $i++;
+    }
+    return strtr($sql, $identifiers);
   }
 
   /**
@@ -534,12 +409,8 @@ public function quoteIdentifiers($sql) {
    *   (optional) The table to find the prefix for.
    */
   public function tablePrefix($table = 'default') {
-    if (isset($this->prefixes[$table])) {
-      return $this->prefixes[$table];
-    }
-    else {
-      return $this->prefixes['default'];
-    }
+    // @todo deprecate the $table argument.
+    return $this->identifierHandler->getTablePrefix();
   }
 
   /**
@@ -550,7 +421,8 @@ public function tablePrefix($table = 'default') {
    *   names (i.e. prefix + table_name).
    */
   public function getUnprefixedTablesMap() {
-    return $this->unprefixedTablesMap;
+    @trigger_error(__METHOD__ . '() is deprecated in drupal:9.x.0 and is removed from drupal:10.0.0. @todo. See https://www.drupal.org/node/1234567', E_USER_DEPRECATED);
+    return [];
   }
 
   /**
@@ -562,9 +434,7 @@ public function getUnprefixedTablesMap() {
    * @return string
    */
   public function getFullQualifiedTableName($table) {
-    $options = $this->getConnectionOptions();
-    $prefix = $this->tablePrefix($table);
-    return $options['database'] . '.' . $prefix . $table;
+    return $this->identifierHandler->getPlatformDatabaseName($this->getConnectionOptions()['database']) . '.' . $this->identifierHandler->getPlatformTableName($table, TRUE, TRUE);
   }
 
   /**
@@ -780,10 +650,7 @@ public function getLogger() {
    *   A table prefix-parsed string for the sequence name.
    */
   public function makeSequenceName($table, $field) {
-    $sequence_name = $this->prefixTables('{' . $table . '}_' . $field . '_seq');
-    // Remove identifier quotes as we are constructing a new name from a
-    // prefixed and quoted table name.
-    return str_replace($this->identifierQuotes, '', $sequence_name);
+    return $this->identifierHandler->getPlatformTableName($table, TRUE, FALSE) . "_{$field}_seq";
   }
 
   /**
@@ -1357,9 +1224,7 @@ public function condition($conjunction) {
    *   The sanitized database name.
    */
   public function escapeDatabase($database) {
-    $database = preg_replace('/[^A-Za-z0-9_]+/', '', $database);
-    [$start_quote, $end_quote] = $this->identifierQuotes;
-    return $start_quote . $database . $end_quote;
+    return $this->identifierHandler->getPlatformDatabaseName($database);
   }
 
   /**
@@ -1380,10 +1245,7 @@ public function escapeDatabase($database) {
    * @see \Drupal\Core\Database\Connection::setPrefix()
    */
   public function escapeTable($table) {
-    if (!isset($this->escapedTables[$table])) {
-      $this->escapedTables[$table] = preg_replace('/[^A-Za-z0-9_.]+/', '', $table);
-    }
-    return $this->escapedTables[$table];
+    return $this->identifierHandler->getPlatformTableName($table);
   }
 
   /**
@@ -1400,14 +1262,7 @@ public function escapeTable($table) {
    *   The sanitized field name.
    */
   public function escapeField($field) {
-    if (!isset($this->escapedFields[$field])) {
-      $escaped = preg_replace('/[^A-Za-z0-9_.]+/', '', $field);
-      [$start_quote, $end_quote] = $this->identifierQuotes;
-      // Sometimes fields have the format table_alias.field. In such cases
-      // both identifiers should be quoted, for example, "table_alias"."field".
-      $this->escapedFields[$field] = $start_quote . str_replace('.', $end_quote . '.' . $start_quote, $escaped) . $end_quote;
-    }
-    return $this->escapedFields[$field];
+    return $this->identifierHandler->getPlatformColumnName($field);
   }
 
   /**
@@ -1425,11 +1280,7 @@ public function escapeField($field) {
    *   The sanitized alias name.
    */
   public function escapeAlias($field) {
-    if (!isset($this->escapedAliases[$field])) {
-      [$start_quote, $end_quote] = $this->identifierQuotes;
-      $this->escapedAliases[$field] = $start_quote . preg_replace('/[^A-Za-z0-9_]+/', '', $field) . $end_quote;
-    }
-    return $this->escapedAliases[$field];
+    return $this->identifierHandler->getPlatformAliasName($field);
   }
 
   /**
@@ -2121,4 +1972,11 @@ public function getPagerManager(): PagerManagerInterface {
     return \Drupal::service('pager.manager');
   }
 
+  /**
+   * @todo
+   */
+  public function getIdentifierHandler(): IdentifierHandler {
+    return $this->identifierHandler;
+  }
+
 }
diff --git a/core/lib/Drupal/Core/Database/Database.php b/core/lib/Drupal/Core/Database/Database.php
index 2771166e48..ea6a96ce92 100644
--- a/core/lib/Drupal/Core/Database/Database.php
+++ b/core/lib/Drupal/Core/Database/Database.php
@@ -216,25 +216,8 @@
     }
 
     // Parse the prefix information.
-    // @todo in Drupal 10, fail hard if $info['prefix'] is an array.
-    // @see https://www.drupal.org/project/drupal/issues/3124382
-    if (!isset($info['prefix'])) {
-      // Default to an empty prefix.
-      $info['prefix'] = '';
-    }
-    elseif (is_array($info['prefix'])) {
-      $prefix = $info['prefix']['default'] ?? '';
-      unset($info['prefix']['default']);
-      // If there are keys left besides the 'default' one, we are in a
-      // multi-prefix scenario (for per-table prefixing, or migrations).
-      // In that case, we put the non-default keys in a 'extra_prefix' key
-      // to avoid mixing up with the normal 'prefix', which is a string since
-      // Drupal 9.1.0.
-      if (count($info['prefix'])) {
-        $info['extra_prefix'] = $info['prefix'];
-      }
-      $info['prefix'] = $prefix;
-    }
+    $info['prefix'] = $info['prefix'] ?? '';
+    assert(is_string($info['prefix']), "The 'prefix' key of the database connection array must be a string.");
 
     // Fallback for Drupal 7 settings.php if namespace is not provided.
     if (empty($info['namespace'])) {
diff --git a/core/lib/Drupal/Core/Database/Driver/mysql/Connection.php b/core/lib/Drupal/Core/Database/Driver/mysql/Connection.php
index ef6027256c..3fb737c7fc 100644
--- a/core/lib/Drupal/Core/Database/Driver/mysql/Connection.php
+++ b/core/lib/Drupal/Core/Database/Driver/mysql/Connection.php
@@ -11,6 +11,7 @@
 use Drupal\Core\Database\DatabaseNotFoundException;
 use Drupal\Core\Database\DatabaseException;
 use Drupal\Core\Database\Connection as DatabaseConnection;
+use Drupal\Core\Database\IdentifierHandler;
 use Drupal\Core\Database\TransactionNoActiveException;
 
 /**
@@ -84,11 +85,6 @@ class Connection extends DatabaseConnection {
    */
   const MIN_MAX_ALLOWED_PACKET = 1024;
 
-  /**
-   * {@inheritdoc}
-   */
-  protected $identifierQuotes = ['"', '"'];
-
   /**
    * {@inheritdoc}
    */
@@ -112,10 +108,11 @@ public function __construct(\PDO $connection, array $connection_options) {
         break;
       }
     }
-    if ($this->identifierQuotes === ['"', '"'] && !$is_ansi_quotes_mode) {
-      $this->identifierQuotes = ['`', '`'];
-    }
+
     parent::__construct($connection, $connection_options);
+
+    // Initialize the identifier handler.
+    $this->identifierHandler = new IdentifierHandler($connection_options['prefix'], $is_ansi_quotes_mode ? ['"', '"'] : ['`', '`']);
   }
 
   /**
diff --git a/core/lib/Drupal/Core/Database/Driver/mysql/Schema.php b/core/lib/Drupal/Core/Database/Driver/mysql/Schema.php
index e05f10c86e..aaca542c50 100644
--- a/core/lib/Drupal/Core/Database/Driver/mysql/Schema.php
+++ b/core/lib/Drupal/Core/Database/Driver/mysql/Schema.php
@@ -48,9 +48,13 @@ class Schema extends DatabaseSchema {
    *   A keyed array with information about the database, table name and prefix.
    */
   protected function getPrefixInfo($table = 'default', $add_prefix = TRUE) {
-    $info = ['prefix' => $this->connection->tablePrefix($table)];
-    if ($add_prefix) {
-      $table = $info['prefix'] . $table;
+    $prefix = $this->connection->tablePrefix($table);
+    $info = ['prefix' => $prefix];
+    if (strpos($table, '%') !== FALSE) {
+      $table = ($add_prefix ? $prefix : '') . $table;
+    }
+    else {
+      $table = $this->connection->getIdentifierHandler()->getPlatformTableName($table ?? '', $add_prefix);
     }
     if (($pos = strpos($table, '.')) !== FALSE) {
       $info['database'] = substr($table, 0, $pos);
diff --git a/core/lib/Drupal/Core/Database/Driver/pgsql/Connection.php b/core/lib/Drupal/Core/Database/Driver/pgsql/Connection.php
index a5b6ae3296..778cd54e0c 100644
--- a/core/lib/Drupal/Core/Database/Driver/pgsql/Connection.php
+++ b/core/lib/Drupal/Core/Database/Driver/pgsql/Connection.php
@@ -6,6 +6,7 @@
 use Drupal\Core\Database\Connection as DatabaseConnection;
 use Drupal\Core\Database\DatabaseAccessDeniedException;
 use Drupal\Core\Database\DatabaseNotFoundException;
+use Drupal\Core\Database\IdentifierHandler;
 use Drupal\Core\Database\StatementInterface;
 use Drupal\Core\Database\StatementWrapper;
 
@@ -68,11 +69,6 @@ class Connection extends DatabaseConnection {
    */
   protected $transactionalDDLSupport = TRUE;
 
-  /**
-   * {@inheritdoc}
-   */
-  protected $identifierQuotes = ['"', '"'];
-
   /**
    * Constructs a connection object.
    */
@@ -86,6 +82,9 @@ public function __construct(\PDO $connection, array $connection_options) {
     if (isset($connection_options['init_commands'])) {
       $this->connection->exec(implode('; ', $connection_options['init_commands']));
     }
+
+    // Initialize the identifier handler.
+    $this->identifierHandler = new IdentifierHandler($connection_options['prefix']);
   }
 
   /**
@@ -313,13 +312,10 @@ public function nextId($existing = 0) {
    * {@inheritdoc}
    */
   public function getFullQualifiedTableName($table) {
-    $options = $this->getConnectionOptions();
-    $prefix = $this->tablePrefix($table);
-
     // The fully qualified table name in PostgreSQL is in the form of
     // <database>.<schema>.<table>, so we have to include the 'public' schema in
     // the return value.
-    return $options['database'] . '.public.' . $prefix . $table;
+    return $this->getConnectionOptions()['database'] . '.public.' . $this->identifierHandler->getPlatformTableName($table, TRUE, FALSE);
   }
 
   /**
diff --git a/core/lib/Drupal/Core/Database/Driver/pgsql/Schema.php b/core/lib/Drupal/Core/Database/Driver/pgsql/Schema.php
index 106add49ef..4b186dfa4d 100644
--- a/core/lib/Drupal/Core/Database/Driver/pgsql/Schema.php
+++ b/core/lib/Drupal/Core/Database/Driver/pgsql/Schema.php
@@ -511,8 +511,15 @@ public function tableExists($table) {
    * {@inheritdoc}
    */
   public function findTables($table_expression) {
-    $individually_prefixed_tables = $this->connection->getUnprefixedTablesMap();
-    $default_prefix = $this->connection->tablePrefix();
+    // Set up a map of prefixed => un-prefixed tables.
+    $individually_prefixed_tables = [];
+    foreach ($this->connection->getIdentifierHandler()->getPrefix() as $table_name => $prefix) {
+      if ($table_name !== 'default') {
+        $individually_prefixed_tables[$prefix . $table_name] = $table_name;
+      }
+    }
+
+    $default_prefix = $this->connection->tablePrefix('default');
     $default_prefix_length = strlen($default_prefix);
     $tables = [];
 
diff --git a/core/lib/Drupal/Core/Database/Driver/sqlite/Connection.php b/core/lib/Drupal/Core/Database/Driver/sqlite/Connection.php
index bb1c15def9..5c4ab61def 100644
--- a/core/lib/Drupal/Core/Database/Driver/sqlite/Connection.php
+++ b/core/lib/Drupal/Core/Database/Driver/sqlite/Connection.php
@@ -4,6 +4,7 @@
 
 use Drupal\Core\Database\DatabaseNotFoundException;
 use Drupal\Core\Database\Connection as DatabaseConnection;
+use Drupal\Core\Database\IdentifierHandler;
 use Drupal\Core\Database\StatementInterface;
 
 /**
@@ -73,11 +74,6 @@ class Connection extends DatabaseConnection {
    */
   protected $transactionalDDLSupport = TRUE;
 
-  /**
-   * {@inheritdoc}
-   */
-  protected $identifierQuotes = ['"', '"'];
-
   /**
    * Constructs a \Drupal\Core\Database\Driver\sqlite\Connection object.
    */
@@ -85,7 +81,7 @@ public function __construct(\PDO $connection, array $connection_options) {
     parent::__construct($connection, $connection_options);
 
     // Attach one database for each registered prefix.
-    $prefixes = $this->prefixes;
+    $prefixes = ['default' => $connection_options['prefix'] ?? ''];
     foreach ($prefixes as &$prefix) {
       // Empty prefix means query the main database -- no need to attach anything.
       if (!empty($prefix)) {
@@ -108,8 +104,9 @@ public function __construct(\PDO $connection, array $connection_options) {
         $prefix .= '.';
       }
     }
-    // Regenerate the prefixes replacement table.
-    $this->setPrefix($prefixes);
+
+    // Initialize the identifier handler.
+    $this->identifierHandler = new IdentifierHandler($connection_options['prefix'] ?? '');
   }
 
   /**
@@ -391,9 +388,7 @@ public function queryTemporary($query, array $args = [], array $options = []) {
     // Generate a new temporary table name and protect it from prefixing.
     // SQLite requires that temporary tables to be non-qualified.
     $tablename = $this->generateTemporaryTableName();
-    $prefixes = $this->prefixes;
-    $prefixes[$tablename] = '';
-    $this->setPrefix($prefixes);
+    $this->identifierHandler->addPrefix($tablename, '');
 
     $this->query('CREATE TEMPORARY TABLE ' . $tablename . ' AS ' . $query, $args, $options);
     return $tablename;
@@ -469,10 +464,7 @@ public function nextId($existing_id = 0) {
    * {@inheritdoc}
    */
   public function getFullQualifiedTableName($table) {
-    $prefix = $this->tablePrefix($table);
-
-    // Don't include the SQLite database file name as part of the table name.
-    return $prefix . $table;
+    return 'main.' . $this->identifierHandler->getPlatformTableName($table, TRUE, TRUE);
   }
 
   /**
diff --git a/core/lib/Drupal/Core/Database/IdentifierHandler.php b/core/lib/Drupal/Core/Database/IdentifierHandler.php
new file mode 100644
index 0000000000..5742e0a272
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/IdentifierHandler.php
@@ -0,0 +1,198 @@
+<?php
+
+namespace Drupal\Core\Database;
+
+/**
+ * @todo
+ */
+class IdentifierHandler {
+
+  const GENERIC = 0x0;
+  const DATABASE = 0x4;
+  const SEQUENCE = 0x5;
+  const TABLE = 0x7;
+  const PREFIXED_TABLE = 0x8;
+  const COLUMN = 0xC;
+  const INDEX = 0xD;
+  const ALIAS = 0x10;
+
+  /**
+   * The identifier quote characters for the database type.
+   *
+   * An array containing the start and end identifier quote characters for the
+   * database type. The ANSI SQL standard identifier quote character is a double
+   * quotation mark.
+   *
+   * @var string[]
+   */
+  protected $identifierQuotes;
+
+  /**
+   * The table prefix used by this database connection.
+   *
+   * @var string
+   *
+   * @todo add property 'string' typehint for PHP 8.0.
+   */
+  protected $tablePrefix;
+
+  /**
+   * @todo
+   */
+  protected $identifiers;
+
+  /**
+   * Constructs an IdentifierHandler object.
+   *
+   * @param string $table_prefix
+   *   The table prefix to be used by the database connection.
+   * @param string[] $identifier_quotes
+   *   The identifier quote characters.
+   */
+  public function __construct(string $table_prefix, array $identifier_quotes = ['"', '"']) {
+    $this->tablePrefix = $table_prefix;
+    $this->identifierQuotes = $identifier_quotes;
+  }
+
+  /**
+   * @todo
+   */
+  public function getTablePrefix(): string {
+    return $this->tablePrefix;
+  }
+
+  /**
+   * @todo
+   */
+  protected function setIdentifier(string $identifier, string $platform_identifier, int $type): void {
+    $is_alias = (bool) ($type & static::ALIAS);
+    $type = $type & 0xF;
+    if (!$is_alias) {
+      $this->identifiers['identifier'][$identifier][$type] = $platform_identifier;
+      $this->identifiers['platform'][$platform_identifier][$type] = $identifier;
+    }
+    else {
+      $this->identifiers['identifier'][$identifier][static::ALIAS][$type] = $platform_identifier;
+      $this->identifiers['platform'][$platform_identifier][static::ALIAS][$type] = $identifier;
+    }
+  }
+
+  /**
+   * @todo
+   */
+  protected function hasIdentifier(string $identifier, int $type = 0): bool {
+    return isset($this->identifiers['identifier'][$identifier][$type]);
+  }
+
+  /**
+   * @todo
+   */
+  public function getPlatformIdentifierName(string $original_name, bool $quoted = TRUE): string {
+    if (!$this->hasIdentifier($original_name, static::GENERIC)) {
+      $this->setIdentifier($original_name, $this->resolvePlatformGenericIdentifier($original_name), static::GENERIC);
+    }
+    [$start_quote, $end_quote] = $this->identifierQuotes;
+    $identifier = $this->identifiers['identifier'][$original_name][static::GENERIC];
+    return $quoted ? $start_quote . $identifier . $end_quote : $identifier;
+  }
+
+  /**
+   * @todo
+   */
+  public function getPlatformDatabaseName(string $original_name, bool $quoted = TRUE): string {
+    $original_name = preg_replace('/[^A-Za-z0-9_]+/', '', $original_name);
+    if (!$this->hasIdentifier($original_name, static::DATABASE)) {
+      $this->setIdentifier($original_name, $this->resolvePlatformDatabaseIdentifier($original_name), static::DATABASE);
+    }
+    [$start_quote, $end_quote] = $this->identifierQuotes;
+    return $quoted ?
+      $start_quote . $this->identifiers['identifier'][$original_name][static::DATABASE] . $end_quote :
+      $this->identifiers['identifier'][$original_name][static::DATABASE];
+  }
+
+  /**
+   * @todo
+   */
+  public function getPlatformTableName(string $original_name, bool $prefixed = FALSE, bool $quoted = FALSE): string {
+    $original_name = preg_replace('/[^A-Za-z0-9_.]+/', '', $original_name);
+    if (!$this->hasIdentifier($original_name, static::TABLE)) {
+      $table_name = $this->resolvePlatformTableIdentifier($original_name);
+      $this->setIdentifier($original_name, $table_name, static::TABLE);
+      $this->setIdentifier($original_name, $this->getTablePrefix() . $table_name, static::PREFIXED_TABLE);
+    }
+    [$start_quote, $end_quote] = $this->identifierQuotes;
+    $table = $prefixed ? $this->identifiers['identifier'][$original_name][static::PREFIXED_TABLE] : $this->identifiers['identifier'][$original_name][static::TABLE];
+    return $quoted ? $start_quote . str_replace(".", "$end_quote.$start_quote", $table) . $end_quote : $table;
+  }
+
+  /**
+   * @todo
+   */
+  public function getPlatformColumnName(string $original_name, bool $quoted = TRUE): string {
+    if ($original_name === '') {
+      return '';
+    }
+    $original_name = preg_replace('/[^A-Za-z0-9_.]+/', '', $original_name);
+    if (!$this->hasIdentifier($original_name, static::COLUMN)) {
+      $this->setIdentifier($original_name, $this->resolvePlatformColumnIdentifier($original_name), static::COLUMN);
+    }
+    // Sometimes fields have the format table_alias.field. In such cases
+    // both identifiers should be quoted, for example, "table_alias"."field".
+    [$start_quote, $end_quote] = $this->identifierQuotes;
+    return $quoted ?
+      $start_quote . str_replace(".", "$end_quote.$start_quote", $this->identifiers['identifier'][$original_name][static::COLUMN]) . $end_quote :
+      $this->identifiers['identifier'][$original_name][static::COLUMN];
+  }
+
+  /**
+   * @todo
+   */
+  public function getPlatformAliasName(string $original_name, int $type = 0, bool $quoted = TRUE): string {
+    $original_name = preg_replace('/[^A-Za-z0-9_]+/', '', $original_name);
+    if ($original_name[0] === $this->identifierQuotes[0]) {
+      $original_name = substr($original_name, 1, -1);
+    }
+    if (!$this->hasIdentifier($original_name, static::ALIAS)) {
+      $this->setIdentifier($original_name, $this->resolvePlatformGenericIdentifier($original_name, $type), $type | static::ALIAS);
+    }
+    [$start_quote, $end_quote] = $this->identifierQuotes;
+    $alias = $this->identifiers['identifier'][$original_name][static::ALIAS][$type] ?? $this->identifiers['identifier'][$original_name][static::ALIAS][0];
+    return $quoted ? $start_quote . $alias . $end_quote : $alias;
+  }
+
+  /**
+   * @todo
+   */
+  protected function resolvePlatformGenericIdentifier(string $identifier): string {
+    return $identifier;
+  }
+
+  /**
+   * @todo
+   */
+  protected function resolvePlatformDatabaseIdentifier(string $identifier): string {
+    return $identifier;
+  }
+
+  /**
+   * @todo
+   */
+  protected function resolvePlatformTableIdentifier(string $identifier): string {
+    return $identifier;
+  }
+
+  /**
+   * @todo
+   */
+  protected function resolvePlatformColumnIdentifier(string $identifier): string {
+    return $identifier;
+  }
+
+  /**
+   * @todo
+   */
+  protected function resolvePlatformAliasIdentifier(string $identifier, int $type = 0): string {
+    return $identifier;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Database/Schema.php b/core/lib/Drupal/Core/Database/Schema.php
index 9083b27492..71c71c4461 100644
--- a/core/lib/Drupal/Core/Database/Schema.php
+++ b/core/lib/Drupal/Core/Database/Schema.php
@@ -82,12 +82,16 @@ public function nextPlaceholder() {
    *   A keyed array with information about the schema, table name and prefix.
    */
   protected function getPrefixInfo($table = 'default', $add_prefix = TRUE) {
+    $prefix = $this->connection->tablePrefix($table);
     $info = [
       'schema' => $this->defaultSchema,
-      'prefix' => $this->connection->tablePrefix($table),
+      'prefix' => $prefix,
     ];
-    if ($add_prefix) {
-      $table = $info['prefix'] . $table;
+    if (strpos($table, '%') !== FALSE) {
+      $table = ($add_prefix ? $prefix : '') . $table;
+    }
+    else {
+      $table = $this->connection->getIdentifierHandler()->getPlatformTableName($table ?? '', $add_prefix);
     }
     // If the prefix contains a period in it, then that means the prefix also
     // contains a schema reference in which case we will change the schema key
@@ -191,8 +195,10 @@ public function findTables($table_expression) {
     $condition = $this->buildTableNameCondition('%', 'LIKE');
     $condition->compile($this->connection, $this);
 
-    $individually_prefixed_tables = $this->connection->getUnprefixedTablesMap();
-    $default_prefix = $this->connection->tablePrefix();
+    // Set up a map of prefixed => un-prefixed tables.
+    $individually_prefixed_tables = [];
+
+    $default_prefix = $this->connection->tablePrefix('default');
     $default_prefix_length = strlen($default_prefix);
     $tables = [];
     // Normally, we would heartily discourage the use of string
diff --git a/core/modules/migrate/tests/src/Unit/MigrateSqlIdMapTest.php b/core/modules/migrate/tests/src/Unit/MigrateSqlIdMapTest.php
index 31f456233b..147149d213 100644
--- a/core/modules/migrate/tests/src/Unit/MigrateSqlIdMapTest.php
+++ b/core/modules/migrate/tests/src/Unit/MigrateSqlIdMapTest.php
@@ -971,7 +971,7 @@ public function testGetQualifiedMapTablePrefix() {
     // The SQLite driver is a special flower. It will prefix tables with
     // PREFIX.TABLE, instead of the standard PREFIXTABLE.
     // @see \Drupal\Core\Database\Driver\sqlite\Connection::__construct()
-    $this->assertEquals('prefix.migrate_map_sql_idmap_test', $qualified_map_table);
+    $this->assertEquals('"prefix"."migrate_map_sql_idmap_test"', $qualified_map_table);
   }
 
   /**
diff --git a/core/modules/system/tests/src/Functional/Database/TemporaryQueryTest.php b/core/modules/system/tests/src/Functional/Database/TemporaryQueryTest.php
deleted file mode 100644
index 419363a2cb..0000000000
--- a/core/modules/system/tests/src/Functional/Database/TemporaryQueryTest.php
+++ /dev/null
@@ -1,67 +0,0 @@
-<?php
-
-namespace Drupal\Tests\system\Functional\Database;
-
-use Drupal\Core\Database\Database;
-
-/**
- * Tests the temporary query functionality.
- *
- * @group Database
- * @group legacy
- */
-class TemporaryQueryTest extends DatabaseTestBase {
-
-  /**
-   * {@inheritdoc}
-   */
-  protected static $modules = ['database_test'];
-
-  /**
-   * {@inheritdoc}
-   */
-  protected $defaultTheme = 'stark';
-
-  /**
-   * Returns the number of rows of a table.
-   */
-  public function countTableRows($table_name) {
-    return Database::getConnection()->select($table_name)->countQuery()->execute()->fetchField();
-  }
-
-  /**
-   * Confirms that temporary tables work and are limited to one request.
-   */
-  public function testTemporaryQuery() {
-    $this->expectDeprecation('Connection::queryTemporary() is deprecated in drupal:9.3.0 and is removed from drupal:10.0.0. There is no replacement. See https://www.drupal.org/node/3211781');
-    $this->expectDeprecation('Connection::generateTemporaryTableName() is deprecated in drupal:9.3.0 and is removed from drupal:10.0.0. There is no replacement. See https://www.drupal.org/node/3211781');
-
-    $connection = Database::getConnection();
-    $this->drupalGet('database_test/db_query_temporary');
-    $data = json_decode($this->getSession()->getPage()->getContent());
-    if ($data) {
-      $this->assertEquals($this->countTableRows('test'), $data->row_count, 'The temporary table contains the correct amount of rows.');
-      $this->assertFalse($connection->schema()->tableExists($data->table_name), 'The temporary table is, indeed, temporary.');
-    }
-    else {
-      $this->fail('The creation of the temporary table failed.');
-    }
-
-    // Now try to run two temporary queries in the same request.
-    $table_name_test = $connection->queryTemporary('SELECT [name] FROM {test}', []);
-    $table_name_task = $connection->queryTemporary('SELECT [pid] FROM {test_task}', []);
-
-    $this->assertEquals($this->countTableRows('test'), $this->countTableRows($table_name_test), 'A temporary table was created successfully in this request.');
-    $this->assertEquals($this->countTableRows('test_task'), $this->countTableRows($table_name_task), 'A second temporary table was created successfully in this request.');
-
-    // Check that leading whitespace and comments do not cause problems
-    // in the modified query.
-    $sql = "
-      -- Let's select some rows into a temporary table
-      SELECT [name] FROM {test}
-    ";
-    $table_name_test = $connection->queryTemporary($sql, []);
-    $this->assertEquals($this->countTableRows('test'), $this->countTableRows($table_name_test), 'Leading white space and comments do not interfere with temporary table creation.');
-  }
-
-}
diff --git a/core/tests/Drupal/FunctionalTests/Installer/InstallerWithTablePrefixArrayTest.php b/core/tests/Drupal/FunctionalTests/Installer/InstallerWithTablePrefixArrayTest.php
deleted file mode 100644
index ca645e95a7..0000000000
--- a/core/tests/Drupal/FunctionalTests/Installer/InstallerWithTablePrefixArrayTest.php
+++ /dev/null
@@ -1,41 +0,0 @@
-<?php
-
-namespace Drupal\FunctionalTests\Installer;
-
-/**
- * Tests the interactive installer with deprecated table prefix array.
- *
- * @group Installer
- */
-class InstallerWithTablePrefixArrayTest extends InstallerTestBase {
-
-  /**
-   * {@inheritdoc}
-   */
-  protected $defaultTheme = 'stark';
-
-  /**
-   * Ensures that the status report raises the warning after installation.
-   */
-  public function testInstall(): void {
-    $this->drupalGet('admin/reports/status');
-    $this->assertSession()->pageTextNotContains("There is at least one database entry in the \$database array in settings.php that has a 'prefix' value in the format of an array. Per-table prefixes are no longer supported.");
-
-    // Add a database with a multi-entry 'prefix' array.
-    $settings['databases']['test_fu']['default'] = (object) [
-      'value' => [
-        'database' => 'drupal_db',
-        'prefix' => ['default' => 'foo', 'other_table' => 'qux'],
-        'host' => 'localhost',
-        'namespace' => 'Drupal\Core\Database\Driver\sqlite',
-        'driver' => 'sqlite',
-      ],
-      'required' => TRUE,
-    ];
-    $this->writeSettings($settings);
-
-    $this->drupalGet('admin/reports/status');
-    $this->assertSession()->pageTextContains("There is at least one database entry in the \$database array in settings.php that has a 'prefix' value in the format of an array. Per-table prefixes are no longer supported.");
-  }
-
-}
diff --git a/core/tests/Drupal/KernelTests/Core/Database/ConnectionTest.php b/core/tests/Drupal/KernelTests/Core/Database/ConnectionTest.php
index 570146fc10..11f046bb3b 100644
--- a/core/tests/Drupal/KernelTests/Core/Database/ConnectionTest.php
+++ b/core/tests/Drupal/KernelTests/Core/Database/ConnectionTest.php
@@ -176,13 +176,10 @@ public function testPerTablePrefixOption() {
       'test_table' => $connection_info['default']['prefix'] . '_bar',
     ];
     Database::addConnectionInfo('default', 'foo', $new_connection_info);
+
+    $this->expectException(\AssertionError::class);
+    $this->expectExceptionMessage("The 'prefix' key of the database connection array must be a string.");
     $foo_connection = Database::getConnection('foo', 'default');
-    $this->assertInstanceOf(Connection::class, $foo_connection);
-    $this->assertIsString($foo_connection->getConnectionOptions()['prefix']);
-    $this->assertSame($connection_info['default']['prefix'], $foo_connection->getConnectionOptions()['prefix']);
-    $this->assertSame([
-      'test_table' => $connection_info['default']['prefix'] . '_bar',
-    ], $foo_connection->getConnectionOptions()['extra_prefix']);
   }
 
   /**
@@ -195,11 +192,10 @@ public function testPrefixArrayOption() {
       'default' => $connection_info['default']['prefix'],
     ];
     Database::addConnectionInfo('default', 'foo', $new_connection_info);
+
+    $this->expectException(\AssertionError::class);
+    $this->expectExceptionMessage("The 'prefix' key of the database connection array must be a string.");
     $foo_connection = Database::getConnection('foo', 'default');
-    $this->assertInstanceOf(Connection::class, $foo_connection);
-    $this->assertIsString($foo_connection->getConnectionOptions()['prefix']);
-    $this->assertSame($connection_info['default']['prefix'], $foo_connection->getConnectionOptions()['prefix']);
-    $this->assertArrayNotHasKey('extra_prefix', $foo_connection->getConnectionOptions());
   }
 
   /**
diff --git a/core/tests/Drupal/KernelTests/Core/Database/SchemaTest.php b/core/tests/Drupal/KernelTests/Core/Database/SchemaTest.php
index eb8ea41d37..3b5ed6dbb2 100644
--- a/core/tests/Drupal/KernelTests/Core/Database/SchemaTest.php
+++ b/core/tests/Drupal/KernelTests/Core/Database/SchemaTest.php
@@ -1197,20 +1197,6 @@ public function testFindPrimaryKeyColumns() {
    * Tests the findTables() method.
    */
   public function testFindTables() {
-    // We will be testing with three tables, two of them using the default
-    // prefix and the third one with an individually specified prefix.
-    // Set up a new connection with different connection info.
-    $connection_info = Database::getConnectionInfo();
-
-    // Add per-table prefix to the second table.
-    $new_connection_info = $connection_info['default'];
-    $new_connection_info['prefix'] = [
-      'default' => $connection_info['default']['prefix'],
-      'test_2_table' => $connection_info['default']['prefix'] . '_shared_',
-    ];
-    Database::addConnectionInfo('test', 'default', $new_connection_info);
-    Database::setActiveConnection('test');
-    $test_schema = Database::getConnection()->schema();
 
     // Create the tables.
     $table_specification = [
@@ -1222,35 +1208,31 @@ public function testFindTables() {
         ],
       ],
     ];
-    $test_schema->createTable('test_1_table', $table_specification);
-    $test_schema->createTable('test_2_table', $table_specification);
-    $test_schema->createTable('the_third_table', $table_specification);
+    $this->schema->createTable('test_1_table', $table_specification);
+    $this->schema->createTable('test_2_table', $table_specification);
+    $this->schema->createTable('the_third_table', $table_specification);
 
     // Check the "all tables" syntax.
-    $tables = $test_schema->findTables('%');
+    $tables = $this->schema->findTables('%');
     sort($tables);
     $expected = [
       // The 'config' table is added by
       // \Drupal\KernelTests\KernelTestBase::containerBuild().
       'config',
       'test_1_table',
-      // This table uses a per-table prefix, yet it is returned as un-prefixed.
       'test_2_table',
       'the_third_table',
     ];
     $this->assertEquals($expected, $tables, 'All tables were found.');
 
     // Check the restrictive syntax.
-    $tables = $test_schema->findTables('test_%');
+    $tables = $this->schema->findTables('test_%');
     sort($tables);
     $expected = [
       'test_1_table',
       'test_2_table',
     ];
     $this->assertEquals($expected, $tables, 'Two tables were found.');
-
-    // Go back to the initial connection.
-    Database::setActiveConnection('default');
   }
 
   /**
diff --git a/core/tests/Drupal/KernelTests/KernelTestBaseDatabaseDriverModuleTest.php b/core/tests/Drupal/KernelTests/KernelTestBaseDatabaseDriverModuleTest.php
index b72e2972e2..72595efc32 100644
--- a/core/tests/Drupal/KernelTests/KernelTestBaseDatabaseDriverModuleTest.php
+++ b/core/tests/Drupal/KernelTests/KernelTestBaseDatabaseDriverModuleTest.php
@@ -44,9 +44,7 @@ protected function getDatabaseConnectionInfo() {
       foreach ($connection_info as $target => $value) {
         // Replace the full table prefix definition to ensure that no table
         // prefixes of the test runner leak into the test.
-        $connection_info[$target]['prefix'] = [
-          'default' => $this->databasePrefix,
-        ];
+        $connection_info[$target]['prefix'] = $this->databasePrefix;
       }
     }
     return $connection_info;
diff --git a/core/tests/Drupal/Tests/Core/Database/ConnectionTest.php b/core/tests/Drupal/Tests/Core/Database/ConnectionTest.php
index b105f79192..11331fbd22 100644
--- a/core/tests/Drupal/Tests/Core/Database/ConnectionTest.php
+++ b/core/tests/Drupal/Tests/Core/Database/ConnectionTest.php
@@ -3,6 +3,7 @@
 namespace Drupal\Tests\Core\Database;
 
 use Composer\Autoload\ClassLoader;
+use Drupal\Core\Database\Connection;
 use Drupal\Core\Database\Statement;
 use Drupal\Core\Database\StatementWrapper;
 use Drupal\Tests\Core\Database\Stub\StubConnection;
@@ -18,55 +19,6 @@
  */
 class ConnectionTest extends UnitTestCase {
 
-  /**
-   * Data provider for testPrefixRoundTrip().
-   *
-   * @return array
-   *   Array of arrays with the following elements:
-   *   - Arguments to pass to Connection::setPrefix().
-   *   - Expected result from Connection::tablePrefix().
-   */
-  public function providerPrefixRoundTrip() {
-    return [
-      [
-        ['' => 'test_'],
-        'test_',
-      ],
-      [
-        [
-          'fooTable' => 'foo_',
-          'barTable' => 'bar_',
-        ],
-        [
-          'fooTable' => 'foo_',
-          'barTable' => 'bar_',
-        ],
-      ],
-    ];
-  }
-
-  /**
-   * Exercise setPrefix() and tablePrefix().
-   *
-   * @dataProvider providerPrefixRoundTrip
-   */
-  public function testPrefixRoundTrip($expected, $prefix_info) {
-    $mock_pdo = $this->createMock('Drupal\Tests\Core\Database\Stub\StubPDO');
-    $connection = new StubConnection($mock_pdo, []);
-
-    // setPrefix() is protected, so we make it accessible with reflection.
-    $reflection = new \ReflectionClass('Drupal\Tests\Core\Database\Stub\StubConnection');
-    $set_prefix = $reflection->getMethod('setPrefix');
-    $set_prefix->setAccessible(TRUE);
-
-    // Set the prefix data.
-    $set_prefix->invokeArgs($connection, [$prefix_info]);
-    // Check the round-trip.
-    foreach ($expected as $table => $prefix) {
-      $this->assertEquals($prefix, $connection->tablePrefix($table));
-    }
-  }
-
   /**
    * Data provider for testPrefixTables().
    *
@@ -612,29 +564,11 @@ public function testEscapeDatabase($expected, $name, array $identifier_quote = [
    * @group legacy
    */
   public function testIdentifierQuotesDeprecation() {
-    $this->expectDeprecation('In drupal:10.0.0 not setting the $identifierQuotes property in the concrete Connection class will result in an RuntimeException. See https://www.drupal.org/node/2986894');
-    $mock_pdo = $this->createMock(StubPDO::class);
-    new StubConnection($mock_pdo, [], NULL);
-  }
-
-  /**
-   * @covers ::__construct
-   */
-  public function testIdentifierQuotesAssertCount() {
-    $this->expectException(\AssertionError::class);
-    $this->expectExceptionMessage('\Drupal\Core\Database\Connection::$identifierQuotes must contain 2 string values');
-    $mock_pdo = $this->createMock(StubPDO::class);
-    new StubConnection($mock_pdo, [], ['"']);
-  }
-
-  /**
-   * @covers ::__construct
-   */
-  public function testIdentifierQuotesAssertString() {
-    $this->expectException(\AssertionError::class);
-    $this->expectExceptionMessage('\Drupal\Core\Database\Connection::$identifierQuotes must contain 2 string values');
+    $this->expectDeprecation('Connection::$identifierQuotes should not be accessed in drupal:9.x.0 and is removed from drupal:10.0.0. This is no longer used. See https://www.drupal.org/node/1234567');
     $mock_pdo = $this->createMock(StubPDO::class);
-    new StubConnection($mock_pdo, [], [0, '1']);
+    $mock_connection = new StubConnection($mock_pdo, [], ['"', '"']);
+    $this->assertInstanceOf(Connection::class, $mock_connection);
+    $test_identifier_quotes = $mock_connection->identifierQuotes;
   }
 
   /**
diff --git a/core/tests/Drupal/Tests/Core/Database/Stub/StubConnection.php b/core/tests/Drupal/Tests/Core/Database/Stub/StubConnection.php
index b553dcce0d..c7d1716f10 100644
--- a/core/tests/Drupal/Tests/Core/Database/Stub/StubConnection.php
+++ b/core/tests/Drupal/Tests/Core/Database/Stub/StubConnection.php
@@ -3,6 +3,7 @@
 namespace Drupal\Tests\Core\Database\Stub;
 
 use Drupal\Core\Database\Connection;
+use Drupal\Core\Database\IdentifierHandler;
 use Drupal\Core\Database\Log;
 use Drupal\Core\Database\StatementWrapper;
 
@@ -44,12 +45,14 @@ class StubConnection extends Connection {
    *   A class to use as a statement class for deprecation testing.
    */
   public function __construct(\PDO $connection, array $connection_options, $identifier_quotes = ['', ''], $statement_class = NULL) {
-    $this->identifierQuotes = $identifier_quotes;
     if ($statement_class) {
       $this->statementClass = $statement_class;
       $this->statementWrapperClass = NULL;
     }
     parent::__construct($connection, $connection_options);
+
+    // Initialize the identifier handler.
+    $this->identifierHandler = new IdentifierHandler($connection_options['prefix'] ?? '', $identifier_quotes);
   }
 
   /**
