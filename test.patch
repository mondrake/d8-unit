diff --git a/core/lib/Drupal/Core/Database/StatementWrapper.php b/core/lib/Drupal/Core/Database/StatementWrapper.php
index 8a3bc208c5..d0cf1cd3f4 100644
--- a/core/lib/Drupal/Core/Database/StatementWrapper.php
+++ b/core/lib/Drupal/Core/Database/StatementWrapper.php
@@ -7,7 +7,7 @@
 /**
  * Implementation of StatementInterface encapsulating PDOStatement.
  */
-class StatementWrapper implements \IteratorAggregate, StatementInterface {
+class StatementWrapper implements \Iterator, StatementInterface {
 
   /**
    * The Drupal database connection object.
@@ -32,6 +32,27 @@ class StatementWrapper implements \IteratorAggregate, StatementInterface {
    */
   protected $rowCountEnabled = FALSE;
 
+  /**
+   * Traces if rows can be fetched from the resultset.
+   *
+   * @var bool
+   */
+  private $isResultsetFetchable = FALSE;
+
+  /**
+   * The current row, retrieved in the current fetch format.
+   *
+   * @var mixed
+   */
+  private $resultsetRow = NULL;
+
+  /**
+   * The key of the current row.
+   *
+   * @var int
+   */
+  private $resultsetKey = -1;
+
   /**
    * Constructs a StatementWrapper object.
    *
@@ -93,6 +114,7 @@ public function execute($args = [], $options = []) {
     }
 
     $return = $this->clientStatement->execute($args);
+    $this->markResultsetFetchable($return);
 
     if (!empty($logger)) {
       $query_end = microtime(TRUE);
@@ -131,6 +153,7 @@ public function fetchAllAssoc($key, $fetch = NULL) {
     }
 
     foreach ($this as $record) {
+global $xxx; if ($xxx) dump($record);
       $record_key = is_object($record) ? $record->$key : $record[$key];
       $return[$record_key] = $record;
     }
@@ -154,15 +177,14 @@ public function fetchAllKeyed($key_index = 0, $value_index = 1) {
    * {@inheritdoc}
    */
   public function fetchField($index = 0) {
-    // Call \PDOStatement::fetchColumn to fetch the field.
-    return $this->clientStatement->fetchColumn($index);
+    $return = $this->fetch(\PDO::FETCH_NUM);
+    return $return === FALSE ? FALSE : ($return[$index] ?? NULL);
   }
 
   /**
    * {@inheritdoc}
    */
   public function fetchAssoc() {
-    // Call \PDOStatement::fetch to fetch the row.
     return $this->fetch(\PDO::FETCH_ASSOC);
   }
 
@@ -171,9 +193,20 @@ public function fetchAssoc() {
    */
   public function fetchObject(string $class_name = NULL, array $constructor_arguments = NULL) {
     if ($class_name) {
-      return $this->clientStatement->fetchObject($class_name, $constructor_arguments);
+      $row = $this->clientStatement->fetchObject($class_name, $constructor_arguments);
+    }
+    else {
+      $row = $this->clientStatement->fetchObject();
+    }
+
+    if ($row) {
+      $this->setCurrentResultsetRow($row);
+    }
+    else {
+      $this->markResultsetFetchingComplete();
     }
-    return $this->clientStatement->fetchObject();
+
+    return $row;
   }
 
   /**
@@ -215,21 +248,34 @@ public function setFetchMode($mode, $a1 = NULL, $a2 = []) {
   public function fetch($mode = NULL, $cursor_orientation = NULL, $cursor_offset = NULL) {
     // Call \PDOStatement::fetchAll to fetch all rows.
     // \PDOStatement is picky about the number of arguments in some cases so we
-    // need to be pass the exact number of arguments we where given.
+    // need to pass the exact number of arguments we were given.
     switch (func_num_args()) {
       case 0:
-        return $this->clientStatement->fetch();
+        $row = $this->clientStatement->fetch();
+        break;
 
       case 1:
-        return $this->clientStatement->fetch($mode);
+        $row = $this->clientStatement->fetch($mode);
+        break;
 
       case 2:
-        return $this->clientStatement->fetch($mode, $cursor_orientation);
+        $row = $this->clientStatement->fetch($mode, $cursor_orientation);
+        break;
 
       case 3:
       default:
-        return $this->clientStatement->fetch($mode, $cursor_orientation, $cursor_offset);
+        $row = $this->clientStatement->fetch($mode, $cursor_orientation, $cursor_offset);
+        break;
+    }
+
+    if ($row) {
+      $this->setCurrentResultsetRow($row);
+    }
+    else {
+      $this->markResultsetFetchingComplete();
     }
+
+    return $row;
   }
 
   /**
@@ -241,26 +287,116 @@ public function fetchAll($mode = NULL, $column_index = NULL, $constructor_argume
     // need to be pass the exact number of arguments we where given.
     switch (func_num_args()) {
       case 0:
-        return $this->clientStatement->fetchAll();
+        $return = $this->clientStatement->fetchAll();
+        break;
 
       case 1:
-        return $this->clientStatement->fetchAll($mode);
+        $return = $this->clientStatement->fetchAll($mode);
+        break;
 
       case 2:
-        return $this->clientStatement->fetchAll($mode, $column_index);
+        $return = $this->clientStatement->fetchAll($mode, $column_index);
+        break;
 
       case 3:
       default:
-        return $this->clientStatement->fetchAll($mode, $column_index, $constructor_arguments);
+        $return = $this->clientStatement->fetchAll($mode, $column_index, $constructor_arguments);
     }
+
+    $this->markResultsetFetchingComplete();
+
+    return $return;
   }
 
   /**
-   * {@inheritdoc}
+   * @deprecated in drupal:9.4.0 and is removed from drupal:10.0.0. There is
+   *   no replacement.
+   *
+   * @see https://www.drupal.org/node/7654321
    */
-  #[\ReturnTypeWillChange]
   public function getIterator() {
+    @trigger_error(__METHOD__ . '() is deprecated in drupal:9.4.0 and is removed from drupal:10.0.0. There is no replacement. See https://www.drupal.org/node/7654321', E_USER_DEPRECATED);
     return new \ArrayIterator($this->fetchAll());
   }
 
+  /**
+   * Informs the iterator that whether rows can be fetched from the resultset.
+   *
+   * @var bool $valid
+   *   The result of the execution of the client statement.
+   */
+  protected function markResultsetFetchable(bool $valid): void {
+    $this->isResultsetFetchable = $valid;
+    $this->resultsetRow = NULL;
+    $this->resultsetKey = -1;
+  }
+
+  /**
+   * Sets the current resultset row for the iterator, and increments the key.
+   *
+   * @var mixed $row
+   *   The last row fetched from the client statement.
+   */
+  protected function setCurrentResultsetRow($row): void {
+    $this->resultsetRow = $row;
+    $this->resultsetKey++;
+  }
+
+  /**
+   * Informs the iterator that no more rows can be fetched from the resultset.
+   */
+  protected function markResultsetFetchingComplete(): void {
+    $this->isResultsetFetchable = FALSE;
+    $this->resultsetRow = NULL;
+    $this->resultsetKey = -1;
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function current(): mixed {
+    return $this->resultsetRow;
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function key(): mixed {
+    return $this->resultsetKey;
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function rewind(): void {
+    // Nothing to do: our DatabaseStatement can't be rewound.
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function next(): void {
+    $this->fetch();
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @internal This method should not be called directly.
+   */
+  public function valid(): bool {
+    if ($this->isResultsetFetchable && $this->resultsetKey === -1) {
+      $this->fetch();
+    }
+    return $this->isResultsetFetchable;
+  }
+
 }
diff --git a/core/modules/mysql/src/Driver/Database/mysql/Schema.php b/core/modules/mysql/src/Driver/Database/mysql/Schema.php
index 1f0e4dfe20..dcf9f3fbc1 100644
--- a/core/modules/mysql/src/Driver/Database/mysql/Schema.php
+++ b/core/modules/mysql/src/Driver/Database/mysql/Schema.php
@@ -526,7 +526,9 @@ protected function findPrimaryKeyColumns($table) {
     if (!$this->tableExists($table)) {
       return FALSE;
     }
+global $xxx;$xxx=TRUE;
     $result = $this->connection->query("SHOW KEYS FROM {" . $table . "} WHERE Key_name = 'PRIMARY'")->fetchAllAssoc('Column_name');
+$xxx=FALSE;
     return array_keys($result);
   }
 
