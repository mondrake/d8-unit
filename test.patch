diff --git a/core/lib/Drupal/Core/Cache/CacheTagsChecksumTrait.php b/core/lib/Drupal/Core/Cache/CacheTagsChecksumTrait.php
index 2a14f8a540..037a64f8dc 100644
--- a/core/lib/Drupal/Core/Cache/CacheTagsChecksumTrait.php
+++ b/core/lib/Drupal/Core/Cache/CacheTagsChecksumTrait.php
@@ -41,10 +41,12 @@ trait CacheTagsChecksumTrait {
    *   Whether or not the transaction was successful.
    */
   public function rootTransactionEndCallback($success) {
+dump([__METHOD__, 'start', 'success' => $success, $this->delayedTags]);
     if ($success) {
       $this->doInvalidateTags($this->delayedTags);
     }
     $this->delayedTags = [];
+dump([__METHOD__, 'stop']);
   }
 
   /**
diff --git a/core/lib/Drupal/Core/Database/Connection.php b/core/lib/Drupal/Core/Database/Connection.php
index 97b528c25b..1e2ae7d527 100644
--- a/core/lib/Drupal/Core/Database/Connection.php
+++ b/core/lib/Drupal/Core/Database/Connection.php
@@ -4,6 +4,8 @@
 
 use Drupal\Component\Assertion\Inspector;
 use Drupal\Core\Database\Event\DatabaseEvent;
+use Drupal\Core\Database\Event\StatementExecutionEndEvent;
+use Drupal\Core\Database\Event\StatementExecutionStartEvent;
 use Drupal\Core\Database\Exception\EventException;
 use Drupal\Core\Database\Query\Condition;
 use Drupal\Core\Database\Query\Delete;
@@ -859,6 +861,83 @@ public function query($query, array $args = [], $options = []) {
     }
   }
 
+  /**
+   * Executes a data definition language (DDL) statement.
+   *
+   * This method allows to void an active transaction when the driver does
+   * not support transactional DDL.
+   *
+   * @param string $sql
+   *   The DDL statement to execute. This is a SQL string that may contain
+   *   placeholders.
+   * @param array $arguments
+   *   (Optional) The associative array of arguments for the prepared
+   *   statement.
+   * @param array $options
+   *   (Optional) An associative array of options to control how the query is
+   *   run. The given options will be merged with self::defaultOptions().
+   */
+  public function executeDdlStatement(string $sql, array $arguments = [], array $options = []): void {
+    if (count($arguments) > 0) {
+      $this->query($sql, $arguments, $options);
+    }
+    else {
+      $this->executeSql($sql, $options);
+    }
+
+    // DDL statements when in a transaction force a commit in some databases.
+    // Void the transaction in that case.
+//    if (!$this->transactionalDDLSupport && $this->transactionManager()->inTransaction()) {
+//      $this->transactionManager()->voidClientTransaction();
+//    }
+  }
+
+  /**
+   * Executes an SQL statement, directly through the client connection.
+   *
+   * This method does not allow placeholders. It assumes the client connection
+   * is \PDO. Non-PDO based drivers need to override this method.
+   *
+   * @param string $sql
+   *   The SQL statement to execute.
+   * @param array $options
+   *   (Optional) An associative array of options. The given options will be
+   *    merged with self::defaultOptions().
+   */
+  protected function executeSql(string $sql, array $options = []): void {
+    $sql = $this->preprocessStatement($sql, $options);
+    try {
+      if ($this->isEventEnabled(StatementExecutionStartEvent::class)) {
+        $startEvent = new StatementExecutionStartEvent(
+          spl_object_id($this),
+          $this->getKey(),
+          $this->getTarget(),
+          $sql,
+          [],
+          $this->findCallerFromDebugBacktrace()
+        );
+        $this->dispatchEvent($startEvent);
+      }
+
+      $this->getClientConnection()->exec($sql);
+
+      if (isset($startEvent) && $this->isEventEnabled(StatementExecutionEndEvent::class)) {
+        $this->dispatchEvent(new StatementExecutionEndEvent(
+          $startEvent->statementObjectId,
+          $startEvent->key,
+          $startEvent->target,
+          $startEvent->queryString,
+          $startEvent->args,
+          $startEvent->caller,
+          $startEvent->time
+        ));
+      }
+    }
+    catch (\Exception $e) {
+      $this->exceptionHandler()->handleExecuteSqlException($e, $sql, $options);
+    }
+  }
+
   /**
    * Expands out shorthand placeholders.
    *
diff --git a/core/lib/Drupal/Core/Database/ExceptionHandler.php b/core/lib/Drupal/Core/Database/ExceptionHandler.php
index 5dfd41f41c..8acb2f0588 100644
--- a/core/lib/Drupal/Core/Database/ExceptionHandler.php
+++ b/core/lib/Drupal/Core/Database/ExceptionHandler.php
@@ -55,18 +55,52 @@ public function handleStatementException(\Exception $exception, string $sql, arr
    */
   public function handleExecutionException(\Exception $exception, StatementInterface $statement, array $arguments = [], array $options = []): void {
     if ($exception instanceof \PDOException) {
-      // Wrap the exception in another exception, because PHP does not allow
-      // overriding Exception::getMessage(). Its message is the extra database
-      // debug information.
-      $message = $exception->getMessage() . ": " . $statement->getQueryString() . "; " . print_r($arguments, TRUE);
-      // Match all SQLSTATE 23xxx errors.
-      if (substr($exception->getCode(), -6, -3) == '23') {
-        throw new IntegrityConstraintViolationException($message, $exception->getCode(), $exception);
-      }
-      throw new DatabaseExceptionWrapper($message, 0, $exception);
+      $this->throwExecutionException($exception, $exception->getMessage() . ": " . $statement->getQueryString() . "; " . print_r($arguments, TRUE));
     }
+    throw $exception;
+  }
 
+  /**
+   * Handles exceptions thrown during direct execution of an SQL statement.
+   *
+   * @param \Exception $exception
+   *   The exception to be handled.
+   * @param string $sql
+   *   The SQL statement executed.
+   * @param array $options
+   *   An associative array of options to control how the database operation is
+   *   run.
+   *
+   * @throws \Drupal\Core\Database\DatabaseExceptionWrapper
+   * @throws \Drupal\Core\Database\IntegrityConstraintViolationException
+   */
+  public function handleExecuteSqlException(\Exception $exception, string $sql, array $options = []): void {
+    if ($exception instanceof \PDOException) {
+      $this->throwExecutionException($exception, $exception->getMessage() . ": " . $sql);
+    }
     throw $exception;
   }
 
+  /**
+   * Re-throws the appropriate exception.
+   *
+   * @param \Exception $exception
+   *   The exception to be handled.
+   * @param string $message
+   *   The message to be included in the exception.
+   *
+   * @throws \Drupal\Core\Database\DatabaseExceptionWrapper
+   * @throws \Drupal\Core\Database\IntegrityConstraintViolationException
+   */
+  protected function throwExecutionException(\Exception $exception, string $message): void {
+    // Wrap the exception in another exception, because PHP does not allow
+    // overriding Exception::getMessage(). Its message is the extra database
+    // debug information.
+    // Match all SQLSTATE 23xxx errors.
+    if (substr($exception->getCode(), -6, -3) == '23') {
+      throw new IntegrityConstraintViolationException($message, $exception->getCode(), $exception);
+    }
+    throw new DatabaseExceptionWrapper($message, 0, $exception);
+  }
+
 }
diff --git a/core/lib/Drupal/Core/Database/Query/Truncate.php b/core/lib/Drupal/Core/Database/Query/Truncate.php
index 01f0c9d47d..359769830f 100644
--- a/core/lib/Drupal/Core/Database/Query/Truncate.php
+++ b/core/lib/Drupal/Core/Database/Query/Truncate.php
@@ -48,13 +48,23 @@ public function __construct(Connection $connection, $table, array $options = [])
    * @see https://learnsql.com/blog/difference-between-truncate-delete-and-drop-table-in-sql
    */
   public function execute() {
-    $stmt = $this->connection->prepareStatement((string) $this, $this->queryOptions, TRUE);
-    try {
-      $stmt->execute([], $this->queryOptions);
-      return $stmt->rowCount();
+    // In most cases, TRUNCATE is not a transaction safe statement as it is a
+    // DDL statement which results in an implicit COMMIT. When we are in a
+    // transaction, fallback to the slower, but transactional, DELETE.
+    // PostgreSQL also locks the entire table for a TRUNCATE strongly reducing
+    // the concurrency with other transactions.
+    if ($this->connection->inTransaction()) {
+      $stmt = $this->connection->prepareStatement((string) $this, $this->queryOptions, TRUE);
+      try {
+        $stmt->execute([], $this->queryOptions);
+        return $stmt->rowCount();
+      }
+      catch (\Exception $e) {
+        $this->connection->exceptionHandler()->handleExecutionException($e, $stmt, [], $this->queryOptions);
+      }
     }
-    catch (\Exception $e) {
-      $this->connection->exceptionHandler()->handleExecutionException($e, $stmt, [], $this->queryOptions);
+    else {
+      $this->connection->executeDdlStatement((string) $this, [], $this->queryOptions);
     }
 
     return NULL;
@@ -70,11 +80,6 @@ public function __toString() {
     // Create a sanitized comment string to prepend to the query.
     $comments = $this->connection->makeComment($this->comments);
 
-    // In most cases, TRUNCATE is not a transaction safe statement as it is a
-    // DDL statement which results in an implicit COMMIT. When we are in a
-    // transaction, fallback to the slower, but transactional, DELETE.
-    // PostgreSQL also locks the entire table for a TRUNCATE strongly reducing
-    // the concurrency with other transactions.
     if ($this->connection->inTransaction()) {
       return $comments . 'DELETE FROM {' . $this->connection->escapeTable($this->table) . '}';
     }
diff --git a/core/lib/Drupal/Core/Database/Schema.php b/core/lib/Drupal/Core/Database/Schema.php
index 9153cd9ef8..ac2cb24618 100644
--- a/core/lib/Drupal/Core/Database/Schema.php
+++ b/core/lib/Drupal/Core/Database/Schema.php
@@ -614,7 +614,7 @@ public function createTable($name, $table) {
     }
     $statements = $this->createTableSql($name, $table);
     foreach ($statements as $statement) {
-      $this->connection->query($statement);
+      $this->connection->executeDdlStatement($statement);
     }
   }
 
diff --git a/core/lib/Drupal/Core/Database/StatementWrapperIterator.php b/core/lib/Drupal/Core/Database/StatementWrapperIterator.php
index b0474045a3..a836fd140e 100644
--- a/core/lib/Drupal/Core/Database/StatementWrapperIterator.php
+++ b/core/lib/Drupal/Core/Database/StatementWrapperIterator.php
@@ -95,7 +95,9 @@ public function execute($args = [], $options = []) {
         $this->setFetchMode($options['fetch']);
       }
     }
-
+if (preg_match("/SELECT .* FROM .*cache_default/", $this->getQueryString()) === 1) {
+//  dump([$this->getQueryString(), \Drupal\Core\Utility\Error::formatBacktrace(debug_backtrace())]);
+}
     if ($this->connection->isEventEnabled(StatementExecutionStartEvent::class)) {
       $startEvent = new StatementExecutionStartEvent(
         spl_object_id($this),
diff --git a/core/lib/Drupal/Core/Entity/Sql/SqlContentEntityStorage.php b/core/lib/Drupal/Core/Entity/Sql/SqlContentEntityStorage.php
index c65c623fef..129277b63f 100644
--- a/core/lib/Drupal/Core/Entity/Sql/SqlContentEntityStorage.php
+++ b/core/lib/Drupal/Core/Entity/Sql/SqlContentEntityStorage.php
@@ -803,6 +803,7 @@ protected function doDeleteFieldItems($entities) {
   public function save(EntityInterface $entity) {
     try {
       $transaction = $this->database->startTransaction();
+dump([__METHOD__, $this->entityTypeId, $transaction->getName()]);
       $return = parent::save($entity);
 
       // Ignore replica server temporarily.
@@ -810,6 +811,7 @@ public function save(EntityInterface $entity) {
       return $return;
     }
     catch (\Exception $e) {
+dump([__METHOD__, $e, isset($transaction)]);
       if (isset($transaction)) {
         $transaction->rollBack();
       }
diff --git a/core/modules/mysql/src/Driver/Database/mysql/ExceptionHandler.php b/core/modules/mysql/src/Driver/Database/mysql/ExceptionHandler.php
index 7926175e0d..d06a35ce16 100644
--- a/core/modules/mysql/src/Driver/Database/mysql/ExceptionHandler.php
+++ b/core/modules/mysql/src/Driver/Database/mysql/ExceptionHandler.php
@@ -8,7 +8,6 @@
 use Drupal\Core\Database\Exception\SchemaTableColumnSizeTooLargeException;
 use Drupal\Core\Database\Exception\SchemaTableKeyTooLargeException;
 use Drupal\Core\Database\IntegrityConstraintViolationException;
-use Drupal\Core\Database\StatementInterface;
 
 /**
  * MySql database exception handler class.
@@ -18,45 +17,39 @@ class ExceptionHandler extends BaseExceptionHandler {
   /**
    * {@inheritdoc}
    */
-  public function handleExecutionException(\Exception $exception, StatementInterface $statement, array $arguments = [], array $options = []): void {
-    if ($exception instanceof \PDOException) {
-      // Wrap the exception in another exception, because PHP does not allow
-      // overriding Exception::getMessage(). Its message is the extra database
-      // debug information.
-      $code = is_int($exception->getCode()) ? $exception->getCode() : 0;
-
-      // If a max_allowed_packet error occurs the message length is truncated.
-      // This should prevent the error from recurring if the exception is logged
-      // to the database using dblog or the like.
-      if (($exception->errorInfo[1] ?? NULL) === 1153) {
-        $message = Unicode::truncateBytes($exception->getMessage(), Connection::MIN_MAX_ALLOWED_PACKET);
-        throw new DatabaseExceptionWrapper($message, $code, $exception);
-      }
-
-      $message = $exception->getMessage() . ": " . $statement->getQueryString() . "; " . print_r($arguments, TRUE);
-
-      // SQLSTATE 23xxx errors indicate an integrity constraint violation. Also,
-      // in case of attempted INSERT of a record with an undefined column and no
-      // default value indicated in schema, MySql returns a 1364 error code.
-      if (
-        substr($exception->getCode(), -6, -3) == '23' ||
-        ($exception->errorInfo[1] ?? NULL) === 1364
-      ) {
-        throw new IntegrityConstraintViolationException($message, $code, $exception);
-      }
-
-      if ($exception->getCode() === '42000') {
-        match ($exception->errorInfo[1]) {
-          1071 => throw new SchemaTableKeyTooLargeException($message, $code, $exception),
-          1074 => throw new SchemaTableColumnSizeTooLargeException($message, $code, $exception),
-          default => throw new DatabaseExceptionWrapper($message, 0, $exception),
-        };
-      }
-
-      throw new DatabaseExceptionWrapper($message, 0, $exception);
+  protected function throwExecutionException(\Exception $exception, string $message): void {
+    // Wrap the exception in another exception, because PHP does not allow
+    // overriding Exception::getMessage(). Its message is the extra database
+    // debug information.
+    $code = is_int($exception->getCode()) ? $exception->getCode() : 0;
+
+    // If a max_allowed_packet error occurs the message length is truncated.
+    // This should prevent the error from recurring if the exception is logged
+    // to the database using dblog or the like.
+    if (($exception->errorInfo[1] ?? NULL) === 1153) {
+      $message = Unicode::truncateBytes($exception->getMessage(), Connection::MIN_MAX_ALLOWED_PACKET);
+      throw new DatabaseExceptionWrapper($message, $code, $exception);
     }
 
-    throw $exception;
+    // SQLSTATE 23xxx errors indicate an integrity constraint violation. Also,
+    // in case of attempted INSERT of a record with an undefined column and no
+    // default value indicated in schema, MySql returns a 1364 error code.
+    if (
+      substr($exception->getCode(), -6, -3) == '23' ||
+      ($exception->errorInfo[1] ?? NULL) === 1364
+    ) {
+      throw new IntegrityConstraintViolationException($message, $code, $exception);
+    }
+
+    if ($exception->getCode() === '42000') {
+      match ($exception->errorInfo[1]) {
+        1071 => throw new SchemaTableKeyTooLargeException($message, $code, $exception),
+        1074 => throw new SchemaTableColumnSizeTooLargeException($message, $code, $exception),
+        default => throw new DatabaseExceptionWrapper($message, 0, $exception),
+      };
+    }
+
+    throw new DatabaseExceptionWrapper($message, 0, $exception);
   }
 
 }
diff --git a/core/modules/mysql/src/Driver/Database/mysql/Schema.php b/core/modules/mysql/src/Driver/Database/mysql/Schema.php
index d0076f3481..24c2f29f65 100644
--- a/core/modules/mysql/src/Driver/Database/mysql/Schema.php
+++ b/core/modules/mysql/src/Driver/Database/mysql/Schema.php
@@ -377,7 +377,7 @@ public function renameTable($table, $new_name) {
     }
 
     $info = $this->getPrefixInfo($new_name);
-    $this->connection->query('ALTER TABLE {' . $table . '} RENAME TO [' . $info['table'] . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} RENAME TO [' . $info['table'] . ']');
   }
 
   /**
@@ -388,7 +388,7 @@ public function dropTable($table) {
       return FALSE;
     }
 
-    $this->connection->query('DROP TABLE {' . $table . '}');
+    $this->connection->executeDdlStatement('DROP TABLE {' . $table . '}');
     return TRUE;
   }
 
@@ -426,7 +426,7 @@ public function addField($table, $field, $spec, $keys_new = []) {
 
       $query .= ', ADD ' . implode(', ADD ', $keys_sql);
     }
-    $this->connection->query($query);
+    $this->connection->executeDdlStatement($query);
     if (isset($spec['initial_from_field'])) {
       if (isset($spec['initial'])) {
         $expression = 'COALESCE(' . $spec['initial_from_field'] . ', :default_initial_value)';
@@ -471,7 +471,7 @@ public function dropField($table, $field) {
       $this->dropPrimaryKey($table);
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP [' . $field . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP [' . $field . ']');
     return TRUE;
   }
 
@@ -496,7 +496,7 @@ public function addPrimaryKey($table, $fields) {
       throw new SchemaObjectExistsException("Cannot add primary key to table '$table': primary key already exists.");
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD PRIMARY KEY (' . $this->createKeySql($fields) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD PRIMARY KEY (' . $this->createKeySql($fields) . ')');
   }
 
   /**
@@ -507,7 +507,7 @@ public function dropPrimaryKey($table) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP PRIMARY KEY');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP PRIMARY KEY');
     return TRUE;
   }
 
@@ -533,7 +533,7 @@ public function addUniqueKey($table, $name, $fields) {
       throw new SchemaObjectExistsException("Cannot add unique key '$name' to table '$table': unique key already exists.");
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD UNIQUE KEY [' . $name . '] (' . $this->createKeySql($fields) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD UNIQUE KEY [' . $name . '] (' . $this->createKeySql($fields) . ')');
   }
 
   /**
@@ -544,7 +544,7 @@ public function dropUniqueKey($table, $name) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP KEY [' . $name . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP KEY [' . $name . ']');
     return TRUE;
   }
 
@@ -562,7 +562,7 @@ public function addIndex($table, $name, $fields, array $spec) {
     $spec['indexes'][$name] = $fields;
     $indexes = $this->getNormalizedIndexes($spec);
 
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD INDEX [' . $name . '] (' . $this->createKeySql($indexes[$name]) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD INDEX [' . $name . '] (' . $this->createKeySql($indexes[$name]) . ')');
   }
 
   /**
@@ -573,7 +573,7 @@ public function dropIndex($table, $name) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP INDEX [' . $name . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP INDEX [' . $name . ']');
     return TRUE;
   }
 
@@ -625,11 +625,11 @@ public function changeField($table, $field, $field_new, $spec, $keys_new = []) {
     if ($keys_sql = $this->createKeysSql($keys_new)) {
       $sql .= ', ADD ' . implode(', ADD ', $keys_sql);
     }
-    $this->connection->query($sql);
+    $this->connection->executeDdlStatement($sql);
 
     if ($spec['type'] === 'serial') {
       $max = $this->connection->query('SELECT MAX(`' . $field_new . '`) FROM {' . $table . '}')->fetchField();
-      $this->connection->query("ALTER TABLE {" . $table . "} AUTO_INCREMENT = " . ($max + 1));
+      $this->connection->executeDdlStatement("ALTER TABLE {" . $table . "} AUTO_INCREMENT = " . ($max + 1));
     }
   }
 
diff --git a/core/modules/pgsql/src/Driver/Database/pgsql/Schema.php b/core/modules/pgsql/src/Driver/Database/pgsql/Schema.php
index a7a389a67f..5c872827d8 100644
--- a/core/modules/pgsql/src/Driver/Database/pgsql/Schema.php
+++ b/core/modules/pgsql/src/Driver/Database/pgsql/Schema.php
@@ -586,7 +586,7 @@ public function renameTable($table, $new_name) {
         preg_match('/^' . preg_quote($table_name) . '__(.*)__' . preg_quote($index_type) . '/', $index->indexname, $matches);
         $index_name = $matches[1];
       }
-      $this->connection->query('ALTER INDEX "' . $this->defaultSchema . '"."' . $index->indexname . '" RENAME TO ' . $this->ensureIdentifiersLength($new_name, $index_name, $index_type));
+      $this->connection->executeDdlStatement('ALTER INDEX "' . $this->defaultSchema . '"."' . $index->indexname . '" RENAME TO ' . $this->ensureIdentifiersLength($new_name, $index_name, $index_type));
     }
 
     // Ensure the new table name does not include schema syntax.
@@ -608,11 +608,11 @@ public function renameTable($table, $new_name) {
         // subsequent table renames.
         $new_sequence = $this->ensureIdentifiersLength($new_name, $field, 'seq', '_');
 
-        $this->connection->query('ALTER SEQUENCE ' . $old_sequence . ' RENAME TO ' . $new_sequence);
+        $this->connection->executeDdlStatement('ALTER SEQUENCE ' . $old_sequence . ' RENAME TO ' . $new_sequence);
       }
     }
     // Now rename the table.
-    $this->connection->query('ALTER TABLE {' . $table . '} RENAME TO ' . $prefixInfo['table']);
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} RENAME TO ' . $prefixInfo['table']);
     $this->resetTableInformation($table);
   }
 
@@ -624,7 +624,7 @@ public function dropTable($table) {
       return FALSE;
     }
 
-    $this->connection->query('DROP TABLE {' . $table . '}');
+    $this->connection->executeDdlStatement('DROP TABLE {' . $table . '}');
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -653,7 +653,7 @@ public function addField($table, $field, $spec, $new_keys = []) {
     }
     $query = 'ALTER TABLE {' . $table . '} ADD COLUMN ';
     $query .= $this->createFieldSql($field, $this->processField($spec));
-    $this->connection->query($query);
+    $this->connection->executeDdlStatement($query);
     if (isset($spec['initial_from_field'])) {
       if (isset($spec['initial'])) {
         $expression = 'COALESCE(' . $spec['initial_from_field'] . ', :default_initial_value)';
@@ -673,7 +673,7 @@ public function addField($table, $field, $spec, $new_keys = []) {
         ->execute();
     }
     if ($fixnull) {
-      $this->connection->query("ALTER TABLE {" . $table . "} ALTER $field SET NOT NULL");
+      $this->connection->executeDdlStatement("ALTER TABLE {" . $table . "} ALTER $field SET NOT NULL");
     }
     if (isset($new_keys)) {
       // Make sure to drop the existing primary key before adding a new one.
@@ -686,7 +686,7 @@ public function addField($table, $field, $spec, $new_keys = []) {
     }
     // Add column comment.
     if (!empty($spec['description'])) {
-      $this->connection->query('COMMENT ON COLUMN {' . $table . '}.' . $field . ' IS ' . $this->prepareComment($spec['description']));
+      $this->connection->executeDdlStatement('COMMENT ON COLUMN {' . $table . '}.' . $field . ' IS ' . $this->prepareComment($spec['description']));
     }
     $this->resetTableInformation($table);
   }
@@ -699,7 +699,7 @@ public function dropField($table, $field) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP COLUMN "' . $field . '"');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP COLUMN "' . $field . '"');
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -773,7 +773,7 @@ public function addPrimaryKey($table, $fields) {
       throw new SchemaObjectExistsException("Cannot add primary key to table '$table': primary key already exists.");
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD CONSTRAINT ' . $this->ensureIdentifiersLength($table, '', 'pkey') . ' PRIMARY KEY (' . $this->createPrimaryKeySql($fields) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD CONSTRAINT ' . $this->ensureIdentifiersLength($table, '', 'pkey') . ' PRIMARY KEY (' . $this->createPrimaryKeySql($fields) . ')');
     $this->resetTableInformation($table);
   }
 
@@ -785,7 +785,7 @@ public function dropPrimaryKey($table) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP CONSTRAINT ' . $this->ensureIdentifiersLength($table, '', 'pkey'));
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP CONSTRAINT ' . $this->ensureIdentifiersLength($table, '', 'pkey'));
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -814,7 +814,7 @@ public function addUniqueKey($table, $name, $fields) {
     // Use the createPrimaryKeySql(), which already discards any prefix lengths
     // passed as part of the key column specifiers. (Postgres doesn't support
     // setting a prefix length for PRIMARY or UNIQUE indices.)
-    $this->connection->query('ALTER TABLE {' . $table . '} ADD CONSTRAINT ' . $this->ensureIdentifiersLength($table, $name, 'key') . ' UNIQUE (' . $this->createPrimaryKeySql($fields) . ')');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD CONSTRAINT ' . $this->ensureIdentifiersLength($table, $name, 'key') . ' UNIQUE (' . $this->createPrimaryKeySql($fields) . ')');
     $this->resetTableInformation($table);
   }
 
@@ -826,7 +826,7 @@ public function dropUniqueKey($table, $name) {
       return FALSE;
     }
 
-    $this->connection->query('ALTER TABLE {' . $table . '} DROP CONSTRAINT ' . $this->ensureIdentifiersLength($table, $name, 'key'));
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP CONSTRAINT ' . $this->ensureIdentifiersLength($table, $name, 'key'));
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -842,7 +842,7 @@ public function addIndex($table, $name, $fields, array $spec) {
       throw new SchemaObjectExistsException("Cannot add index '$name' to table '$table': index already exists.");
     }
 
-    $this->connection->query($this->_createIndexSql($table, $name, $fields));
+    $this->connection->executeDdlStatement($this->_createIndexSql($table, $name, $fields));
     $this->resetTableInformation($table);
   }
 
@@ -854,7 +854,7 @@ public function dropIndex($table, $name) {
       return FALSE;
     }
 
-    $this->connection->query('DROP INDEX ' . $this->defaultSchema . '.' . $this->ensureIdentifiersLength($table, $name, 'idx'));
+    $this->connection->executeDdlStatement('DROP INDEX ' . $this->defaultSchema . '.' . $this->ensureIdentifiersLength($table, $name, 'idx'));
     $this->resetTableInformation($table);
     return TRUE;
   }
@@ -933,15 +933,15 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
     if (!empty($seq_name)) {
       // We need to add CASCADE otherwise we cannot alter the sequence because
       // the table depends on it.
-      $this->connection->query('DROP SEQUENCE IF EXISTS ' . $seq_name . ' CASCADE');
+      $this->connection->executeDdlStatement('DROP SEQUENCE IF EXISTS ' . $seq_name . ' CASCADE');
     }
 
     foreach ($field_info as $check) {
-      $this->connection->query('ALTER TABLE {' . $table . '} DROP CONSTRAINT [' . $check . ']');
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} DROP CONSTRAINT [' . $check . ']');
     }
 
     // Remove old default.
-    $this->connection->query('ALTER TABLE {' . $table . '} ALTER COLUMN [' . $field . '] DROP DEFAULT');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER COLUMN [' . $field . '] DROP DEFAULT');
 
     // Convert field type.
     // Usually, we do this via a simple typecast 'USING fieldname::type'. But
@@ -951,10 +951,10 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
     $is_bytea = !empty($table_information->blob_fields[$field]);
     if ($spec['pgsql_type'] != 'bytea') {
       if ($is_bytea) {
-        $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING convert_from([' . $field . ']' . ", 'UTF8')");
+        $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING convert_from([' . $field . ']' . ", 'UTF8')");
       }
       else {
-        $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING [' . $field . ']::' . $field_def);
+        $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING [' . $field . ']::' . $field_def);
       }
     }
     else {
@@ -963,7 +963,7 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
         // Convert to a bytea type by using the SQL replace() function to
         // convert any single backslashes in the field content to double
         // backslashes ('\' to '\\').
-        $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING decode(replace("' . $field . '"' . ", E'\\\\', E'\\\\\\\\'), 'escape');");
+        $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] TYPE ' . $field_def . ' USING decode(replace("' . $field . '"' . ", E'\\\\', E'\\\\\\\\'), 'escape');");
       }
     }
 
@@ -974,7 +974,7 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
       else {
         $null_action = 'DROP NOT NULL';
       }
-      $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] ' . $null_action);
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] ' . $null_action);
     }
 
     if (in_array($spec['pgsql_type'], ['serial', 'bigserial'])) {
@@ -982,31 +982,31 @@ public function changeField($table, $field, $field_new, $spec, $new_keys = []) {
       // not when altering. Because of that, the sequence needs to be created
       // and initialized by hand.
       $seq = $this->connection->makeSequenceName($table, $field_new);
-      $this->connection->query("CREATE SEQUENCE " . $seq . " OWNED BY {" . $table . "}.[" . $field_new . ']');
+      $this->connection->executeDdlStatement("CREATE SEQUENCE " . $seq . " OWNED BY {" . $table . "}.[" . $field_new . ']');
       // Set sequence to maximal field value to not conflict with existing
       // entries.
       $this->connection->query("SELECT setval('" . $seq . "', MAX([" . $field . "])) FROM {" . $table . "}");
-      $this->connection->query('ALTER TABLE {' . $table . '} ALTER [' . $field . '] SET DEFAULT nextval(' . $this->connection->quote($seq) . ')');
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER [' . $field . '] SET DEFAULT nextval(' . $this->connection->quote($seq) . ')');
     }
 
     // Rename the column if necessary.
     if ($field != $field_new) {
-      $this->connection->query('ALTER TABLE {' . $table . '} RENAME [' . $field . '] TO [' . $field_new . ']');
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} RENAME [' . $field . '] TO [' . $field_new . ']');
     }
 
     // Add unsigned check if necessary.
     if (!empty($spec['unsigned'])) {
-      $this->connection->query('ALTER TABLE {' . $table . '} ADD CHECK ([' . $field_new . '] >= 0)');
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ADD CHECK ([' . $field_new . '] >= 0)');
     }
 
     // Add default if necessary.
     if (isset($spec['default'])) {
-      $this->connection->query('ALTER TABLE {' . $table . '} ALTER COLUMN [' . $field_new . '] SET DEFAULT ' . $this->escapeDefaultValue($spec['default']));
+      $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} ALTER COLUMN [' . $field_new . '] SET DEFAULT ' . $this->escapeDefaultValue($spec['default']));
     }
 
     // Change description if necessary.
     if (!empty($spec['description'])) {
-      $this->connection->query('COMMENT ON COLUMN {' . $table . '}.[' . $field_new . '] IS ' . $this->prepareComment($spec['description']));
+      $this->connection->executeDdlStatement('COMMENT ON COLUMN {' . $table . '}.[' . $field_new . '] IS ' . $this->prepareComment($spec['description']));
     }
 
     if (isset($new_keys)) {
diff --git a/core/modules/sqlite/src/Driver/Database/sqlite/Schema.php b/core/modules/sqlite/src/Driver/Database/sqlite/Schema.php
index eb836eb453..e4b75f73e1 100644
--- a/core/modules/sqlite/src/Driver/Database/sqlite/Schema.php
+++ b/core/modules/sqlite/src/Driver/Database/sqlite/Schema.php
@@ -272,7 +272,7 @@ public function renameTable($table, $new_name) {
     // the table with curly braces in case the db_prefix contains a reference
     // to a database outside of our existing database.
     $info = $this->getPrefixInfo($new_name);
-    $this->connection->query('ALTER TABLE {' . $table . '} RENAME TO [' . $info['table'] . ']');
+    $this->connection->executeDdlStatement('ALTER TABLE {' . $table . '} RENAME TO [' . $info['table'] . ']');
 
     // Drop the indexes, there is no RENAME INDEX command in SQLite.
     if (!empty($schema['unique keys'])) {
@@ -289,7 +289,7 @@ public function renameTable($table, $new_name) {
     // Recreate the indexes.
     $statements = $this->createIndexSql($new_name, $schema);
     foreach ($statements as $statement) {
-      $this->connection->query($statement);
+      $this->connection->executeDdlStatement($statement);
     }
   }
 
@@ -301,7 +301,7 @@ public function dropTable($table) {
       return FALSE;
     }
     $this->connection->tableDropped = TRUE;
-    $this->connection->query('DROP TABLE {' . $table . '}');
+    $this->connection->executeDdlStatement('DROP TABLE {' . $table . '}');
     return TRUE;
   }
 
@@ -326,7 +326,7 @@ public function addField($table, $field, $specification, $keys_new = []) {
       // When we don't have to create new keys and we are not creating a
       // NOT NULL column without a default value, we can use the quicker version.
       $query = 'ALTER TABLE {' . $table . '} ADD ' . $this->createFieldSql($field, $this->processField($specification));
-      $this->connection->query($query);
+      $this->connection->executeDdlStatement($query);
 
       // Apply the initial value if set.
       if (isset($specification['initial_from_field'])) {
@@ -683,7 +683,7 @@ public function addIndex($table, $name, $fields, array $spec) {
     $schema['indexes'][$name] = $fields;
     $statements = $this->createIndexSql($table, $schema);
     foreach ($statements as $statement) {
-      $this->connection->query($statement);
+      $this->connection->executeDdlStatement($statement);
     }
   }
 
@@ -706,7 +706,7 @@ public function dropIndex($table, $name) {
 
     $info = $this->getPrefixInfo($table);
 
-    $this->connection->query('DROP INDEX [' . $info['schema'] . '].[' . $info['table'] . '_' . $name . ']');
+    $this->connection->executeDdlStatement('DROP INDEX [' . $info['schema'] . '].[' . $info['table'] . '_' . $name . ']');
     return TRUE;
   }
 
@@ -724,7 +724,7 @@ public function addUniqueKey($table, $name, $fields) {
     $schema['unique keys'][$name] = $fields;
     $statements = $this->createIndexSql($table, $schema);
     foreach ($statements as $statement) {
-      $this->connection->query($statement);
+      $this->connection->executeDdlStatement($statement);
     }
   }
 
@@ -738,7 +738,7 @@ public function dropUniqueKey($table, $name) {
 
     $info = $this->getPrefixInfo($table);
 
-    $this->connection->query('DROP INDEX [' . $info['schema'] . '].[' . $info['table'] . '_' . $name . ']');
+    $this->connection->executeDdlStatement('DROP INDEX [' . $info['schema'] . '].[' . $info['table'] . '_' . $name . ']');
     return TRUE;
   }
 
diff --git a/core/tests/Drupal/KernelTests/Core/Cache/EndOfTransactionQueriesTest.php b/core/tests/Drupal/KernelTests/Core/Cache/EndOfTransactionQueriesTest.php
index 83ea69e10f..2685e054f6 100644
--- a/core/tests/Drupal/KernelTests/Core/Cache/EndOfTransactionQueriesTest.php
+++ b/core/tests/Drupal/KernelTests/Core/Cache/EndOfTransactionQueriesTest.php
@@ -79,7 +79,9 @@ public function testEntitySave(): void {
       $executed_statements[] = $log['query'];
     }
     $last_statement_index = max(array_keys($executed_statements));
+    dump(['$executed_statements', $executed_statements, $last_statement_index]);
     $cachetag_statements = array_keys($this->getStatementsForTable($executed_statements, 'cachetags'));
+    dump(['$cachetag_statements', $cachetag_statements, $last_statement_index - count($cachetag_statements) + 1]);
     $this->assertSame($last_statement_index - count($cachetag_statements) + 1, min($cachetag_statements), 'All of the last queries in the transaction are for the "cachetags" table.');
 
     // Verify that a nested entity save occurred.
diff --git a/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php b/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
index 3d053be1d0..030ffd6380 100644
--- a/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
+++ b/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
@@ -3,12 +3,12 @@
 namespace Drupal\KernelTests\Core\Database;
 
 use Drupal\Core\Database\Database;
+use Drupal\Core\Database\Transaction\ClientConnectionTransactionState;
 use Drupal\Core\Database\Transaction\StackItem;
 use Drupal\Core\Database\Transaction\StackItemType;
 use Drupal\Core\Database\TransactionExplicitCommitNotAllowedException;
 use Drupal\Core\Database\TransactionNameNonUniqueException;
 use Drupal\Core\Database\TransactionOutOfOrderException;
-use PHPUnit\Framework\Error\Warning;
 
 /**
  * Tests the transaction abstraction system.
@@ -269,18 +269,19 @@ public function testTransactionWithDdlStatement() {
       // the DDL statement should commit the transaction stack.
       $this->cleanUp();
       $transaction = $this->connection->startTransaction();
+      $reflectionMethod = new \ReflectionMethod(get_class($this->connection->transactionManager()), 'getConnectionTransactionState');
+      $this->assertSame(1, $this->connection->transactionManager()->stackDepth());
+      $this->assertEquals(ClientConnectionTransactionState::Active, $reflectionMethod->invoke($this->connection->transactionManager()));
       $this->insertRow('row');
+
       $this->executeDDLStatement();
+      $this->assertSame(0, $this->connection->transactionManager()->stackDepth());
+      $this->assertEquals(ClientConnectionTransactionState::Voided, $reflectionMethod->invoke($this->connection->transactionManager()));
+      $this->assertRowPresent('row');
 
-      try {
-        // Rollback the outer transaction.
-        $transaction->rollBack();
-        // @see \Drupal\mysql\Driver\Database\mysql\TransactionManager::rollbackClientTransaction()
-        $this->fail('Rolling back a transaction containing DDL should produce a warning.');
-      }
-      catch (Warning $warning) {
-        $this->assertSame('Rollback attempted when there is no active transaction. This can cause data integrity issues.', $warning->getMessage());
-      }
+      // Rollback the outer transaction. Nothing happens as the transaction was
+      // voided.
+      $transaction->rollBack();
       unset($transaction);
       $this->assertRowPresent('row');
     }
