diff --git a/core/lib/Drupal/Core/Database/Connection.php b/core/lib/Drupal/Core/Database/Connection.php
index f38ac642cd..654d00c875 100644
--- a/core/lib/Drupal/Core/Database/Connection.php
+++ b/core/lib/Drupal/Core/Database/Connection.php
@@ -13,6 +13,7 @@
 use Drupal\Core\Database\Query\Truncate;
 use Drupal\Core\Database\Query\Update;
 use Drupal\Core\Database\Query\Upsert;
+use Drupal\Core\Database\Transaction\TransactionManagerInterface;
 use Drupal\Core\Pager\PagerManagerInterface;
 
 /**
@@ -62,6 +63,11 @@ abstract class Connection {
    * transaction.
    *
    * @var array
+   *
+   * @deprecated in drupal:10.0.2 and is removed from drupal:11.0.0. The
+   *   transaction stack is now managed by TransactionManager.
+   *
+   * @see https://www.drupal.org/node/5555555
    */
   protected $transactionLayers = [];
 
@@ -204,6 +210,11 @@ abstract class Connection {
    * Post-root (non-nested) transaction commit callbacks.
    *
    * @var callable[]
+   *
+   * @deprecated in drupal:10.0.2 and is removed from drupal:11.0.0. The
+   *   transaction end callbacks are now managed by TransactionManager.
+   *
+   * @see https://www.drupal.org/node/5555555
    */
   protected $rootTransactionEndCallbacks = [];
 
@@ -226,6 +237,11 @@ abstract class Connection {
    */
   private array $enabledEvents = [];
 
+  /**
+   * The transaction manager.
+   */
+  protected TransactionManagerInterface|FALSE $transactionManager;
+
   /**
    * Constructs a Connection object.
    *
@@ -276,6 +292,20 @@ public function __destruct() {
     $this->connection = NULL;
   }
 
+  /**
+   * Returns the client-level database connection object.
+   *
+   * This method should normally be used only within database driver code. Not
+   * doing so constitutes a risk of introducing code that is not database
+   * independent.
+   *
+   * @return object
+   *   The client-level database connection, for example \PDO.
+   */
+  public function getClientConnection(): object {
+    return $this->connection;
+  }
+
   /**
    * Returns the default query options for any given query.
    *
@@ -1294,6 +1324,41 @@ public function escapeLike($string) {
     return addcslashes($string, '\%_');
   }
 
+  /**
+   * Returns the transaction manager.
+   *
+   * @return \Drupal\Core\Database\Transaction\TransactionManagerInterface|false
+   *   The transaction manager, or FALSE if not available.
+   */
+  public function transactionManager(): TransactionManagerInterface|FALSE {
+    if (!isset($this->transactionManager)) {
+      try {
+        $this->transactionManager = $this->driverTransactionManager();
+      }
+      catch (\LogicException $e) {
+        $this->transactionManager = FALSE;
+      }
+    }
+    return $this->transactionManager;
+  }
+
+  /**
+   * Returns a new instance of the driver's transaction manager.
+   *
+   * Database drivers must implement their own class extending from
+   * \Drupal\Core\Database\Transaction\TransactionManagerBase, and instantiate
+   * it here.
+   *
+   * @return \Drupal\Core\Database\Transaction\TransactionManagerInterface
+   *   The transaction manager.
+   *
+   * @throws \LogicException
+   *   If the transaction manager is undefined or unavailable.
+   */
+  protected function driverTransactionManager(): TransactionManagerInterface {
+    throw new \LogicException('The database driver has no TransactionManager implementation');
+  }
+
   /**
    * Determines if there is an active transaction open.
    *
@@ -1301,6 +1366,9 @@ public function escapeLike($string) {
    *   TRUE if we're currently in a transaction, FALSE otherwise.
    */
   public function inTransaction() {
+    if ($this->transactionManager()) {
+      return $this->transactionManager()->inTransaction();
+    }
     return ($this->transactionDepth() > 0);
   }
 
@@ -1311,6 +1379,9 @@ public function inTransaction() {
    *   The current transaction depth.
    */
   public function transactionDepth() {
+    if ($this->transactionManager()) {
+      return $this->transactionManager()->stackDepth();
+    }
     return count($this->transactionLayers);
   }
 
@@ -1326,6 +1397,9 @@ public function transactionDepth() {
    * @see \Drupal\Core\Database\Transaction
    */
   public function startTransaction($name = '') {
+    if ($this->transactionManager()) {
+      return $this->transactionManager()->push($name);
+    }
     $class = $this->getDriverClass('Transaction');
     return new $class($this, $name);
   }
@@ -1345,6 +1419,10 @@ public function startTransaction($name = '') {
    * @see \Drupal\Core\Database\Transaction::rollBack()
    */
   public function rollBack($savepoint_name = 'drupal_transaction') {
+    if ($this->transactionManager()) {
+      $this->transactionManager()->rollback($savepoint_name);
+      return;
+    }
     if (!$this->inTransaction()) {
       throw new TransactionNoActiveException();
     }
@@ -1359,6 +1437,7 @@ public function rollBack($savepoint_name = 'drupal_transaction') {
     // we need to throw an exception.
     $rolled_back_other_active_savepoints = FALSE;
     while ($savepoint = array_pop($this->transactionLayers)) {
+dump([__METHOD__, $savepoint, $savepoint_name]);
       if ($savepoint == $savepoint_name) {
         // If it is the last the transaction in the stack, then it is not a
         // savepoint, it is the transaction itself so we will need to roll back
@@ -1381,6 +1460,7 @@ public function rollBack($savepoint_name = 'drupal_transaction') {
     // Notify the callbacks about the rollback.
     $callbacks = $this->rootTransactionEndCallbacks;
     $this->rootTransactionEndCallbacks = [];
+dump([__METHOD__, '** callbacks']);
     foreach ($callbacks as $callback) {
       call_user_func($callback, FALSE);
     }
@@ -1469,6 +1549,10 @@ public function popTransaction($name) {
    * @see \Drupal\Core\Database\Connection::doCommit()
    */
   public function addRootTransactionEndCallback(callable $callback) {
+    if ($this->transactionManager()) {
+      $this->transactionManager()->addPostTransactionCallback($callback);
+      return;
+    }
     if (!$this->transactionLayers) {
       throw new \LogicException('Root transaction end callbacks can only be added when there is an active transaction.');
     }
@@ -1644,6 +1728,7 @@ abstract public function mapConditionOperator($operator);
    * @see \Drupal\Core\Database\Transaction
    */
   public function commit() {
+    @trigger_error(__METHOD__ . '() is deprecated in drupal:10.2.0 and is removed from drupal:11.0.0. Instead, @todo. See https://www.drupal.org/node/5555555', E_USER_DEPRECATED);
     throw new TransactionExplicitCommitNotAllowedException();
   }
 
diff --git a/core/lib/Drupal/Core/Database/Transaction.php b/core/lib/Drupal/Core/Database/Transaction.php
index 76d5fc8f5f..b03b2ca24a 100644
--- a/core/lib/Drupal/Core/Database/Transaction.php
+++ b/core/lib/Drupal/Core/Database/Transaction.php
@@ -48,6 +48,11 @@ class Transaction {
   protected $name;
 
   public function __construct(Connection $connection, $name = NULL) {
+    if ($connection->transactionManager()) {
+      $this->connection = $connection;
+      $this->name = $name;
+      return;
+    }
     $this->connection = $connection;
     // If there is no transaction depth, then no transaction has started. Name
     // the transaction 'drupal_transaction'.
@@ -66,6 +71,10 @@ public function __construct(Connection $connection, $name = NULL) {
   }
 
   public function __destruct() {
+    if ($this->connection->transactionManager()) {
+      $this->connection->transactionManager()->unpile($this->name);
+      return;
+    }
     // If we rolled back then the transaction would have already been popped.
     if (!$this->rolledBack) {
       $this->connection->popTransaction($this->name);
@@ -90,6 +99,10 @@ public function name() {
    * @see \Drupal\Core\Database\Connection::rollBack()
    */
   public function rollBack() {
+    if ($this->connection->transactionManager()) {
+      $this->connection->transactionManager()->rollback($this->name);
+      return;
+    }
     $this->rolledBack = TRUE;
     $this->connection->rollBack($this->name);
   }
diff --git a/core/lib/Drupal/Core/Database/Transaction/ClientConnectionTransactionState.php b/core/lib/Drupal/Core/Database/Transaction/ClientConnectionTransactionState.php
new file mode 100644
index 0000000000..b545d6b2de
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/Transaction/ClientConnectionTransactionState.php
@@ -0,0 +1,27 @@
+<?php
+
+/**
+ * @file
+ * Enumeration of the possible states of a client connection transaction.
+ */
+
+namespace Drupal\Core\Database\Transaction;
+
+/**
+ * Enumeration of the possible states of a client connection transaction.
+ */
+enum ClientConnectionTransactionState {
+
+  case Active;
+  case RolledBack;
+  case RollbackFailed;
+  case Committed;
+  case CommitFailed;
+
+  // In some cases the active transaction can be automatically committed by
+  // the database server (for example, MySql when a DDL statement is executed
+  // during a transaction). We track such cases with 'Voided' when we can
+  // detect them.
+  case Voided;
+
+}
diff --git a/core/lib/Drupal/Core/Database/Transaction/ManagerStackItem.php b/core/lib/Drupal/Core/Database/Transaction/ManagerStackItem.php
new file mode 100644
index 0000000000..5edca7915d
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/Transaction/ManagerStackItem.php
@@ -0,0 +1,24 @@
+<?php
+
+namespace Drupal\Core\Database\Transaction;
+
+/**
+ * A representation of a Drupal transaction on the TransactionManager stack.
+ */
+final class ManagerStackItem {
+
+  /**
+   * Constructor.
+   *
+   * @param string $name
+   *   The name of the Drupal transaction.
+   * @param \Drupal\Core\Database\Transaction\ManagerStackItemType $type
+   *   The type of the Drupal transaction, root or savepoint.
+   */
+  public function __construct(
+    public readonly string $name,
+    public readonly ManagerStackItemType $type,
+  ) {
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Database/Transaction/ManagerStackItemType.php b/core/lib/Drupal/Core/Database/Transaction/ManagerStackItemType.php
new file mode 100644
index 0000000000..763a758a9f
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/Transaction/ManagerStackItemType.php
@@ -0,0 +1,18 @@
+<?php
+
+/**
+ * @file
+ * Enumeration of the types of items in the Drupal transaction stack.
+ */
+
+namespace Drupal\Core\Database\Transaction;
+
+/**
+ * Enumeration of the types of items in the Drupal transaction stack.
+ */
+enum ManagerStackItemType {
+
+  case Root;
+  case Savepoint;
+
+}
diff --git a/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php b/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php
new file mode 100644
index 0000000000..96ded8e8fe
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php
@@ -0,0 +1,420 @@
+<?php
+
+namespace Drupal\Core\Database\Transaction;
+
+use Drupal\Core\Database\Connection;
+use Drupal\Core\Database\Transaction;
+use Drupal\Core\Database\TransactionCommitFailedException;
+use Drupal\Core\Database\TransactionNameNonUniqueException;
+use Drupal\Core\Database\TransactionNoActiveException;
+use Drupal\Core\Database\TransactionOutOfOrderException;
+
+/**
+ * The database transaction manager base class.
+ *
+ * On many databases transactions cannot nest. Instead, we track nested calls
+ * to transactions and collapse them into a single client transaction.
+ *
+ * Database drivers must implement their own class extending from this, and
+ * instantiate it via their Connection::driverTransactionManager() method.
+ *
+ * @see \Drupal\Core\Database\Connection::driverTransactionManager()
+ */
+abstract class TransactionManagerBase implements TransactionManagerInterface {
+
+  /**
+   * The stack of Drupal transactions currently active.
+   *
+   * @var array<string,ManagerStackItem>
+   */
+  private array $stack = [];
+
+  /**
+   * A list of Drupal transactions rolled back but not yet unpiled.
+   *
+   * @var array<string,true>
+   */
+  private array $rollbacks = [];
+
+  /**
+   * A list of post-transaction callbacks.
+   *
+   * @var callable[]
+   */
+  private array $postTransactionCallbacks = [];
+
+  /**
+   * The state of the underlying client connection transaction.
+   *
+   * Note that this is a proxy of the actual state on the database server,
+   * best determined through calls to methods in this class. The actual
+   * state on the database server could be different.
+   */
+  private ClientConnectionTransactionState $connectionTransactionState;
+
+  /**
+   * Constructor.
+   *
+   * @param \Drupal\Core\Database\Connection $connection
+   *   The database connection.
+   */
+  public function __construct(
+    protected readonly Connection $connection,
+  ) {
+  }
+
+  /**
+   * Returns the current depth of the transaction stack.
+   *
+   * @return int
+   *   The current depth of the transaction stack.
+   *
+   * @todo consider making this function protected.
+   */
+  public function stackDepth(): int {
+    return count($this->stack());
+  }
+
+  /**
+   * Returns the content of the transaction stack.
+   *
+   * Drivers should not override this method unless they also override the
+   * $stack property.
+   *
+   * @return array
+   *   The elements of the transaction stack.
+   */
+  protected function stack(): array {
+    return $this->stack;
+  }
+
+  /**
+   * Resets the transaction stack.
+   *
+   * Drivers should not override this method unless they also override the
+   * $stack property.
+   */
+  protected function resetStack(): void {
+    $this->stack = [];
+  }
+
+  /**
+   * Adds an item to the transaction stack.
+   *
+   * Drivers should not override this method unless they also override the
+   * $stack property.
+   */
+  protected function addStackItem(string $name, ManagerStackItem $item): void {
+    $this->stack[$name] = $item;
+  }
+
+  /**
+   * Removes an item from the transaction stack.
+   *
+   * Drivers should not override this method unless they also override the
+   * $stack property.
+   */
+  protected function removeStackItem(string $name): void {
+    unset($this->stack[$name]);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function inTransaction(): bool {
+    return (bool) $this->stackDepth() && $this->getConnectionTransactionState() === ClientConnectionTransactionState::Active;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function push(string $name = ''): Transaction {
+    if (!$this->inTransaction()) {
+      // If there is no transaction active, name the transaction
+      // 'drupal_transaction'.
+      $name = 'drupal_transaction';
+    }
+    elseif (!$name) {
+      // Within transactions, savepoints are used. Each savepoint requires a
+      // name. So if no name is present we need to create one.
+      $name = 'savepoint_' . $this->stackDepth();
+    }
+
+    if ($this->has($name)) {
+      throw new TransactionNameNonUniqueException($name . " is already in use.");
+    }
+
+    // Do the client-level processing.
+    if ($this->stackDepth() === 0) {
+      $this->beginClientTransaction();
+      $type = ManagerStackItemType::Root;
+      $this->setConnectionTransactionState(ClientConnectionTransactionState::Active);
+    }
+    else {
+      // If we're already in a Drupal transaction then we want to create a
+      // database savepoint, rather than try to begin another database
+      // transaction.
+      $this->addClientSavepoint($name);
+      $type = ManagerStackItemType::Savepoint;
+    }
+
+    // Push the transaction on the stack, increasing its depth.
+    $this->addStackItem($name, new ManagerStackItem($name, $type));
+
+    return new Transaction($this->connection, $name);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function unpile(string $name): void {
+    // If an already rolled back Drupal transaction, do nothing on the client
+    // connection, just cleanup the list of transactions rolled back.
+    if (isset($this->rollbacks[$name])) {
+      unset($this->rollbacks[$name]);
+      return;
+    }
+
+    if ($name !== 'drupal_transaction' && !$this->has($name)) {
+      throw new TransactionOutOfOrderException();
+    }
+
+    // Release the client transaction savepoint in case the Drupal transaction
+    // is not a root one.
+    if (
+      $this->has($name)
+      && $this->stack()[$name]->type === ManagerStackItemType::Savepoint
+      && $this->getConnectionTransactionState() === ClientConnectionTransactionState::Active
+    ) {
+      $this->releaseClientSavepoint($name);
+    }
+
+    // Remove the transaction from the stack.
+    $this->removeStackItem($name);
+
+    // If this was the last Drupal transaction open, we can commit the client
+    // transaction.
+    if (
+      $this->stackDepth() === 0
+      && $this->getConnectionTransactionState() === ClientConnectionTransactionState::Active
+    ) {
+      $this->processRootCommit();
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function rollback(string $name): void {
+    if (!$this->inTransaction()) {
+      throw new TransactionNoActiveException();
+    }
+
+    // Do the client-level processing.
+    match ($this->stack()[$name]->type) {
+      ManagerStackItemType::Root => $this->processRootRollback(),
+      ManagerStackItemType::Savepoint => $this->rollbackClientSavepoint($name),
+    };
+
+    // Rolled back item should match the last one in stack.
+    if ($name !== array_key_last($this->stack())) {
+      throw new TransactionOutOfOrderException();
+    }
+
+    $this->rollbacks[$name] = TRUE;
+    $this->removeStackItem($name);
+
+    // If this was the last Drupal transaction open, we can commit the client
+    // transaction.
+    if ($this->stackDepth() === 0 && $this->getConnectionTransactionState() === ClientConnectionTransactionState::Active) {
+      $this->processRootCommit();
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function addPostTransactionCallback(callable $callback): void {
+    if (!$this->inTransaction()) {
+      throw new \LogicException('Root transaction end callbacks can only be added when there is an active transaction.');
+    }
+    $this->postTransactionCallbacks[] = $callback;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function has(string $name): bool {
+    return isset($this->stack()[$name]);
+  }
+
+  /**
+   * Sets the state of the client connection transaction.
+   *
+   * Note that this is a proxy of the actual state on the database server,
+   * best determined through calls to methods in this class. The actual
+   * state on the database server could be different.
+   *
+   * Drivers should not override this method unless they also override the
+   * $connectionTransactionState property.
+   *
+   * @param \Drupal\Core\Database\Transaction\ClientConnectionTransactionState $state
+   *   The state of the client connection.
+   */
+  protected function setConnectionTransactionState(ClientConnectionTransactionState $state): void {
+    $this->connectionTransactionState = $state;
+  }
+
+  /**
+   * Gets the state of the client connection transaction.
+   *
+   * Note that this is a proxy of the actual state on the database server,
+   * best determined through calls to methods in this class. The actual
+   * state on the database server could be different.
+   *
+   * Drivers should not override this method unless they also override the
+   * $connectionTransactionState property.
+   *
+   * @return \Drupal\Core\Database\Transaction\ClientConnectionTransactionState
+   *   The state of the client connection.
+   */
+  protected function getConnectionTransactionState(): ClientConnectionTransactionState {
+    return $this->connectionTransactionState;
+  }
+
+  /**
+   * Processes the root transaction rollback.
+   */
+  protected function processRootRollback(): void {
+    $this->rollbackClientTransaction();
+    $this->processPostTransactionCallbacks();
+  }
+
+  /**
+   * Processes the root transaction commit.
+   *
+   * @throws \Drupal\Core\Database\TransactionCommitFailedException
+   *   If the commit of the root transaction failed.
+   */
+  protected function processRootCommit(): void {
+    $clientCommit = $this->commitClientTransaction();
+    $this->processPostTransactionCallbacks();
+    if (!$clientCommit) {
+      throw new TransactionCommitFailedException();
+    }
+  }
+
+  /**
+   * Processes the post-transaction callbacks.
+   */
+  protected function processPostTransactionCallbacks(): void {
+    if (!empty($this->postTransactionCallbacks)) {
+      $callbacks = $this->postTransactionCallbacks;
+      $this->postTransactionCallbacks = [];
+      foreach ($callbacks as $callback) {
+        call_user_func($callback, $this->getConnectionTransactionState() === ClientConnectionTransactionState::Committed || $this->getConnectionTransactionState() === ClientConnectionTransactionState::Voided);
+      }
+    }
+  }
+
+  /**
+   * Begins a transaction on the client connection.
+   *
+   * This is a PDO-based implementation. Drivers should override this method
+   * to use a method specific for the client.
+   *
+   * @return bool
+   *   Returns TRUE on success or FALSE on failure.
+   */
+  protected function beginClientTransaction(): bool {
+    return $this->connection->getClientConnection()->beginTransaction();
+  }
+
+  /**
+   * Adds a savepoint on the client transaction.
+   *
+   * This is a PDO-based implementation. Drivers should override this method
+   * to use a method specific for the client.
+   *
+   * @param string $name
+   *   The name of the savepoint.
+   *
+   * @return bool
+   *   Returns TRUE on success or FALSE on failure.
+   */
+  protected function addClientSavepoint(string $name): bool {
+    $this->connection->query('SAVEPOINT ' . $name);
+    return TRUE;
+  }
+
+  /**
+   * Rolls back to a savepoint on the client transaction.
+   *
+   * This is a PDO-based implementation. Drivers should override this method
+   * to use a method specific for the client.
+   *
+   * @param string $name
+   *   The name of the savepoint.
+   *
+   * @return bool
+   *   Returns TRUE on success or FALSE on failure.
+   */
+  protected function rollbackClientSavepoint(string $name): bool {
+    $this->connection->query('ROLLBACK TO SAVEPOINT ' . $name);
+    return TRUE;
+  }
+
+  /**
+   * Releases a savepoint on the client transaction.
+   *
+   * This is a PDO-based implementation. Drivers should override this method
+   * to use a method specific for the client.
+   *
+   * @param string $name
+   *   The name of the savepoint.
+   *
+   * @return bool
+   *   Returns TRUE on success or FALSE on failure.
+   */
+  protected function releaseClientSavepoint(string $name): bool {
+    $this->connection->query('RELEASE SAVEPOINT ' . $name);
+    return TRUE;
+  }
+
+  /**
+   * Rolls back a client transaction.
+   *
+   * This is a PDO-based implementation. Drivers should override this method
+   * to use a method specific for the client.
+   *
+   * @return bool
+   *   Returns TRUE on success or FALSE on failure.
+   */
+  protected function rollbackClientTransaction(): bool {
+    $clientRollback = $this->connection->getClientConnection()->rollBack();
+    $this->setConnectionTransactionState($clientRollback ?
+      ClientConnectionTransactionState::RolledBack :
+      ClientConnectionTransactionState::RollbackFailed
+    );
+    return $clientRollback;
+  }
+
+  /**
+   * Commits a client transaction.
+   *
+   * This is a PDO-based implementation. Drivers should override this method
+   * to use a method specific for the client.
+   *
+   * @return bool
+   *   Returns TRUE on success or FALSE on failure.
+   */
+  protected function commitClientTransaction(): bool {
+    $clientCommit = $this->connection->getClientConnection()->commit();
+    $this->setConnectionTransactionState($clientCommit ?
+      ClientConnectionTransactionState::Committed :
+      ClientConnectionTransactionState::CommitFailed
+    );
+    return $clientCommit;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Database/Transaction/TransactionManagerInterface.php b/core/lib/Drupal/Core/Database/Transaction/TransactionManagerInterface.php
new file mode 100644
index 0000000000..d6dc96ed29
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/Transaction/TransactionManagerInterface.php
@@ -0,0 +1,110 @@
+<?php
+
+namespace Drupal\Core\Database\Transaction;
+
+use Drupal\Core\Database\Transaction;
+
+/**
+ * Interface for the database transaction manager classes.
+ */
+interface TransactionManagerInterface {
+
+  /**
+   * Determines if there is an active transaction open.
+   *
+   * @return bool
+   *   TRUE if we're currently in a transaction, FALSE otherwise.
+   */
+  public function inTransaction(): bool;
+
+  /**
+   * Checks if a named Drupal transaction is active.
+   *
+   * @param string $name
+   *   The name of the transaction.
+   *
+   * @return bool
+   *   TRUE if the transaction is active, FALSE otherwise.
+   */
+  public function has(string $name): bool;
+
+  /**
+   * Pushes a new Drupal transaction on the stack.
+   *
+   * This begins a client connection transaction if there is not one active,
+   * or adds a savepoint to the active one.
+   *
+   * @param string $name
+   *   (optional) The name of the savepoint.
+   *
+   * @return \Drupal\Core\Database\Transaction
+   *   A Transaction object.
+   *
+   * @throws \Drupal\Core\Database\TransactionNameNonUniqueException
+   *   If a Drupal Transaction with the specified name exists already.
+   */
+  public function push(string $name = ''): Transaction;
+
+  /**
+   * Removes a Drupal transaction from the stack.
+   *
+   * The unpiled item does not necessarily need to be the last on the stack.
+   * This method should only be called by a Transaction object going out of
+   * scope.
+   *
+   * @param string $name
+   *   (optional) The name of the savepoint.
+   *
+   * @throws \Drupal\Core\Database\TransactionOutOfOrderException
+   *   If a Drupal Transaction with the specified name does not exist.
+   * @throws \Drupal\Core\Database\TransactionCommitFailedException
+   *   If the commit of the root transaction failed.
+   */
+  public function unpile(string $name): void;
+
+  /**
+   * Rolls back a Drupal transaction.
+   *
+   * Rollbacks for nested transactions need to occur in reverse order to the
+   * pushes to the stack. Rolling back the last active Drupal transaction leads
+   * to rolling back the client connection (or to committing it in the edge
+   * case when the root was unpiled earlier).
+   *
+   * @param string $name
+   *   (optional) The name of the savepoint.
+   *
+   * @throws \Drupal\Core\Database\TransactionNoActiveException
+   *   If there is no active client connection.
+   * @throws \Drupal\Core\Database\TransactionOutOfOrderException
+   *   If the order of rollback is not in reverse sequence against the pushes
+   *   to the stack.
+   * @throws \Drupal\Core\Database\TransactionCommitFailedException
+   *   If the commit of the root transaction failed.
+   */
+  public function rollback(string $name): void;
+
+  /**
+   * Adds a root transaction end callback.
+   *
+   * These callbacks are invoked immediately after the client transaction has
+   * been committed or rolled back.
+   *
+   * It can for example be used to avoid deadlocks on write-heavy tables that
+   * do not need to be part of the transaction, like cache tag invalidations.
+   *
+   * Another use case is that services using alternative backends like Redis
+   * and Memcache cache implementations can replicate the transaction-behavior
+   * of the database cache backend and avoid race conditions.
+   *
+   * An argument is passed to the callbacks that indicates whether the
+   * transaction was successful or not.
+   *
+   * @param callable $callback
+   *   The callback to invoke.
+   *
+   * @throws \LogicException
+   *   When a callback addition is attempted but no transaction is active.
+   */
+  public function addPostTransactionCallback(callable $callback): void;
+
+}
diff --git a/core/modules/sqlite/src/Driver/Database/sqlite/Connection.php b/core/modules/sqlite/src/Driver/Database/sqlite/Connection.php
index c46dc1bce6..e2a8063e13 100644
--- a/core/modules/sqlite/src/Driver/Database/sqlite/Connection.php
+++ b/core/modules/sqlite/src/Driver/Database/sqlite/Connection.php
@@ -7,6 +7,7 @@
 use Drupal\Core\Database\Connection as DatabaseConnection;
 use Drupal\Core\Database\StatementInterface;
 use Drupal\Core\Database\SupportsTemporaryTablesInterface;
+use Drupal\Core\Database\Transaction\TransactionManagerInterface;
 
 /**
  * SQLite implementation of \Drupal\Core\Database\Connection.
@@ -27,6 +28,11 @@ class Connection extends DatabaseConnection implements SupportsTemporaryTablesIn
    * Whether or not the active transaction (if any) will be rolled back.
    *
    * @var bool
+   *
+   * @deprecated in drupal:10.0.2 and is removed from drupal:11.0.0. It is
+   *   unused.
+   *
+   * @see https://www.drupal.org/node/5555555
    */
   protected $willRollback;
 
@@ -452,6 +458,13 @@ public function nextId($existing_id = 0) {
     return $this->query('SELECT [value] FROM {sequences}')->fetchField();
   }
 
+  /**
+   * {@inheritdoc}
+   */
+//  protected function driverTransactionManager(): TransactionManagerInterface {
+//    return new TransactionManager($this);
+//  }
+
   /**
    * {@inheritdoc}
    */
diff --git a/core/modules/sqlite/src/Driver/Database/sqlite/TransactionManager.php b/core/modules/sqlite/src/Driver/Database/sqlite/TransactionManager.php
new file mode 100644
index 0000000000..c65cd8615b
--- /dev/null
+++ b/core/modules/sqlite/src/Driver/Database/sqlite/TransactionManager.php
@@ -0,0 +1,11 @@
+<?php
+
+namespace Drupal\sqlite\Driver\Database\sqlite;
+
+use Drupal\Core\Database\Transaction\TransactionManagerBase;
+
+/**
+ * SQLite implementation of TransactionManagerInterface.
+ */
+class TransactionManager extends TransactionManagerBase {
+}
diff --git a/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php b/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
index ebbf60826a..d7dc312ccb 100644
--- a/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
+++ b/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
@@ -282,6 +282,7 @@ public function testTransactionWithDdlStatement() {
    * Inserts a single row into the testing table.
    */
   protected function insertRow($name) {
+dump([__METHOD__, $name, $this->connection->inTransaction(), $this->connection->transactionDepth()]);
     $this->connection->insert('test')
       ->fields([
         'name' => $name,
@@ -575,4 +576,45 @@ public function testQueryFailureInTransaction() {
     $this->assertEquals('24', $saved_age);
   }
 
+  /**
+   * Tests that adding a post-transaction callback fails with no transaction.
+   */
+  public function testRootTransactionEndCallbackAddedWithoutTransaction(): void {
+    $this->expectException(\LogicException::class);
+    $this->connection->addRootTransactionEndCallback([$this, 'rootTransactionCallback']);
+  }
+
+  /**
+   * Tests post-transaction callback executes after transaction commit.
+   */
+  public function testRootTransactionEndCallbackCalledOnCommit(): void {
+    $transaction = $this->connection->startTransaction();
+    $this->connection->addRootTransactionEndCallback([$this, 'rootTransactionCallback']);
+    $this->insertRow('row');
+    unset($transaction);
+    $this->assertRowPresent('row');
+    $this->assertRowPresent('rtcCommit');
+  }
+
+  /**
+   * Tests post-transaction callback executes after transaction rollback.
+   */
+  public function testRootTransactionEndCallbackCalledOnRollback(): void {
+    $transaction = $this->connection->startTransaction();
+    $this->connection->addRootTransactionEndCallback([$this, 'rootTransactionCallback']);
+    $this->insertRow('row');
+    $transaction->rollBack();
+    unset($transaction);
+    $this->assertRowAbsent('row');
+    $this->assertRowPresent('rtcRollback');
+  }
+
+  /**
+   * A post-transaction callback for testing purposes.
+   */
+  public function rootTransactionCallback(bool $success): void {
+dump([__METHOD__, $success]);
+    $this->insertRow($success ? 'rtcCommit' : 'rtcRollback');
+  }
+
 }
