diff --git a/core/lib/Drupal/Core/Database/Connection.php b/core/lib/Drupal/Core/Database/Connection.php
index 486d788b2c..a00bebf21e 100644
--- a/core/lib/Drupal/Core/Database/Connection.php
+++ b/core/lib/Drupal/Core/Database/Connection.php
@@ -545,17 +545,24 @@ public function getFullQualifiedTableName($table) {
    *
    * @return \Drupal\Core\Database\StatementInterface
    *   A PDO prepared statement ready for its execute() method.
+   *
+   * @throws \Drupal\Core\Database\DatabaseExceptionWrapper
    */
   public function prepareStatement(string $query, array $options): StatementInterface {
     $query = $this->prefixTables($query);
     if (!($options['allow_square_brackets'] ?? FALSE)) {
       $query = $this->quoteIdentifiers($query);
     }
-    // @todo in Drupal 10, only return the StatementWrapper.
-    // @see https://www.drupal.org/node/3177490
-    return $this->statementWrapperClass ?
-      new $this->statementWrapperClass($this, $this->connection, $query, $options['pdo'] ?? []) :
-      $this->connection->prepare($query, $options['pdo'] ?? []);
+    try {
+      // @todo in Drupal 10, only return the StatementWrapper.
+      // @see https://www.drupal.org/node/3177490
+      return $this->statementWrapperClass ?
+        new $this->statementWrapperClass($this, $this->connection, $query, $options['pdo'] ?? []) :
+        $this->connection->prepare($query, $options['pdo'] ?? []);
+    }
+    catch (\Exception $e) {
+      $this->exceptionHandler($e)->handleStatementException($query, $options);
+    }
   }
 
   /**
@@ -792,39 +799,46 @@ public function query($query, array $args = [], $options = []) {
     $options += $this->defaultOptions();
     assert(!isset($options['target']), 'Passing "target" option to query() has no effect. See https://www.drupal.org/node/2993033');
 
+    // We allow either a pre-bound statement object (deprecated) or a literal
+    // string. In either case, we want to end up with an executed statement
+    // object, which we pass to StatementInterface::execute.
+    if (is_string($query)) {
+      $this->expandArguments($query, $args);
+      // To protect against SQL injection, Drupal only supports executing one
+      // statement at a time.  Thus, the presence of a SQL delimiter (the
+      // semicolon) is not allowed unless the option is set.  Allowing
+      // semicolons should only be needed for special cases like defining a
+      // function or stored procedure in SQL. Trim any trailing delimiter to
+      // minimize false positives unless delimiter is allowed.
+      $trim_chars = " \xA0\t\n\r\0\x0B";
+      if (empty($options['allow_delimiter_in_query'])) {
+        $trim_chars .= ';';
+      }
+      $query = rtrim($query, $trim_chars);
+      if (strpos($query, ';') !== FALSE && empty($options['allow_delimiter_in_query'])) {
+        throw new \InvalidArgumentException('; is not supported in SQL strings. Use only one statement at a time.');
+      }
+      $stmt = $this->prepareStatement($query, $options);
+    }
+    elseif ($query instanceof StatementInterface) {
+      @trigger_error('Passing a StatementInterface object as a $query argument to ' . __METHOD__ . ' is deprecated in drupal:9.2.0 and is removed in drupal:10.0.0. Call the execute method from the StatementInterface object directly instead. See https://www.drupal.org/node/3154439', E_USER_DEPRECATED);
+      $stmt = $query;
+    }
+    elseif ($query instanceof \PDOStatement) {
+      @trigger_error('Passing a \\PDOStatement object as a $query argument to ' . __METHOD__ . ' is deprecated in drupal:9.2.0 and is removed in drupal:10.0.0. Call the execute method from the StatementInterface object directly instead. See https://www.drupal.org/node/3154439', E_USER_DEPRECATED);
+      $stmt = $query;
+    }
+
     try {
-      // We allow either a pre-bound statement object (deprecated) or a literal
-      // string. In either case, we want to end up with an executed statement
-      // object, which we pass to PDOStatement::execute.
-      if ($query instanceof StatementInterface) {
-        @trigger_error('Passing a StatementInterface object as a $query argument to ' . __METHOD__ . ' is deprecated in drupal:9.2.0 and is removed in drupal:10.0.0. Call the execute method from the StatementInterface object directly instead. See https://www.drupal.org/node/3154439', E_USER_DEPRECATED);
-        $stmt = $query;
+      if (is_string($query)) {
+        $stmt->execute($args, $options);
+      }
+      elseif ($query instanceof StatementInterface) {
         $stmt->execute(NULL, $options);
       }
       elseif ($query instanceof \PDOStatement) {
-        @trigger_error('Passing a \\PDOStatement object as a $query argument to ' . __METHOD__ . ' is deprecated in drupal:9.2.0 and is removed in drupal:10.0.0. Call the execute method from the StatementInterface object directly instead. See https://www.drupal.org/node/3154439', E_USER_DEPRECATED);
-        $stmt = $query;
         $stmt->execute();
       }
-      else {
-        $this->expandArguments($query, $args);
-        // To protect against SQL injection, Drupal only supports executing one
-        // statement at a time.  Thus, the presence of a SQL delimiter (the
-        // semicolon) is not allowed unless the option is set.  Allowing
-        // semicolons should only be needed for special cases like defining a
-        // function or stored procedure in SQL. Trim any trailing delimiter to
-        // minimize false positives unless delimiter is allowed.
-        $trim_chars = " \xA0\t\n\r\0\x0B";
-        if (empty($options['allow_delimiter_in_query'])) {
-          $trim_chars .= ';';
-        }
-        $query = rtrim($query, $trim_chars);
-        if (strpos($query, ';') !== FALSE && empty($options['allow_delimiter_in_query'])) {
-          throw new \InvalidArgumentException('; is not supported in SQL strings. Use only one statement at a time.');
-        }
-        $stmt = $this->prepareStatement($query, $options);
-        $stmt->execute($args, $options);
-      }
 
       // Depending on the type of query we may need to return a different value.
       // See DatabaseConnection::defaultOptions() for a description of each
@@ -846,13 +860,19 @@ public function query($query, array $args = [], $options = []) {
 
         default:
           throw new \PDOException('Invalid return directive: ' . $options['return']);
+
       }
     }
-    catch (\PDOException $e) {
+    catch (\Exception $e) {
       // Most database drivers will return NULL here, but some of them
       // (e.g. the SQLite driver) may need to re-run the query, so the return
       // value will be the same as for static::query().
-      return $this->handleQueryException($e, $query, $args, $options);
+      if (is_string($query)) {
+        return $this->exceptionHandler($e)->handleExecutionException($stmt, $args, $options);
+      }
+      else {
+        return $this->handleQueryException($e, $query, $args, $options);
+      }
     }
   }
 
@@ -875,8 +895,15 @@ public function query($query, array $args = [], $options = []) {
    *
    * @throws \Drupal\Core\Database\DatabaseExceptionWrapper
    * @throws \Drupal\Core\Database\IntegrityConstraintViolationException
+   *
+   * @deprecated in drupal:9.2.0 and is removed from drupal:10.0.0. Get a
+   *   handler through $this->exceptionHandler() instead, and use one of its
+   *   methods.
+   *
+   * @see https://www.drupal.org/node/3187222
    */
   protected function handleQueryException(\PDOException $e, $query, array $args = [], $options = []) {
+    @trigger_error('Connection::handleQueryException() is deprecated in drupal:9.2.0 and is removed in drupal:10.0.0. Get a handler through $this->exceptionHandler() instead, and use one of its methods. See https://www.drupal.org/node/3187222', E_USER_DEPRECATED);
     if ($options['throw_exception']) {
       // Wrap the exception in another exception, because PHP does not allow
       // overriding Exception::getMessage(). Its message is the extra database
@@ -998,6 +1025,10 @@ public function getDriverClass($class) {
             $this->driverClasses[$class] = Delete::class;
             break;
 
+          case 'ExceptionHandler':
+            $this->driverClasses[$class] = ExceptionHandler::class;
+            break;
+
           case 'Insert':
             $this->driverClasses[$class] = Insert::class;
             break;
@@ -1038,6 +1069,20 @@ public function getDriverClass($class) {
     return $this->driverClasses[$class];
   }
 
+  /**
+   * Returns the database exceptions handler.
+   *
+   * @param \Exception $exception
+   *   The exception.
+   *
+   * @return \Drupal\Core\Database\ExceptionHandler
+   *   The database exceptions handler.
+   */
+  public function exceptionHandler(\Exception $exception) {
+    $class = $this->getDriverClass('ExceptionHandler');
+    return new $class($exception);
+  }
+
   /**
    * Prepares and returns a SELECT query object.
    *
diff --git a/core/lib/Drupal/Core/Database/Driver/mysql/Connection.php b/core/lib/Drupal/Core/Database/Driver/mysql/Connection.php
index fe281cb3d9..2a9c5cb379 100644
--- a/core/lib/Drupal/Core/Database/Driver/mysql/Connection.php
+++ b/core/lib/Drupal/Core/Database/Driver/mysql/Connection.php
@@ -10,7 +10,6 @@
 use Drupal\Core\Database\DatabaseNotFoundException;
 use Drupal\Core\Database\DatabaseException;
 use Drupal\Core\Database\Connection as DatabaseConnection;
-use Drupal\Component\Utility\Unicode;
 use Drupal\Core\Database\TransactionNoActiveException;
 
 /**
@@ -89,29 +88,11 @@ class Connection extends DatabaseConnection {
    */
   protected $identifierQuotes = ['"', '"'];
 
-  /**
-   * {@inheritdoc}
-   */
-  public function query($query, array $args = [], $options = []) {
-    try {
-      return parent::query($query, $args, $options);
-    }
-    catch (DatabaseException $e) {
-      if ($e->getPrevious()->errorInfo[1] == 1153) {
-        // If a max_allowed_packet error occurs the message length is truncated.
-        // This should prevent the error from recurring if the exception is
-        // logged to the database using dblog or the like.
-        $message = Unicode::truncateBytes($e->getMessage(), self::MIN_MAX_ALLOWED_PACKET);
-        $e = new DatabaseExceptionWrapper($message, $e->getCode(), $e->getPrevious());
-      }
-      throw $e;
-    }
-  }
-
   /**
    * {@inheritdoc}
    */
   protected function handleQueryException(\PDOException $e, $query, array $args = [], $options = []) {
+    @trigger_error('Connection::handleQueryException() is deprecated in drupal:9.2.0 and is removed in drupal:10.0.0. Get a handler through $this->exceptionHandler() instead, and use one of its methods. See https://www.drupal.org/node/3187222', E_USER_DEPRECATED);
     // In case of attempted INSERT of a record with an undefined column and no
     // default value indicated in schema, MySql returns a 1364 error code.
     // Throw an IntegrityConstraintViolationException here like the other
diff --git a/core/lib/Drupal/Core/Database/Driver/mysql/ExceptionHandler.php b/core/lib/Drupal/Core/Database/Driver/mysql/ExceptionHandler.php
new file mode 100644
index 0000000000..7558b10300
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/Driver/mysql/ExceptionHandler.php
@@ -0,0 +1,56 @@
+<?php
+
+namespace Drupal\Core\Database\Driver\mysql;
+
+use Drupal\Component\Utility\Unicode;
+use Drupal\Core\Database\DatabaseExceptionWrapper;
+use Drupal\Core\Database\ExceptionHandler as BaseExceptionHandler;
+use Drupal\Core\Database\IntegrityConstraintViolationException;
+use Drupal\Core\Database\StatementInterface;
+
+/**
+ * MySql database exception handler class.
+ */
+class ExceptionHandler extends BaseExceptionHandler {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function handleExecutionException(StatementInterface $statement, array $arguments = [], array $options = []): void {
+    if (!($options['throw_exception'] ?? FALSE)) {
+      return;
+    }
+
+    if ($this->exception instanceof \PDOException) {
+      // Wrap the exception in another exception, because PHP does not allow
+      // overriding Exception::getMessage(). Its message is the extra database
+      // debug information.
+      $code = is_int($this->exception->getCode()) ? $this->exception->getCode() : 0;
+
+      // If a max_allowed_packet error occurs the message length is truncated.
+      // This should prevent the error from recurring if the exception is logged
+      // to the database using dblog or the like.
+      if (($this->exception->errorInfo[1] ?? NULL) === 1153) {
+        $message = Unicode::truncateBytes($this->exception->getMessage(), Connection::MIN_MAX_ALLOWED_PACKET);
+        throw new DatabaseExceptionWrapper($message, $code, $this->exception);
+      }
+
+      $message = $this->exception->getMessage() . ": " . $statement->getQueryString() . "; " . print_r($arguments, TRUE);
+
+      // SQLSTATE 23xxx errors indicate an integrity constraint violation. Also,
+      // in case of attempted INSERT of a record with an undefined column and no
+      // default value indicated in schema, MySql returns a 1364 error code.
+      if (
+        substr($this->exception->getCode(), -6, -3) == '23' ||
+        ($this->exception->errorInfo[1] ?? NULL) === 1364
+      ) {
+        throw new IntegrityConstraintViolationException($message, $code, $this->exception);
+      }
+
+      throw new DatabaseExceptionWrapper($message, 0, $this->exception);
+    }
+
+    throw $this->exception;
+  }
+
+}
diff --git a/core/lib/Drupal/Core/Database/Driver/sqlite/Connection.php b/core/lib/Drupal/Core/Database/Driver/sqlite/Connection.php
index 64957038d2..684a4c6b73 100644
--- a/core/lib/Drupal/Core/Database/Driver/sqlite/Connection.php
+++ b/core/lib/Drupal/Core/Database/Driver/sqlite/Connection.php
@@ -366,6 +366,7 @@ public function prepare($statement, array $driver_options = []) {
    * {@inheritdoc}
    */
   protected function handleQueryException(\PDOException $e, $query, array $args = [], $options = []) {
+    @trigger_error('Connection::handleQueryException() is deprecated in drupal:9.2.0 and is removed in drupal:10.0.0. Get a handler through $this->exceptionHandler() instead, and use one of its methods. See https://www.drupal.org/node/3187222', E_USER_DEPRECATED);
     // The database schema might be changed by another process in between the
     // time that the statement was prepared and the time the statement was run
     // (e.g. usually happens when running tests). In this case, we need to
diff --git a/core/lib/Drupal/Core/Database/Driver/sqlite/Statement.php b/core/lib/Drupal/Core/Database/Driver/sqlite/Statement.php
index d9b422b584..1e895629ea 100644
--- a/core/lib/Drupal/Core/Database/Driver/sqlite/Statement.php
+++ b/core/lib/Drupal/Core/Database/Driver/sqlite/Statement.php
@@ -90,6 +90,12 @@ public function execute($args = [], $options = []) {
       $return = parent::execute($args, $options);
     }
     catch (\PDOException $e) {
+      // The database schema might be changed by another process in between the
+      // time that the statement was prepared and the time the statement was run
+      // (e.g. usually happens when running tests). In this case, we need to
+      // re-run the query.
+      // @see http://www.sqlite.org/faq.html#q15
+      // @see http://www.sqlite.org/rescode.html#schema
       if (!empty($e->errorInfo[1]) && $e->errorInfo[1] === 17) {
         // The schema has changed. SQLite specifies that we must resend the query.
         $return = parent::execute($args, $options);
diff --git a/core/lib/Drupal/Core/Database/ExceptionHandler.php b/core/lib/Drupal/Core/Database/ExceptionHandler.php
new file mode 100644
index 0000000000..50ad96805f
--- /dev/null
+++ b/core/lib/Drupal/Core/Database/ExceptionHandler.php
@@ -0,0 +1,92 @@
+<?php
+
+namespace Drupal\Core\Database;
+
+/**
+ * Base Database exception handler class.
+ *
+ * This class handles exceptions thrown by the database layer. Database driver
+ * implementation can provide an alternative implementation to support special
+ * handling required by that database.
+ */
+class ExceptionHandler {
+
+  /**
+   * The exception to be handled.
+   *
+   * @var \Exception
+   */
+  protected $exception;
+
+  /**
+   * Constructs a ExceptionHandler object.
+   *
+   * @param \Exception $exception
+   *   The exception to be handled.
+   */
+  public function __construct(\Exception $exception) {
+    $this->exception = $exception;
+  }
+
+  /**
+   * Handles exceptions thrown during the preparation of statement objects.
+   *
+   * @param string $sql
+   *   The SQL statement that was requested to be prepared.
+   * @param array $options
+   *   An associative array of options to control how the database operation is
+   *   run.
+   *
+   * @throws \Drupal\Core\Database\DatabaseExceptionWrapper
+   */
+  public function handleStatementException(string $sql, array $options = []): void {
+    if (!($options['throw_exception'] ?? FALSE)) {
+      return;
+    }
+
+    if ($this->exception instanceof \PDOException) {
+      // Wrap the exception in another exception, because PHP does not allow
+      // overriding Exception::getMessage(). Its message is the extra database
+      // debug information.
+      $message = $this->exception->getMessage() . ": " . $sql . "; ";
+      throw new DatabaseExceptionWrapper($message, 0, $this->exception);
+    }
+
+    throw $this->exception;
+  }
+
+  /**
+   * Handles exceptions thrown during execution of statement objects.
+   *
+   * @param \Drupal\Core\Database\StatementInterface $statement
+   *   The statement object requested to be executed.
+   * @param array $arguments
+   *   An array of arguments for the prepared statement.
+   * @param array $options
+   *   An associative array of options to control how the database operation is
+   *   run.
+   *
+   * @throws \Drupal\Core\Database\DatabaseExceptionWrapper
+   * @throws \Drupal\Core\Database\IntegrityConstraintViolationException
+   */
+  public function handleExecutionException(StatementInterface $statement, array $arguments = [], array $options = []): void {
+    if (!($options['throw_exception'] ?? FALSE)) {
+      return;
+    }
+
+    if ($this->exception instanceof \PDOException) {
+      // Wrap the exception in another exception, because PHP does not allow
+      // overriding Exception::getMessage(). Its message is the extra database
+      // debug information.
+      $message = $this->exception->getMessage() . ": " . $statement->getQueryString() . "; " . print_r($arguments, TRUE);
+      // Match all SQLSTATE 23xxx errors.
+      if (substr($this->exception->getCode(), -6, -3) == '23') {
+        throw new IntegrityConstraintViolationException($message, $this->exception->getCode(), $this->exception);
+      }
+      throw new DatabaseExceptionWrapper($message, 0, $this->exception);
+    }
+
+    throw $this->exception;
+  }
+
+}
diff --git a/core/tests/Drupal/KernelTests/Core/Database/DatabaseExceptionWrapperTest.php b/core/tests/Drupal/KernelTests/Core/Database/DatabaseExceptionWrapperTest.php
index 0f4c06a328..30aeaa2283 100644
--- a/core/tests/Drupal/KernelTests/Core/Database/DatabaseExceptionWrapperTest.php
+++ b/core/tests/Drupal/KernelTests/Core/Database/DatabaseExceptionWrapperTest.php
@@ -50,14 +50,44 @@ public function testPrepareQuery() {
   }
 
   /**
-   * Tests Connection::prepareStatement exceptions.
+   * Tests deprecation of Connection::handleQueryException.
+   *
+   * @group legacy
+   */
+  public function testHandleQueryExceptionDeprecation(): void {
+    $this->expectDeprecation('Passing a StatementInterface object as a $query argument to Drupal\Core\Database\Connection::query is deprecated in drupal:9.2.0 and is removed in drupal:10.0.0. Call the execute method from the StatementInterface object directly instead. See https://www.drupal.org/node/3154439');
+    $this->expectDeprecation('Connection::handleQueryException() is deprecated in drupal:9.2.0 and is removed in drupal:10.0.0. Get a handler through $this->exceptionHandler() instead, and use one of its methods. See https://www.drupal.org/node/3187222');
+    $this->expectException(DatabaseExceptionWrapper::class);
+    $stmt = Database::getConnection()->prepareStatement('SELECT * FROM {does_not_exist}', []);
+    Database::getConnection()->query($stmt);
+  }
+
+  /**
+   * Tests Connection::prepareStatement exceptions on execution.
    */
-  public function testPrepareStatement() {
+  public function testPrepareStatementFailOnExecution() {
     $this->expectException(\PDOException::class);
     $stmt = Database::getConnection()->prepareStatement('bananas', []);
     $stmt->execute();
   }
 
+  /**
+   * Tests Connection::prepareStatement exceptions on preparation.
+   *
+   * Core database drivers use PDO emulated statements or the StatementPrefetch
+   * class, which defer the statement check to the moment of the execution. In
+   * order to test a failure, we have to force the connection not to emulate
+   * statement preparation. Still, this is only valid for drivers that implement
+   * StatementWrapper.
+   */
+  public function testPrepareStatementFailOnPreparation() {
+    $connection_info = Database::getConnectionInfo('default');
+    $connection_info['default']['pdo'][\PDO::ATTR_EMULATE_PREPARES] = FALSE;
+    Database::addConnectionInfo('default', 'foo', $connection_info['default']);
+    $foo_connection = Database::getConnection('foo', 'default');
+    $stmt = $foo_connection->prepareStatement('bananas', []);
+  }
+
   /**
    * Tests the expected database exception thrown for inexistent tables.
    */
diff --git a/core/tests/Drupal/Tests/Core/Database/ConnectionTest.php b/core/tests/Drupal/Tests/Core/Database/ConnectionTest.php
index 64efa32515..0b71cb7374 100644
--- a/core/tests/Drupal/Tests/Core/Database/ConnectionTest.php
+++ b/core/tests/Drupal/Tests/Core/Database/ConnectionTest.php
@@ -149,6 +149,11 @@ public function providerGetDriverClass() {
         'Drupal\corefake\Driver\Database\corefake',
         'Delete',
       ],
+      [
+        'Drupal\Core\Database\ExceptionHandler',
+        'Drupal\corefake\Driver\Database\corefake',
+        'ExceptionHandler',
+      ],
       [
         'Drupal\Core\Database\Query\Insert',
         'Drupal\corefake\Driver\Database\corefake',
@@ -201,6 +206,11 @@ public function providerGetDriverClass() {
         'Drupal\corefake\Driver\Database\corefakeWithAllCustomClasses',
         'Delete',
       ],
+      [
+        'Drupal\corefake\Driver\Database\corefakeWithAllCustomClasses\ExceptionHandler',
+        'Drupal\corefake\Driver\Database\corefakeWithAllCustomClasses',
+        'ExceptionHandler',
+      ],
       [
         'Drupal\corefake\Driver\Database\corefakeWithAllCustomClasses\Insert',
         'Drupal\corefake\Driver\Database\corefakeWithAllCustomClasses',
diff --git a/core/tests/fixtures/database_drivers/module/corefake/src/Driver/Database/corefakeWithAllCustomClasses/ExceptionHandler.php b/core/tests/fixtures/database_drivers/module/corefake/src/Driver/Database/corefakeWithAllCustomClasses/ExceptionHandler.php
new file mode 100644
index 0000000000..9dc9122124
--- /dev/null
+++ b/core/tests/fixtures/database_drivers/module/corefake/src/Driver/Database/corefakeWithAllCustomClasses/ExceptionHandler.php
@@ -0,0 +1,12 @@
+<?php
+
+namespace Drupal\corefake\Driver\Database\corefakeWithAllCustomClasses;
+
+use Drupal\Core\Database\ExceptionHandler as BaseExceptionHandler;
+
+/**
+ * CorefakeWithAllCustomClasses implementation of \Drupal\Core\Database\Delete.
+ */
+class ExceptionHandler extends BaseExceptionHandler {
+
+}
