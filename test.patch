diff --git a/core/includes/form.inc b/core/includes/form.inc
index 4f353d0088..ac3e15e1f9 100644
--- a/core/includes/form.inc
+++ b/core/includes/form.inc
@@ -6,6 +6,7 @@
  */
 
 use Drupal\Component\Utility\UrlHelper;
+use Drupal\Core\Database\IntegrityConstraintViolationException;
 use Drupal\Core\Render\Element;
 use Drupal\Core\Render\Element\RenderElement;
 use Drupal\Core\Template\Attribute;
@@ -897,9 +898,29 @@ function batch_process($redirect = NULL, Url $url = NULL, $redirect_callback = N
     // environments.
     \Drupal::moduleHandler()->alter('batch', $batch);
 
-    // Assign an arbitrary id: don't rely on a serial column in the 'batch'
-    // table, since non-progressive batches skip database storage completely.
-    $batch['id'] = \Drupal::database()->nextId();
+    // Assign an id: non-progressive batches skip database storage completely.
+    if ($batch['progressive']) {
+      try {
+        $batch['id'] = \Drupal::service('batch.storage')->getId();
+      }
+      catch (IntegrityConstraintViolationException $e) {
+        // @todo this is here to support the update path to deprecate
+        // Connection::nextId(). Remove in Drupal 11.
+        $connection = \Drupal::database();
+        $batch['id'] = $connection->nextId();
+        $connection->insert('batch')
+          ->fields([
+            'bid' => $batch['id'], 
+            'timestamp' => \Drupal::request->getRequestTime(),
+            'token' => '',
+            'batch' => NULL,
+          ])
+          ->execute();
+      }
+    }
+    else {
+      $batch['id'] = rand();
+    }
 
     // Move operations to a job queue. Non-progressive batches will use a
     // memory-based queue.
diff --git a/core/lib/Drupal/Core/Batch/BatchStorage.php b/core/lib/Drupal/Core/Batch/BatchStorage.php
index 3c44628ef9..81ba8ee613 100644
--- a/core/lib/Drupal/Core/Batch/BatchStorage.php
+++ b/core/lib/Drupal/Core/Batch/BatchStorage.php
@@ -123,10 +123,36 @@ public function cleanup() {
   public function create(array $batch) {
     // Ensure that a session is started before using the CSRF token generator.
     $this->session->start();
+    $this->doCreate($batch);
+  }
+
+  /**
+   * Saves a batch.
+   *
+   * @param array $batch
+   *   The array representing the batch to create.
+   */
+  protected function doCreate(array $batch) {
+    $this->connection->update('batch')
+      ->fields([
+        'token' => $this->csrfToken->get($batch['id']),
+        'batch' => serialize($batch),
+      ])
+      ->condition('bid', $batch['id'])
+      ->execute();
+  }
+
+  /**
+   * Returns a new batch id.
+   *
+   * @return int
+   *   A batch id.
+   */
+  public function getId(): int {
     $try_again = FALSE;
     try {
       // The batch table might not yet exist.
-      $this->doCreate($batch);
+      return $this->doGetId();
     }
     catch (\Exception $e) {
       // If there was an exception, try to create the table.
@@ -138,23 +164,22 @@ public function create(array $batch) {
     }
     // Now that the table has been created, try again if necessary.
     if ($try_again) {
-      $this->doCreate($batch);
+      return $this->doGetId();
     }
   }
 
   /**
-   * Saves a batch.
+   * Inserts a record in the table and returns the batch id.
    *
-   * @param array $batch
-   *   The array representing the batch to create.
+   * @return int
+   *   A batch id.
    */
-  protected function doCreate(array $batch) {
-    $this->connection->insert('batch')
+  protected function doGetId(): int {
+    return $this->connection->insert('batch')
       ->fields([
-        'bid' => $batch['id'],
         'timestamp' => REQUEST_TIME,
-        'token' => $this->csrfToken->get($batch['id']),
-        'batch' => serialize($batch),
+        'token' => '',
+        'batch' => NULL,
       ])
       ->execute();
   }
@@ -208,9 +233,7 @@ public function schemaDefinition() {
       'fields' => [
         'bid' => [
           'description' => 'Primary Key: Unique batch ID.',
-          // This is not a serial column, to allow both progressive and
-          // non-progressive batches. See batch_process().
-          'type' => 'int',
+          'type' => 'serial',
           'unsigned' => TRUE,
           'not null' => TRUE,
         ],
diff --git a/core/lib/Drupal/Core/ProxyClass/Batch/BatchStorage.php b/core/lib/Drupal/Core/ProxyClass/Batch/BatchStorage.php
index 5e6fc6df6d..4b54090cab 100644
--- a/core/lib/Drupal/Core/ProxyClass/Batch/BatchStorage.php
+++ b/core/lib/Drupal/Core/ProxyClass/Batch/BatchStorage.php
@@ -107,6 +107,14 @@ public function create(array $batch)
             return $this->lazyLoadItself()->create($batch);
         }
 
+        /**
+         * {@inheritdoc}
+         */
+        public function getId(): int
+        {
+            return $this->lazyLoadItself()->getId();
+        }
+
         /**
          * {@inheritdoc}
          */
diff --git a/core/modules/system/system.install b/core/modules/system/system.install
index 90d2a09ffe..f03210bbe3 100644
--- a/core/modules/system/system.install
+++ b/core/modules/system/system.install
@@ -1750,3 +1750,23 @@ function system_update_10100(&$sandbox = NULL) {
   }
 
 }
+
+/**
+ * Change the {batch} table [bid] field to serial.
+ */
+function system_update_10101(&$sandbox = NULL) {
+  $connection = \Drupal::database();
+  $schema = $connection->schema();
+
+  // Update batch table.
+  if ($schema->tableExists('batch')) {
+    $new = [
+      'description' => 'Primary Key: Unique batch ID.',
+      'type' => 'serial',
+      'unsigned' => TRUE,
+      'not null' => TRUE,
+    ];
+    $schema->changeField('batch', 'bid', 'bid', $new);
+  }
+
+}
