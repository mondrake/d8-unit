diff --git a/core/lib/Drupal/Core/Database/Connection.php b/core/lib/Drupal/Core/Database/Connection.php
index cdaf0d19dd..2b733a0ec8 100644
--- a/core/lib/Drupal/Core/Database/Connection.php
+++ b/core/lib/Drupal/Core/Database/Connection.php
@@ -242,6 +242,11 @@ abstract class Connection {
    */
   protected TransactionManagerInterface|FALSE $transactionManager;
 
+  /**
+   * Determines if the transaction manager is processing a transaction.
+   */
+  protected bool $isTransactionManagerStackActive = FALSE;
+
   /**
    * Constructs a Connection object.
    *
@@ -286,6 +291,21 @@ public function __construct(object $connection, array $connection_options) {
    * Ensures that the client connection can be garbage collected.
    */
   public function __destruct() {
+    // Ensure all still-open transactions get auto-committed. Usually, this
+    // happens when the Transaction::__destruct() method is invoked, but during
+    // shutdown the object transaction order is unreliable. If the connection
+    // is destroyed first, we need to make sure to auto-commit all still-open
+    // transactions.
+    // Also see https://www.drupal.org/project/drupal/issues/1608374.
+    if ($this->isTransactionManagerStackActive) {
+      $this->commitTransactionOnDestruct();
+    }
+    else {
+      foreach (array_reverse($this->transactionLayers) as $name => $active) {
+        $this->popTransaction($name);
+      }
+    }
+
     // Ensure that the circular reference caused by Connection::__construct()
     // using $this in the call to set the statement class can be garbage
     // collected.
@@ -1402,6 +1422,17 @@ protected function driverTransactionManager(): TransactionManagerInterface {
     throw new \LogicException('The database driver has no TransactionManager implementation');
   }
 
+  /**
+   * Sets the transaction manager state.
+   *
+   * This method should only be called by TransactionManagerInterface objects.
+   *
+   * @internal
+   */
+  public function setTransactionManagerStackState(bool $state): void {
+    $this->isTransactionManagerStackActive = $state;
+  }
+
   /**
    * Determines if there is an active transaction open.
    *
@@ -1691,6 +1722,17 @@ protected function doCommit() {
     }
   }
 
+  /**
+   * Commit on destruction if a client transaction is still active.
+   *
+   * This method should only be called by __destruct().
+   *
+   * @internal
+   */
+  protected function commitTransactionOnDestruct(): void {
+    $this->connection->commit();
+  }
+
   /**
    * Runs a limited-range query on this database object.
    *
diff --git a/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php b/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php
index 0205f7dd65..8c9277952b 100644
--- a/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php
+++ b/core/lib/Drupal/Core/Database/Transaction/TransactionManagerBase.php
@@ -96,7 +96,16 @@ public function __construct(
    * When destructing, $stack must have been already emptied.
    */
   public function __destruct() {
-    assert($this->stack === [], "Transaction \$stack was not empty. Active stack: " . $this->dumpStackItemsAsString());
+    // Ensure all still-open transactions get auto-committed. Usually, this
+    // happens when the Transaction::__destruct() method is invoked, but during
+    // shutdown the object transaction order is unreliable. If this object
+    // is destroyed first, we need to make sure to auto-commit the root
+    // transaction.
+    // Also see https://www.drupal.org/project/drupal/issues/1608374.
+    if (!empty($this->stack)) {
+dump($this->dumpStackItemsAsString());
+      $this->processRootCommit();
+    }
   }
 
   /**
@@ -378,6 +387,10 @@ public function has(string $name): bool {
    */
   protected function setConnectionTransactionState(ClientConnectionTransactionState $state): void {
     $this->connectionTransactionState = $state;
+    match ($state) {
+      ClientConnectionTransactionState::Active => $this->connection->setTransactionManagerStackState(TRUE),
+      default => $this->connection->setTransactionManagerStackState(FALSE),
+    };
   }
 
   /**
diff --git a/core/phpstan-baseline.neon b/core/phpstan-baseline.neon
index ba653f410f..3c44aa7462 100644
--- a/core/phpstan-baseline.neon
+++ b/core/phpstan-baseline.neon
@@ -349,6 +349,24 @@ parameters:
 			count: 1
 			path: lib/Drupal/Core/Config/TypedConfigManager.php
 
+		-
+			message: """
+				#^Access to deprecated property \\$transactionLayers of class Drupal\\\\Core\\\\Database\\\\Connection\\:
+				in drupal\\:10\\.2\\.0 and is removed from drupal\\:11\\.0\\.0\\. The
+				  transaction stack is now managed by TransactionManager\\.$#
+			"""
+			count: 1
+			path: lib/Drupal/Core/Database/Connection.php
+
+		-
+			message: """
+				#^Call to deprecated method popTransaction\\(\\) of class Drupal\\\\Core\\\\Database\\\\Connection\\:
+				in drupal\\:10\\.2\\.0 and is removed from drupal\\:11\\.0\\.0\\. Use
+				  TransactionManagerInterface methods instead\\.$#
+			"""
+			count: 1
+			path: lib/Drupal/Core/Database/Connection.php
+
 		-
 			message: """
 				#^Fetching deprecated class constant RETURN_AFFECTED of class Drupal\\\\Core\\\\Database\\\\Database\\:
@@ -2339,14 +2357,6 @@ parameters:
 			count: 1
 			path: modules/system/tests/modules/lazy_route_provider_install_test/src/PluginManager.php
 
-		-
-			message: """
-				#^Class Drupal\\\\service_provider_test\\\\TestClass implements deprecated interface Symfony\\\\Component\\\\DependencyInjection\\\\ContainerAwareInterface\\:
-				since Symfony 6\\.4, use dependency injection instead$#
-			"""
-			count: 1
-			path: modules/system/tests/modules/service_provider_test/src/TestClass.php
-
 		-
 			message: "#^Missing cache backend declaration for performance\\.$#"
 			count: 1
@@ -2372,6 +2382,14 @@ parameters:
 			count: 1
 			path: modules/system/tests/modules/plugin_test/src/Plugin/TestPluginManager.php
 
+		-
+			message: """
+				#^Class Drupal\\\\service_provider_test\\\\TestClass implements deprecated interface Symfony\\\\Component\\\\DependencyInjection\\\\ContainerAwareInterface\\:
+				since Symfony 6\\.4, use dependency injection instead$#
+			"""
+			count: 1
+			path: modules/system/tests/modules/service_provider_test/src/TestClass.php
+
 		-
 			message: """
 				#^Usage of deprecated trait Symfony\\\\Component\\\\DependencyInjection\\\\ContainerAwareTrait in class Drupal\\\\service_provider_test\\\\TestClass\\:
diff --git a/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php b/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
index b8a71abba1..0eb4a37f63 100644
--- a/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
+++ b/core/tests/Drupal/KernelTests/Core/Database/DriverSpecificTransactionTestBase.php
@@ -3,6 +3,7 @@
 namespace Drupal\KernelTests\Core\Database;
 
 use Drupal\Core\Database\Database;
+use Drupal\Core\Database\Transaction\ClientConnectionTransactionState;
 use Drupal\Core\Database\Transaction\StackItem;
 use Drupal\Core\Database\Transaction\StackItemType;
 use Drupal\Core\Database\TransactionExplicitCommitNotAllowedException;
@@ -780,17 +781,19 @@ public function rootTransactionCallback(bool $success): void {
   /**
    * Tests TransactionManager failure.
    */
-  public function testTransactionManagerFailureOnPendingStackItems(): void {
+  public function testConnectionDestructionWithPendingStackItems(): void {
     $connectionInfo = Database::getConnectionInfo();
     Database::addConnectionInfo('default', 'test_fail', $connectionInfo['default']);
     $testConnection = Database::getConnection('test_fail');
 
-    // Add a fake item to the stack.
-    $reflectionMethod = new \ReflectionMethod(get_class($testConnection->transactionManager()), 'addStackItem');
-    $reflectionMethod->invoke($testConnection->transactionManager(), 'bar', new StackItem('qux', StackItemType::Savepoint));
+    // Add a fake item to the stack, and pretend we have a transaction
+    // active.
+    $transactionManager = get_class($testConnection->transactionManager());
+    $reflectionAddStackItem = new \ReflectionMethod($transactionManager, 'addStackItem');
+    $reflectionAddStackItem->invoke($testConnection->transactionManager(), 'bar', new StackItem('qux', StackItemType::Root));
+    $reflectionSetConnectionTransactionState = new \ReflectionMethod($transactionManager, 'setConnectionTransactionState');
+    $reflectionSetConnectionTransactionState->invoke($testConnection->transactionManager(), ClientConnectionTransactionState::Active);
 
-    $this->expectException(\AssertionError::class);
-    $this->expectExceptionMessageMatches("/^Transaction .stack was not empty\\. Active stack: bar\\\\qux/");
     unset($testConnection);
     Database::closeConnection('test_fail');
   }
