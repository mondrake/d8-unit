diff --git a/core/modules/inline_form_errors/tests/src/Unit/FormErrorHandlerTest.php b/core/modules/inline_form_errors/tests/src/Unit/FormErrorHandlerTest.php
index 962f107955..7e3acc4180 100644
--- a/core/modules/inline_form_errors/tests/src/Unit/FormErrorHandlerTest.php
+++ b/core/modules/inline_form_errors/tests/src/Unit/FormErrorHandlerTest.php
@@ -118,14 +118,17 @@ protected function setUp(): void {
    * @covers ::setElementErrorsFromFormState
    */
   public function testErrorMessagesInline() {
+    $addErrorCallSequence = [
+      [['no title given', FALSE]],
+      [['element is invisible', FALSE]],
+      [['this missing element is invalid', FALSE]],
+      [['3 errors have been found: <ul-comma-list-mock><li-mock>Test 1</li-mock><li-mock>Test 2 &amp; a half</li-mock><li-mock>Test 3</li-mock></ul-comma-list-mock>', FALSE]],
+    ];
     $this->messenger->expects($this->exactly(4))
       ->method('addError')
-      ->withConsecutive(
-        ['no title given', FALSE],
-        ['element is invisible', FALSE],
-        ['this missing element is invalid', FALSE],
-        ['3 errors have been found: <ul-comma-list-mock><li-mock>Test 1</li-mock><li-mock>Test 2 &amp; a half</li-mock><li-mock>Test 3</li-mock></ul-comma-list-mock>', FALSE],
-      );
+      ->willReturnCallback(function (mixed ...$args) use (&$addErrorCallSequence): void {
+        $this->consecutiveCallsCallback($addErrorCallSequence, $args);
+      });
 
     $this->renderer->expects($this->once())
       ->method('renderPlain')
@@ -162,17 +165,20 @@ public function testErrorMessagesInline() {
    */
   public function testErrorMessagesNotInline() {
     // Asserts all messages are summarized.
+    $addMessageCallSequence = [
+      [['invalid', 'error', FALSE]],
+      [['invalid', 'error', FALSE]],
+      [['invalid', 'error', FALSE]],
+      [['no error message', 'error', FALSE]],
+      [['no title given', 'error', FALSE]],
+      [['element is invisible', 'error', FALSE]],
+      [['this missing element is invalid', 'error', FALSE]],
+    ];
     $this->messenger->expects($this->exactly(7))
       ->method('addMessage')
-      ->withConsecutive(
-        ['invalid', 'error', FALSE],
-        ['invalid', 'error', FALSE],
-        ['invalid', 'error', FALSE],
-        ['no error message', 'error', FALSE],
-        ['no title given', 'error', FALSE],
-        ['element is invisible', 'error', FALSE],
-        ['this missing element is invalid', 'error', FALSE],
-      );
+      ->willReturnCallback(function (mixed ...$args) use (&$addMessageCallSequence): void {
+        $this->consecutiveCallsCallback($addMessageCallSequence, $args);
+      });
 
     $this->renderer->expects($this->never())
       ->method('renderPlain');
diff --git a/core/modules/migrate/tests/src/Unit/MigrateSqlIdMapEnsureTablesTest.php b/core/modules/migrate/tests/src/Unit/MigrateSqlIdMapEnsureTablesTest.php
index f4a4dc2596..38b94f9734 100644
--- a/core/modules/migrate/tests/src/Unit/MigrateSqlIdMapEnsureTablesTest.php
+++ b/core/modules/migrate/tests/src/Unit/MigrateSqlIdMapEnsureTablesTest.php
@@ -124,12 +124,16 @@ public function testEnsureTablesNotExist() {
         ['migrate_map_sql_idmap_test', FALSE],
         ['migrate_message_sql_idmap_test', FALSE],
       ]);
+
+    $callSequence = [
+      [['migrate_map_sql_idmap_test', $map_table_schema]],
+      [['migrate_message_sql_idmap_test', $table_schema]],
+    ];
     $schema->expects($this->exactly(2))
       ->method('createTable')
-      ->withConsecutive(
-        ['migrate_map_sql_idmap_test', $map_table_schema],
-        ['migrate_message_sql_idmap_test', $table_schema],
-      );
+      ->willReturnCallback(function (mixed ...$args) use (&$callSequence): void {
+        $this->consecutiveCallsCallback($callSequence, $args);
+      });
 
     $this->runEnsureTablesTest($schema);
   }
@@ -152,36 +156,36 @@ public function testEnsureTablesExist() {
         ['migrate_map_sql_idmap_test', 'hash', FALSE],
         ['migrate_map_sql_idmap_test', 'source_ids_hash', FALSE],
       ]);
+    $rollbackFieldSpec = [
+      'type' => 'int',
+      'size' => 'tiny',
+      'unsigned' => TRUE,
+      'not null' => TRUE,
+      'default' => 0,
+      'description' => 'Flag indicating what to do for this item on rollback',
+    ];
+    $hashFieldSpec = [
+      'type' => 'varchar',
+      'length' => '64',
+      'not null' => FALSE,
+      'description' => 'Hash of source row data, for detecting changes',
+    ];
+    $sourceIdsHashFieldSpec = [
+      'type' => 'varchar',
+      'length' => '64',
+      'not null' => TRUE,
+      'description' => 'Hash of source ids. Used as primary key',
+    ];
+    $callSequence = [
+      [['migrate_map_sql_idmap_test', 'rollback_action', $rollbackFieldSpec]],
+      [['migrate_map_sql_idmap_test', 'hash', $hashFieldSpec]],
+      [['migrate_map_sql_idmap_test', 'source_ids_hash', $sourceIdsHashFieldSpec]],
+    ];
     $schema->expects($this->exactly(3))
       ->method('addField')
-      ->withConsecutive(
-        [
-          'migrate_map_sql_idmap_test', 'rollback_action', [
-            'type' => 'int',
-            'size' => 'tiny',
-            'unsigned' => TRUE,
-            'not null' => TRUE,
-            'default' => 0,
-            'description' => 'Flag indicating what to do for this item on rollback',
-          ],
-        ],
-        [
-          'migrate_map_sql_idmap_test', 'hash', [
-            'type' => 'varchar',
-            'length' => '64',
-            'not null' => FALSE,
-            'description' => 'Hash of source row data, for detecting changes',
-          ],
-        ],
-        [
-          'migrate_map_sql_idmap_test', 'source_ids_hash', [
-            'type' => 'varchar',
-            'length' => '64',
-            'not null' => TRUE,
-            'description' => 'Hash of source ids. Used as primary key',
-          ],
-        ],
-      );
+      ->willReturnCallback(function (mixed ...$args) use (&$callSequence): void {
+        $this->consecutiveCallsCallback($callSequence, $args);
+      });
 
     $this->runEnsureTablesTest($schema);
   }
diff --git a/core/modules/pgsql/tests/src/Unit/SchemaTest.php b/core/modules/pgsql/tests/src/Unit/SchemaTest.php
index 3b9192fdea..1cac9516d9 100644
--- a/core/modules/pgsql/tests/src/Unit/SchemaTest.php
+++ b/core/modules/pgsql/tests/src/Unit/SchemaTest.php
@@ -2,6 +2,7 @@
 
 namespace Drupal\Tests\pgsql\Unit;
 
+use Drupal\Core\Database\StatementInterface;
 use Drupal\pgsql\Driver\Database\pgsql\Schema;
 use Drupal\Tests\UnitTestCase;
 
@@ -48,21 +49,20 @@ public function testComputedConstraintName($table_name, $name, $expected) {
     $max_identifier_length = 63;
     $schema = new Schema($this->connection);
 
-    $statement = $this->createMock('\Drupal\Core\Database\StatementInterface');
+    $statement = $this->createMock(StatementInterface::class);
     $statement->expects($this->any())
       ->method('fetchField')
       ->willReturn($max_identifier_length);
 
+    $callSequence = [
+      [[$this->anything()], $statement],
+      [["SELECT 1 FROM pg_constraint WHERE conname = '{$expected}'"], $this->createMock(StatementInterface::class)],
+    ];
     $this->connection->expects($this->exactly(2))
       ->method('query')
-      ->withConsecutive(
-        [$this->anything()],
-        ["SELECT 1 FROM pg_constraint WHERE conname = '$expected'"],
-      )
-      ->willReturnOnConsecutiveCalls(
-        $statement,
-        $this->createMock('\Drupal\Core\Database\StatementInterface'),
-      );
+      ->willReturnCallback(function (mixed ...$args) use (&$callSequence): StatementInterface {
+        return $this->consecutiveCallsCallback($callSequence, $args);
+      });
 
     $schema->constraintExists($table_name, $name);
   }
diff --git a/core/modules/serialization/tests/src/Unit/Normalizer/EntityNormalizerTest.php b/core/modules/serialization/tests/src/Unit/Normalizer/EntityNormalizerTest.php
index 45a017c410..6de2d6b21e 100644
--- a/core/modules/serialization/tests/src/Unit/Normalizer/EntityNormalizerTest.php
+++ b/core/modules/serialization/tests/src/Unit/Normalizer/EntityNormalizerTest.php
@@ -94,12 +94,15 @@ public function testNormalize() {
       ->disableOriginalConstructor()
       ->onlyMethods(['normalize'])
       ->getMock();
+    $callSequence = [
+      [[$list_item_1, 'test_format']],
+      [[$list_item_2, 'test_format']],
+    ];
     $serializer->expects($this->exactly(2))
       ->method('normalize')
-      ->withConsecutive(
-        [$list_item_1, 'test_format'],
-        [$list_item_2, 'test_format'],
-      );
+      ->willReturnCallback(function (mixed ...$args) use (&$callSequence): void {
+        $this->consecutiveCallsCallback($callSequence, $args);
+      });
 
     $this->entityNormalizer->setSerializer($serializer);
 
@@ -220,12 +223,15 @@ public function testDenormalizeWithValidBundle() {
       ->disableOriginalConstructor()
       ->onlyMethods(['denormalize'])
       ->getMock();
+    $callSequence = [
+      [['value_1', get_class($key_1), NULL, ['target_instance' => $key_1, 'entity_type' => 'test']]],
+      [['value_2', get_class($key_2), NULL, ['target_instance' => $key_2, 'entity_type' => 'test']]],
+    ];
     $serializer->expects($this->exactly(2))
       ->method('denormalize')
-      ->withConsecutive(
-        ['value_1', get_class($key_1), NULL, ['target_instance' => $key_1, 'entity_type' => 'test']],
-        ['value_2', get_class($key_2), NULL, ['target_instance' => $key_2, 'entity_type' => 'test']],
-      );
+      ->willReturnCallback(function (mixed ...$args) use (&$callSequence): void {
+        $this->consecutiveCallsCallback($callSequence, $args);
+      });
 
     $this->entityNormalizer->setSerializer($serializer);
 
@@ -369,12 +375,15 @@ public function testDenormalizeWithNoBundle() {
       ->disableOriginalConstructor()
       ->onlyMethods(['denormalize'])
       ->getMock();
+    $callSequence = [
+      [['value_1', get_class($key_1), NULL, ['target_instance' => $key_1, 'entity_type' => 'test']]],
+      [['value_2', get_class($key_2), NULL, ['target_instance' => $key_2, 'entity_type' => 'test']]],
+    ];
     $serializer->expects($this->exactly(2))
       ->method('denormalize')
-      ->withConsecutive(
-        ['value_1', get_class($key_1), NULL, ['target_instance' => $key_1, 'entity_type' => 'test']],
-        ['value_2', get_class($key_2), NULL, ['target_instance' => $key_2, 'entity_type' => 'test']],
-      );
+      ->willReturnCallback(function (mixed ...$args) use (&$callSequence): void {
+        $this->consecutiveCallsCallback($callSequence, $args);
+      });
 
     $this->entityNormalizer->setSerializer($serializer);
 
diff --git a/core/tests/Drupal/Tests/Core/Cache/CacheCollectorTest.php b/core/tests/Drupal/Tests/Core/Cache/CacheCollectorTest.php
index 4debf2836a..88e4f70348 100644
--- a/core/tests/Drupal/Tests/Core/Cache/CacheCollectorTest.php
+++ b/core/tests/Drupal/Tests/Core/Cache/CacheCollectorTest.php
@@ -305,13 +305,15 @@ public function testUpdateCacheDelete() {
     ];
     // Set up mock expectation, on the second call the with the second argument
     // set to TRUE because we triggered a cache invalidation.
+    $callSequence = [
+      [[$this->cid], $cache],
+      [[$this->cid, TRUE], $cache],
+    ];
     $this->cacheBackend->expects($this->exactly(2))
       ->method('get')
-      ->withConsecutive(
-        [$this->cid],
-        [$this->cid, TRUE],
-      )
-      ->willReturn($cache);
+      ->willReturnCallback(function (mixed ...$args) use (&$callSequence): object {
+        return $this->consecutiveCallsCallback($callSequence, $args);
+      });
 
     $this->collector->delete($key);
 
diff --git a/core/tests/Drupal/Tests/Core/TempStore/PrivateTempStoreTest.php b/core/tests/Drupal/Tests/Core/TempStore/PrivateTempStoreTest.php
index efc048cf36..3454ecbb36 100644
--- a/core/tests/Drupal/Tests/Core/TempStore/PrivateTempStoreTest.php
+++ b/core/tests/Drupal/Tests/Core/TempStore/PrivateTempStoreTest.php
@@ -100,18 +100,16 @@ protected function setUp(): void {
    * @covers ::get
    */
   public function testGet() {
+    $callSequence = [
+      [['1:test_2'], FALSE],
+      [['1:test'], $this->ownObject],
+      [['1:test'], $this->otherObject],
+    ];
     $this->keyValue->expects($this->exactly(3))
       ->method('get')
-      ->withConsecutive(
-        ['1:test_2'],
-        ['1:test'],
-        ['1:test'],
-      )
-      ->willReturnOnConsecutiveCalls(
-        FALSE,
-        $this->ownObject,
-        $this->otherObject,
-      );
+      ->willReturnCallback(function (mixed ...$args) use (&$callSequence): object|FALSE {
+        return $this->consecutiveCallsCallback($callSequence, $args);
+      });
 
     $this->assertNull($this->tempStore->get('test_2'));
     $this->assertSame($this->ownObject->data, $this->tempStore->get('test'));
@@ -246,18 +244,16 @@ public function testDelete() {
       ->with('1:test_2')
       ->willReturn(TRUE);
 
+    $callSequence = [
+      [['1:test_1'], FALSE],
+      [['1:test_2'], $this->ownObject],
+      [['1:test_3'], $this->otherObject],
+    ];
     $this->keyValue->expects($this->exactly(3))
       ->method('get')
-      ->withConsecutive(
-        ['1:test_1'],
-        ['1:test_2'],
-        ['1:test_3'],
-      )
-      ->willReturnOnConsecutiveCalls(
-        FALSE,
-        $this->ownObject,
-        $this->otherObject,
-      );
+      ->willReturnCallback(function (mixed ...$args) use (&$callSequence): object|FALSE {
+        return $this->consecutiveCallsCallback($callSequence, $args);
+      });
     $this->keyValue->expects($this->once())
       ->method('delete')
       ->with('1:test_2');
diff --git a/core/tests/Drupal/Tests/Core/TempStore/SharedTempStoreTest.php b/core/tests/Drupal/Tests/Core/TempStore/SharedTempStoreTest.php
index 4df06f7a4c..f5a3aa1440 100644
--- a/core/tests/Drupal/Tests/Core/TempStore/SharedTempStoreTest.php
+++ b/core/tests/Drupal/Tests/Core/TempStore/SharedTempStoreTest.php
@@ -99,16 +99,15 @@ protected function setUp(): void {
    * @covers ::get
    */
   public function testGet() {
+    $callSequence = [
+      [['test_2'], FALSE],
+      [['test'], $this->ownObject],
+    ];
     $this->keyValue->expects($this->exactly(2))
       ->method('get')
-      ->withConsecutive(
-        ['test_2'],
-        ['test'],
-      )
-      ->willReturnOnConsecutiveCalls(
-        FALSE,
-        $this->ownObject,
-      );
+      ->willReturnCallback(function (mixed ...$args) use (&$callSequence): object|FALSE {
+        return $this->consecutiveCallsCallback($callSequence, $args);
+      });
 
     $this->assertNull($this->tempStore->get('test_2'));
     $this->assertSame($this->ownObject->data, $this->tempStore->get('test'));
@@ -120,18 +119,16 @@ public function testGet() {
    * @covers ::getIfOwner
    */
   public function testGetIfOwner() {
+    $callSequence = [
+      [['test_2'], FALSE],
+      [['test'], $this->ownObject],
+      [['test'], $this->otherObject],
+    ];
     $this->keyValue->expects($this->exactly(3))
       ->method('get')
-      ->withConsecutive(
-        ['test_2'],
-        ['test'],
-        ['test'],
-      )
-      ->willReturnOnConsecutiveCalls(
-        FALSE,
-        $this->ownObject,
-        $this->otherObject,
-      );
+      ->willReturnCallback(function (mixed ...$args) use (&$callSequence): object|FALSE {
+        return $this->consecutiveCallsCallback($callSequence, $args);
+      });
 
     $this->assertNull($this->tempStore->getIfOwner('test_2'));
     $this->assertSame($this->ownObject->data, $this->tempStore->getIfOwner('test'));
@@ -326,18 +323,16 @@ public function testDeleteIfOwner() {
       ->with('test_2')
       ->willReturn(TRUE);
 
+    $callSequence = [
+      [['test_1'], FALSE],
+      [['test_2'], $this->ownObject],
+      [['test_3'], $this->otherObject],
+    ];
     $this->keyValue->expects($this->exactly(3))
       ->method('get')
-      ->withConsecutive(
-        ['test_1'],
-        ['test_2'],
-        ['test_3'],
-      )
-      ->willReturnOnConsecutiveCalls(
-        FALSE,
-        $this->ownObject,
-        $this->otherObject,
-      );
+      ->willReturnCallback(function (mixed ...$args) use (&$callSequence): object|FALSE {
+        return $this->consecutiveCallsCallback($callSequence, $args);
+      });
     $this->keyValue->expects($this->once())
       ->method('delete')
       ->with('test_2');
diff --git a/core/tests/Drupal/Tests/UnitTestCase.php b/core/tests/Drupal/Tests/UnitTestCase.php
index 44f46e6bb8..58964c6e23 100644
--- a/core/tests/Drupal/Tests/UnitTestCase.php
+++ b/core/tests/Drupal/Tests/UnitTestCase.php
@@ -11,6 +11,7 @@
 use Drupal\Core\StringTranslation\PluralTranslatableMarkup;
 use Drupal\Tests\Traits\PhpUnitWarnings;
 use Drupal\TestTools\TestVarDumper;
+use PHPUnit\Framework\Constraint\Constraint;
 use PHPUnit\Framework\TestCase;
 use Prophecy\PhpUnit\ProphecyTrait;
 use Symfony\Component\VarDumper\VarDumper;
@@ -259,4 +260,49 @@ protected function getClassResolverStub() {
     return $class_resolver;
   }
 
+  /**
+   * Callback for consecutive calls to mocked objects.
+   *
+   * Since the removal of InvocationMocker::withConsecutive() from PHPUnit, we
+   * can use InvocationMocker::willReturnCallback() instead, passing a stack of
+   * expected calls to mocked methods. This method provides a generic callback
+   * for the purpose, checking actual arguments against expected ones and
+   * returning a value if needed.
+   *
+   * @param array $expectedConsecutiveCalls
+   *   An array of expected arguments and return values for a stack of calls to
+   *   the method. The first element of the array contains the expected call
+   *   arguments, either concrete values or Constraint objects (could be a
+   *   partial list, in which case the actual arguments in excess of the
+   *   expected ones are ignored). The second element, if specified, is
+   *   returned by the callback when the arguments match.
+   * @param array $actualArgs
+   *   The array of arguments actually passed to the mocked object.
+   *
+   * @return mixed
+   *   The value specified by the second array item of
+   *   $expectedConsecutiveCalls. NULL if not specified.
+   */
+  protected function consecutiveCallsCallback(array &$expectedConsecutiveCalls, array $actualArgs): mixed {
+    $key = key($expectedConsecutiveCalls);
+    $call = reset($expectedConsecutiveCalls);
+    unset($expectedConsecutiveCalls[$key]);
+    $expectedArgs = $call[0];
+
+    for ($i = 0; $i < count($expectedArgs); $i++) {
+      if ($expectedArgs[$i] instanceof Constraint) {
+        $expectedArgs[$i]->evaluate($actualArgs[$i]);
+      }
+      else {
+        $this->assertEquals($expectedArgs[$i], $actualArgs[$i], sprintf('Failed argument match in consecutive call #%d, argument #%d.', $key + 1, $i + 1));
+      }
+    }
+
+    if (array_key_exists(1, $call)) {
+      return $call[1];
+    }
+
+    return NULL;
+  }
+
 }
diff --git a/core/tests/Drupal/Tests/UnitTestCaseTest.php b/core/tests/Drupal/Tests/UnitTestCaseTest.php
index b5fd12cde8..e13b22ea36 100644
--- a/core/tests/Drupal/Tests/UnitTestCaseTest.php
+++ b/core/tests/Drupal/Tests/UnitTestCaseTest.php
@@ -2,6 +2,8 @@
 
 namespace Drupal\Tests;
 
+use PHPUnit\Framework\AssertionFailedError;
+
 /**
  * Tests for the UnitTestCase class.
  *
@@ -53,4 +55,64 @@ public function testVarDumpSeparateProcess() {
     $this->assertStringContainsString('banana', StreamCapturer::$cache);
   }
 
+  public function testConsecutiveCallsCallback(): void {
+    $callSequence = [
+      [['1:test_1'], FALSE],
+      [['1:test_2'], new \stdClass()],
+      [['1:test_3'], ['foo']],
+    ];
+    $this->assertFalse($this->consecutiveCallsCallback($callSequence, ['1:test_1']));
+    $this->assertEquals(new \stdClass(), $this->consecutiveCallsCallback($callSequence, ['1:test_2']));
+    $this->assertSame(['foo'], $this->consecutiveCallsCallback($callSequence, ['1:test_3']));
+    $this->assertEmpty($callSequence);
+  }
+
+  public function testConsecutiveCallsCallbackFail(): void {
+    $callSequence = [
+      [['1:test_1'], FALSE],
+      [['1:test_2'], new \stdClass()],
+      [['1:test_3'], ['foo']],
+    ];
+    $this->assertFalse($this->consecutiveCallsCallback($callSequence, ['1:test_1']));
+    $this->assertEquals(new \stdClass(), $this->consecutiveCallsCallback($callSequence, ['1:test_2']));
+
+    $this->expectException(AssertionFailedError::class);
+    $this->expectExceptionMessage('Failed argument match in consecutive call #3, argument #1.');
+    $this->assertSame(['foo'], $this->consecutiveCallsCallback($callSequence, ['bar']));
+  }
+
+  public function testConsecutiveCallsCallbackWithConstraintArguments(): void {
+    $callSequence = [
+      [['1:test_1'], FALSE],
+      [[$this->isType('object')], new \stdClass()],
+      [[$this->isType('string')], ['foo']],
+    ];
+    $this->assertFalse($this->consecutiveCallsCallback($callSequence, ['1:test_1']));
+    $this->assertEquals(new \stdClass(), $this->consecutiveCallsCallback($callSequence, [$this]));
+    $this->assertSame(['foo'], $this->consecutiveCallsCallback($callSequence, ['bar']));
+    $this->assertEmpty($callSequence);
+  }
+
+  public function testConsecutiveCallsCallbackWithConstraintArgumentsFail(): void {
+    $callSequence = [
+      [['1:test_1'], FALSE],
+      [[$this->isType('object')], new \stdClass()],
+      [[$this->isType('string')], ['foo']],
+    ];
+    $this->assertFalse($this->consecutiveCallsCallback($callSequence, ['1:test_1']));
+    $this->assertEquals(new \stdClass(), $this->consecutiveCallsCallback($callSequence, [$this]));
+
+#    $this->expectException(AssertionFailedError::class);
+#    $this->expectExceptionMessage('Failed argument match in consecutive call #3, argument #1.');
+    $this->assertSame(['foo'], $this->consecutiveCallsCallback($callSequence, [$this]));
+  }
+
+  public function testConsecutiveCallsCallbackExhaustedExpectations(): void {
+    $callSequence = [
+      [['1:test_1'], FALSE],
+    ];
+    $this->assertFalse($this->consecutiveCallsCallback($callSequence, ['1:test_1']));
+    $this->assertEquals(new \stdClass(), $this->consecutiveCallsCallback($callSequence, ['1:test_2']));
+  }
+
 }
